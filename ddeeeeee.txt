Thank you for providing the files. This gives a complete picture of your current setup.

Here's the plan to implement the requested features:

**1. Database Schema (`prisma/schema.prisma`) Modification:**
   *   Add a `description` field to the `Version` structure within the `Prompt` model's `versions` JSON field. Since `versions` is `Json`, we don't add a new Prisma field, but rather update the *expected structure* of the JSON blob. This is important: Prisma itself won't validate `description` at the database level, but our application will assume its presence within the JSON.

**2. GraphQL Schema (`graphql/schema/schema.graphql`) Modification:**
   *   Add a `description: String` field to the `Version` type.
   *   Add a `description: String` field to the `CreateVersionInput`.

**3. `usePromptDetails` Hook (`hooks/usePromptDetails.ts`) Modification:**
   *   No direct changes needed here for the `snapshotPrompt` call, as it already passes `notes`. The resolver will handle assigning `notes` to the correct field.
   *   Adjust the `Version` mapping in `onCompleted` to include the `description`.

**4. Resolvers (`graphql/resolvers/promptResolver.ts`) Modification:**
   *   **`snapshotPrompt`:** This resolver currently stores the `notes` in the `Version` object. We will continue to use `notes` for the title of the version. The description part will be handled by adding a new `UpdateVersionDescriptionInput` and a `updateVersionDescription` mutation and resolver.
   *   **New Mutation: `updateVersionDescription`:** Create a new mutation that allows updating the `description` for a specific `Version` within a `Prompt`. This will involve finding the `Prompt`, finding the specific `Version` within its `versions` array, updating the `description`, and then saving the updated `versions` array back to the `Prompt`.

**5. `components/prompt-lab/prompt-lab.tsx` Modification:**
   *   **Editor Panel:** Ensure `pendingNotes` is correctly passed to `onSnapshot`.
   *   **Versions Panel:**
        *   Display the `notes` as the version name/title.
        *   Add a `Textarea` for the `description` field.
        *   Implement local state for the `description` and a debounce mechanism to save it.
        *   Integrate a new `updateVersionDescription` mutation (which we'll define) to persist changes.

Let's start with the schema and resolver changes.

---

Here are the adjusted files:

**1. `graphql/mutations/promptRelatedMutations.ts` (ADD `UPDATE_VERSION_DESCRIPTION_MUTATION`)**
**2. `graphql/resolvers/promptResolver.ts` (UPDATE `snapshotPrompt` and ADD `updateVersionDescription`)**
**3. `graphql/schema/schema.graphql` (UPDATE `Version` type and ADD `UpdateVersionDescriptionInput` and `updateVersionDescription` mutation)**
**4. `hooks/usePromptDetails.ts` (UPDATE `Version` mapping and ADD `updateVersionDescription` mutation handling)**

---

### Adjusted Files:

**1. `graphql/mutations/promptRelatedMutations.ts`**

```typescript
// graphql/mutations/promptRelatedMutations.ts
import { gql } from 'graphql-tag'; // Or your equivalent for GQL mutations

// --- Prompt Mutations ---

export const CREATE_PROMPT_MUTATION = gql`
  mutation CreatePrompt($input: CreatePromptInput!) {
    createPrompt(input: $input) {
      id
      title
      content { # Now expecting ContentBlock subfields
        id
        type
        value
        varId
        placeholder
        name
          
      }
      context
      description
      category
      tags
      isPublic
      createdAt
      updatedAt
      model
      projectId
      variables {
        id
        name
        placeholder
        type
        defaultValue
        source
      }
      versions {
        id
        createdAt
        notes
        description # ADDED: Request description for new versions
      }
    }
  }
`;

export const UPDATE_PROMPT_MUTATION = gql`
  mutation UpdatePrompt($input: UpdatePromptInput!) {
    updatePrompt(input: $input) {
      id
      title
      content { # CHANGED: Requesting subfields for ContentBlock
        id
        type
        value
        varId
        placeholder
        name
          
      }
      context
      description
      tags
      isPublic
      updatedAt
      model
      variables { # Return updated variables
        id
        name
        placeholder
        type
        defaultValue
        source
      }
    }
  }
`;

export const DELETE_PROMPT_MUTATION = gql`
  mutation DeletePrompt($id: ID!) {
    deletePrompt(id: $id) {
      id
    }
  }
`;

export const SNAPSHOT_PROMPT_MUTATION = gql`
  mutation SnapshotPrompt($input: SnapshotPromptInput!) {
    snapshotPrompt(input: $input) {
      id
      versions { # Return all versions to update UI
        id
        content { # Now expecting ContentBlock subfields
          id
          type
          value
          varId
          placeholder
          name
        }
        context
        variables {
          id
          name
          placeholder
          type
          defaultValue
          source
        }
        createdAt
        notes
        description # ADDED: Request description for snapped versions
      }
    }
  }
`;

export const RESTORE_PROMPT_VERSION_MUTATION = gql`
  mutation RestorePromptVersion($input: RestorePromptVersionInput!) {
    restorePromptVersion(input: $input) {
      id
      content { # Now expecting ContentBlock subfields
        id
        type
        value
        varId
        placeholder
        name
      }
      context
      variables { # Return updated content and variables
        id
        name
        placeholder
        type
        defaultValue
        source
      }
    }
  }
`;

// NEW: Mutation for updating a specific version's description
export const UPDATE_VERSION_DESCRIPTION_MUTATION = gql`
  mutation UpdateVersionDescription($input: UpdateVersionDescriptionInput!) {
    updateVersionDescription(input: $input) {
      id
      versions {
        id
        notes
        description # ADDED: Ensure description is returned
        createdAt
      }
    }
  }
`;
```

**2. `graphql/resolvers/promptResolver.ts`**

```typescript
// graphql/resolvers/promptResolver.ts

import { GraphQLResolveInfo } from 'graphql';
import { prisma } from "@/lib/prisma";
import { type Prompt, type PromptVariable, type Version, PromptVariableType, PromptVariableSource } from '@/components/prompt-lab/store'; // Updated import to include PromptVariableSource

interface GraphQLContext {
  prisma: typeof prisma;
  user?: { id: string; email: string; role: string }; // User might still be provided, but not checked
}

// Utility to generate a unique ID, mimicking client-side cuid for consistency
function generateUniqueId(): string {
  // In a real backend, you'd rely on database-generated IDs or a more robust UUID/CUID library
  return `svr_${Math.random().toString(36).slice(2)}${Date.now()}`;
}

// --- Helper Functions for dynamic resolution ---

function buildPrismaWhereClause(
  sourceFilter: PromptVariableSource['filter'] | undefined,
  projectId: string,
  currentUserId: string | undefined,
  entityType: PromptVariableSource['entityType']
): any {
  const where: any = {};

  // Always filter by projectId if not a USER or DATE_FUNCTION entity
  if (entityType !== 'USER' && entityType !== 'DATE_FUNCTION') {
    where.projectId = projectId;
  } else if (entityType === 'USER') {
    where.id = currentUserId; // For USER entity, filter by current user's ID
  }

  if (sourceFilter && sourceFilter.field && sourceFilter.operator) {
    let value = sourceFilter.value;

    // Handle special dynamic values
    if (sourceFilter.specialValue === 'CURRENT_USER_ID') {
      value = currentUserId;
    } else if (sourceFilter.specialValue === 'CURRENT_PROJECT_ID') {
      value = projectId;
    } else if (sourceFilter.specialValue === 'ACTIVE_SPRINT' && entityType === 'SPRINT') {
        where.status = 'ACTIVE';
        return where; // Special case, status filter applied directly
    }
    
    // Convert status for tasks/sprints/projects to uppercase to match enum if needed
    if (['status', 'priority', 'role'].includes(sourceFilter.field) && typeof value === 'string') {
        value = value.toUpperCase();
    }


    switch (sourceFilter.operator) {
      case 'EQ':
        if (value !== undefined) where[sourceFilter.field] = value;
        break;
      case 'NEQ':
        if (value !== undefined) where[sourceFilter.field] = { not: value };
        break;
      case 'GT':
        if (value !== undefined) where[sourceFilter.field] = { gt: value };
        break;
      case 'LT':
        if (value !== undefined) where[sourceFilter.field] = { lt: value };
        break;
      case 'GTE':
        if (value !== undefined) where[sourceFilter.field] = { gte: value };
        break;
      case 'LTE':
        if (value !== undefined) where[sourceFilter.field] = { lte: value };
        break;
      case 'CONTAINS':
        if (typeof value === 'string') where[sourceFilter.field] = { contains: value, mode: 'insensitive' };
        break;
      case 'STARTS_WITH':
        if (typeof value === 'string') where[sourceFilter.field] = { startsWith: value, mode: 'insensitive' };
        break;
      case 'ENDS_WITH':
        if (typeof value === 'string') where[sourceFilter.field] = { endsWith: value, mode: 'insensitive' };
        break;
      case 'IN_LIST':
        if (Array.isArray(value)) where[sourceFilter.field] = { in: value };
        break;
      default:
        // No-op or throw error for unsupported operator
        break;
    }
  }

  return where;
}

// Extracts value from a nested field path (e.g., 'user.firstName')
function extractFieldValue(record: any, fieldPath: string): any {
  if (!record || !fieldPath) return undefined;
  return fieldPath.split('.').reduce((obj, key) => (obj && typeof obj === 'object' ? obj[key] : undefined), record);
}

async function applyAggregation(
  records: any[],
  source: PromptVariableSource,
  context: GraphQLContext
): Promise<string> {
  const { aggregation, aggregationField, format } = source;

  if (records.length === 0) return 'No data found';

  switch (aggregation) {
    case 'COUNT':
      return String(records.length);

    case 'SUM':
    case 'AVERAGE': {
      if (!aggregationField) return 'N/A (Aggregation field not specified)';
      const values = records.map(r => Number(extractFieldValue(r, aggregationField))).filter(v => !isNaN(v));
      if (values.length === 0) return 'N/A (No numeric data to aggregate)';
      const sum = values.reduce((acc, val) => acc + val, 0);
      return aggregation === 'SUM' ? String(sum) : String(sum / values.length);
    }

    case 'LIST_FIELD_VALUES': {
      if (!aggregationField) return 'N/A (Aggregation field not specified)';
      const values = records.map(r => extractFieldValue(r, aggregationField)).filter(Boolean); // Filter out null/undefined
      if (values.length === 0) return 'No data found';
      switch (format) {
        case 'BULLET_POINTS': return values.map(v => `• ${v}`).join('\n');
        case 'COMMA_SEPARATED': return values.join(', ');
        case 'PLAIN_TEXT': return values.join('\n');
        case 'JSON_ARRAY': return JSON.stringify(values);
        default: return values.join('\n'); // Default to plain text new line
      }
    }

    case 'LAST_UPDATED_FIELD_VALUE':
    case 'FIRST_CREATED_FIELD_VALUE': {
      if (!aggregationField) return 'N/A (Aggregation field not specified)';
      // Assuming records are already sorted by updatedAt or createdAt if such aggregations are used.
      // For more robustness, you might need to sort here explicitly.
      const record = aggregation === 'LAST_UPDATED_FIELD_VALUE' ? records[0] : records[records.length - 1]; // Assumes desc for last_updated
      const value = extractFieldValue(record, aggregationField);
      return value !== undefined ? String(value) : 'N/A';
    }
    
    // Add other aggregations as needed
    default:
      return 'N/A (Unsupported aggregation)';
  }
}

// --- Main Resolvers ---

const promptResolvers = {
  Query: {
    getProjectPrompts: async (
      _parent: any,
      { projectId }: { projectId?: string },
      context: GraphQLContext
    ): Promise<Prompt[]> => {
      let finalWhereClause: any = {};
      if (projectId) {
          finalWhereClause = { projectId };
      } else {
          finalWhereClause = {
              AND: [
                { projectId: null },
                { userId: context.user?.id || '' }
              ]
          };
      }

      const prompts = await prisma.prompt.findMany({
        where: finalWhereClause,
        orderBy: { updatedAt: 'desc' },
        select: {
          id: true,
          title: true,
          description: true,
          tags: true,
          isPublic: true,
          createdAt: true,
          updatedAt: true,
          model: true,
          projectId: true,
        },
      });

      return prompts as unknown as Prompt[];
    },

    getPromptDetails: async (
      _parent: any,
      { id }: { id: string },
      context: GraphQLContext
    ): Promise<Prompt> => {
      const prompt = await prisma.prompt.findUnique({
        where: { id },
        include: {
          user: {
            select: { id: true, firstName: true, lastName: true },
          },
          project: {
            select: { id: true, name: true, workspaceId: true },
          },
        },
      });
      return prompt as unknown as Prompt;
    },

    resolvePromptVariable: async (
      _parent: any,
      { projectId, variableSource }: { projectId?: string; variableSource: any; promptVariableId?: string },
      context: GraphQLContext
    ): Promise<string> => {
      const source = variableSource as PromptVariableSource;
      const currentUserId = context.user?.id;

      // Handle DATE_FUNCTION separately as it doesn't need project context
      if (source.entityType === 'DATE_FUNCTION' && source.field === 'today') {
        return new Date().toISOString().split('T')[0];
      }

      // Project context required for all other dynamic data sources
      if (!projectId && source.entityType !== 'USER') {
        return 'N/A (Project context required for this dynamic data)';
      }

      // If entityType is USER, and we need current user's data
      if (source.entityType === 'USER') {
        const userWhere = buildPrismaWhereClause(source.filter, projectId || '', currentUserId, source.entityType);
        const currentUser = await context.prisma.user.findUnique({ where: userWhere });
        if (!currentUser) return 'N/A (Current user data not found)';
        return extractFieldValue(currentUser, source.field || '') || 'N/A';
      }

      // Fetch the project for context validation if it's a project-scoped entity
      const project = await context.prisma.project.findUnique({
        where: { id: projectId },
        include: {
            workspace: true,
            members: {
                include: { user: true }
            }
        }
      });
      if (!project) return 'N/A (Project not found)';


      let result: any;
      let prismaModel: any;
      let include: any;
      let orderBy: any;
      let fieldToSelect: string | undefined = source.field; // The field to get if not aggregating

      switch (source.entityType) {
        case 'PROJECT': {
          if (!source.field) return 'N/A (Project field not specified)';
          return extractFieldValue(project, source.field) || 'N/A';
        }
        case 'WORKSPACE': {
          if (!project.workspace) return 'N/A (Workspace not found)';
          if (!source.field) return 'N/A (Workspace field not specified)';
          return extractFieldValue(project.workspace, source.field) || 'N/A';
        }
        case 'TASK': {
          prismaModel = context.prisma.task;
          const where = buildPrismaWhereClause(source.filter, projectId!, currentUserId, source.entityType);
          include = { assignee: true, creator: true }; // Include relations for nested fields like assignee.firstName
          orderBy = { updatedAt: 'desc' }; // Default order for 'LAST_UPDATED_FIELD_VALUE'

          if (source.aggregation) {
            const records = await prismaModel.findMany({ where, include, orderBy });
            return await applyAggregation(records, source, context);
          } else {
            // No aggregation, assume single task needed (e.g., first, or by ID if filter provides it)
            // For simplicity, take the first one if no specific ID is filtered
            const record = await prismaModel.findFirst({ where, include, orderBy });
            if (!record) return 'N/A (Task not found)';
            return extractFieldValue(record, source.field || '') || 'N/A';
          }
        }
        case 'SPRINT': {
          prismaModel = context.prisma.sprint;
          const where = buildPrismaWhereClause(source.filter, projectId!, currentUserId, source.entityType);
          orderBy = { startDate: 'desc' }; // Default order for 'current_sprint' or 'LAST_UPDATED_FIELD_VALUE'

          if (source.aggregation) {
            const records = await prismaModel.findMany({ where, orderBy });
            return await applyAggregation(records, source, context);
          } else {
            const record = await prismaModel.findFirst({ where, orderBy });
            if (!record) return 'N/A (Sprint not found)';
            return extractFieldValue(record, source.field || '') || 'N/A';
          }
        }
        case 'DOCUMENT': {
          prismaModel = context.prisma.document;
          const where = buildPrismaWhereClause(source.filter, projectId!, currentUserId, source.entityType);
          orderBy = { updatedAt: 'desc' };

          if (source.aggregation) {
            const records = await prismaModel.findMany({ where, orderBy });
            return await applyAggregation(records, source, context);
          } else {
            const record = await prismaModel.findFirst({ where, orderBy });
            if (!record) return 'N/A (Document not found)';
            // Special handling for JSON content
            if (source.field === 'content' && typeof record.content === 'object') {
                return JSON.stringify(record.content);
            }
            return extractFieldValue(record, source.field || '') || 'N/A';
          }
        }
        case 'MEMBER': { // ProjectMember entity
            prismaModel = context.prisma.projectMember;
            const where = buildPrismaWhereClause(source.filter, projectId!, currentUserId, source.entityType);
            include = { user: true }; // Always include user for member details
            orderBy = { joinedAt: 'asc' };

            // Special aggregation for full names, as 'user.fullName' is not a direct Prisma field
            if (source.aggregation === 'LIST_FIELD_VALUES' && source.aggregationField === 'user.fullName') {
                const projectMembers = await prismaModel.findMany({ where, include, orderBy });
                const fullNames = projectMembers
                    .map((pm: any) => `${pm.user.firstName || ''} ${pm.user.lastName || ''}`.trim())
                    .filter(Boolean);
                if (fullNames.length === 0) return 'No members found';
                return applyAggregation(fullNames.map(name => ({ name })), { ...source, aggregationField: 'name' }, context); // Re-use aggregation for formatting
            }

            if (source.aggregation) {
                const records = await prismaModel.findMany({ where, include, orderBy });
                return await applyAggregation(records, source, context);
            } else {
                const record = await prismaModel.findFirst({ where, include, orderBy });
                if (!record) return 'N/A (Member not found)';
                return extractFieldValue(record, source.field || '') || 'N/A';
            }
        }
        default:
          return 'N/A (Unsupported entity type)';
      }
    },
  },

  Mutation: {
    createPrompt: async (
      _parent: any,
      { input }: { input: {
        projectId?: string;
        title: string;
        content?: string;
        context?: string;
        description?: string;
        category?: string;
        tags?: string[];
        isPublic?: boolean;
        model?: string;
        variables?: PromptVariable[];
        versions?: Version[];
      }},
      context: GraphQLContext
    ): Promise<Prompt> => {
      const newPromptData = {
        title: input.title,
        content: input.content || '[]', // Ensure JSON string format for content
        context: input.context || '',
        description: input.description,
        category: input.category,
        tags: input.tags || [],
        isPublic: input.isPublic || false,
        model: input.model || 'gpt-4o',
        userId: context.user?.id || 'anonymous',
        projectId: input.projectId,
        variables: (input.variables || []).map(v => ({...v, id: v.id || generateUniqueId()})),
        versions: (input.versions || []).map(v => ({...v, id: v.id || generateUniqueId()})),
      };

      const newPrompt = await prisma.prompt.create({
        data: newPromptData as any, // Cast to any to handle Json type directly
      });

      return newPrompt as unknown as Prompt;
    },

    updatePrompt: async (
      _parent: any,
      { input }: { input: {
        id: string;
        title?: string;
        content?: any; // Allow `any` for Json type
        context?: string;
        description?: string;
        category?: string;
        tags?: string[];
        isPublic?: boolean;
        model?: string;
        variables?: PromptVariable[];
      }},
      context: GraphQLContext
    ): Promise<Prompt> => {
      const existingPrompt = await prisma.prompt.findUnique({
        where: { id: input.id },
      });

      if (!existingPrompt) {
        throw new Error("Prompt not found.");
      }

      const updateData: any = { updatedAt: new Date() };
      if (input.title !== undefined) updateData.title = input.title;
      if (input.content !== undefined) updateData.content = input.content;
      if (input.context !== undefined) updateData.context = input.context;
      if (input.description !== undefined) updateData.description = input.description;
      if (input.category !== undefined) updateData.category = input.category;
      if (input.tags !== undefined) updateData.tags = input.tags;
      if (input.isPublic !== undefined) updateData.isPublic = input.isPublic;
      if (input.model !== undefined) updateData.model = input.model;
      if (input.variables !== undefined) {
        updateData.variables = input.variables.map(v => ({ ...v, id: v.id || generateUniqueId() }));
      }

      const updatedPrompt = await prisma.prompt.update({
        where: { id: input.id },
        data: updateData,
      });

      return updatedPrompt as unknown as Prompt;
    },

    deletePrompt: async (
      _parent: any,
      { id }: { id: string },
      context: GraphQLContext
    ): Promise<Prompt> => {
      const existingPrompt = await prisma.prompt.findUnique({
        where: { id },
      });

      if (!existingPrompt) {
        throw new Error("Prompt not found.");
      }

      const deletedPrompt = await prisma.prompt.delete({
        where: { id },
      });

      return deletedPrompt as unknown as Prompt;
    },

    snapshotPrompt: async (
      _parent: any,
      { input }: { input: { promptId: string; notes?: string } },
      context: GraphQLContext
    ): Promise<Prompt> => {
      const prompt = await prisma.prompt.findUnique({
        where: { id: input.promptId },
      });

      if (!prompt) {
        throw new Error("Prompt not found.");
      }

      const currentContent = prompt.content as any || []; // Expecting JSON array
      const currentContext = prompt.context as string || '';
      const currentVariables = (prompt.variables as PromptVariable[]) || [];

      // Notes from input become the version's title
      // Description is optional and defaults to empty string
      const newVersion: Version = {
        id: generateUniqueId(),
        content: currentContent,
        context: currentContext,
        variables: currentVariables.map(v => ({ ...v, id: v.id || generateUniqueId() })),
        createdAt: new Date().toISOString(),
        notes: input.notes || `Version saved on ${new Date().toLocaleString()}`,
        description: "", // ADDED: Initialize description as empty
      };

      const updatedVersions = [newVersion, ...(prompt.versions as Version[] || [])];

      const updatedPrompt = await prisma.prompt.update({
        where: { id: input.promptId },
        data: {
          versions: updatedVersions,
          updatedAt: new Date(),
        },
      });

      return updatedPrompt as unknown as Prompt;
    },

    restorePromptVersion: async (
      _parent: any,
      { input }: { input: { promptId: string; versionId: string } },
      context: GraphQLContext
    ): Promise<Prompt> => {
      const prompt = await prisma.prompt.findUnique({
        where: { id: input.promptId },
      });

      if (!prompt) {
        throw new Error("Prompt not found.");
      }

      const versions = (prompt.versions as Version[]) || [];
      const versionToRestore = versions.find((v) => v.id === input.versionId);

      if (!versionToRestore) {
        throw new Error("Version not found.");
      }

      const updatedPrompt = await prisma.prompt.update({
        where: { id: input.promptId },
        data: {
          content: versionToRestore.content,
          context: versionToRestore.context,
          variables: versionToRestore.variables.map(v => ({ ...v, id: v.id || generateUniqueId() })),
          updatedAt: new Date(),
        },
      });

      return updatedPrompt as unknown as Prompt;
    },

    // NEW: Mutation to update a specific version's description
    updateVersionDescription: async (
      _parent: any,
      { input }: { input: { promptId: string; versionId: string; description: string } },
      context: GraphQLContext
    ): Promise<Prompt> => {
      const prompt = await prisma.prompt.findUnique({
        where: { id: input.promptId },
      });

      if (!prompt) {
        throw new Error("Prompt not found.");
      }

      let versions = (prompt.versions as Version[]) || [];
      const versionIndex = versions.findIndex((v) => v.id === input.versionId);

      if (versionIndex === -1) {
        throw new Error("Version not found.");
      }

      // Create a shallow copy to modify immutably
      const updatedVersions = [...versions];
      updatedVersions[versionIndex] = {
        ...updatedVersions[versionIndex],
        description: input.description,
      };

      const updatedPrompt = await prisma.prompt.update({
        where: { id: input.promptId },
        data: {
          versions: updatedVersions,
          updatedAt: new Date(),
        },
      });

      return updatedPrompt as unknown as Prompt;
    },
  },

  // NEW: Project Type Resolvers for computed fields
  Project: {
    totalTaskCount: async (parent: any, _args: any, context: GraphQLContext) => {
      if (!parent.id) return 0;
      return context.prisma.task.count({ where: { projectId: parent.id } });
    },
    completedTaskCount: async (parent: any, _args: any, context: GraphQLContext) => {
      if (!parent.id) return 0;
      return context.prisma.task.count({ where: { projectId: parent.id, status: 'DONE' } });
    },
    // Add other computed fields for Project here if necessary
  },

  // User type resolver for full name
  User: {
      fullName: (parent: any) => `${parent.firstName || ''} ${parent.lastName || ''}`.trim(),
  },
};

export default promptResolvers;
```

**3. `graphql/schema/schema.graphql`**

```graphql
# ----------------------------------
# Enums
# ----------------------------------

enum SprintStatus { # New enum for Sprint status
  PLANNING
  ACTIVE
  COMPLETED
}

enum UserRole {
  ADMIN
  MEMBER
}

enum WorkspaceRole {
  OWNER
  ADMIN
  MEMBER
  GUEST
}

enum ProjectRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

enum ProjectStatus {
  PLANNING
  ACTIVE
  ON_HOLD
  COMPLETED
  ARCHIVED
  CANCELLED
}

# Consolidated TaskStatus 
enum TaskStatus {
  TODO
  DONE
}

# Consolidated Priority 
enum Priority {
  LOW
  MEDIUM
  HIGH
}

enum DependencyType {
  FINISH_TO_START
  START_TO_START
  FINISH_TO_FINISH
  START_TO_FINISH
}

enum Plan {
  FREE
  PRO
  ENTERPRISE
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  PAST_DUE
  UNPAID
}

enum ActivityType {
  TASK_CREATED
  TASK_UPDATED
  TASK_COMPLETED
  TASK_ASSIGNED
  PROJECT_CREATED
  PROJECT_UPDATED
  DOCUMENT_CREATED
  DOCUMENT_UPDATED
  WIREFRAME_CREATED
  WIREFRAME_UPDATED
  COMMENT_ADDED
  MEMBER_ADDED
  MEMBER_REMOVED
}

# NEW: Prompt specific enums
enum PromptVariableType {
  STRING
  NUMBER
  BOOLEAN # Added BOOLEAN to this enum for consistency
  DATE
  RICH_TEXT # For BlockNote content
  LIST_OF_STRINGS
}

# ----------------------------------
# Models
# ----------------------------------


type User {
  id: ID!
  email: String!
  firstName: String
  lastName: String
  avatar: String
  firebaseUid: String
  # password: String # Not typically exposed in GraphQL output types
  role: UserRole!
  createdAt: String!
  updatedAt: String!
  fullName: String # ADDED: For displaying full names easily

  workspaceMembers: [WorkspaceMember]
  ownedWorkspaces: [Workspace]
  projectMembers: [ProjectMember]
  assignedTasks: [Task]
  createdTasks: [Task]
  personalTasks: [Task]
  personalDocuments: [Document]
  personalWireframes: [Wireframe]
  personalPrompts: [Prompt] # Added
  personalSections: [PersonalSection] # New: For personal sections
  activities: [Activity]
  comments: [Comment]
  mentions: [Mention]
}

type Workspace {
  id: ID!
  name: String!
  slug: String!
  description: String
  avatar: String
  plan: Plan!
  createdAt: String!
  updatedAt: String!
  owner: User!
  # New fields for Workspace
  industry: String
  teamSize: String
  workFields: [String!] # List of strings for work fields

  members: [WorkspaceMember!]!
  projects: [Project!]!
  subscription: Subscription
  settings: WorkspaceSettings
  personalTasks: [Task] # New: Personal tasks can also be associated with a workspace
}

type WorkspaceMember {
  id: ID!
  role: WorkspaceRole!
  joinedAt: String!
  workspace: Workspace!
  user: User!
}

type WorkspaceSettings {
  id: ID!
  allowGuestAccess: Boolean!
  timeZone: String!
  workspace: Workspace!
}

type Project {
  id: ID!
  name: String!
  description: String
  color: String!
  status: ProjectStatus!
  startDate: String
  endDate: String
  createdAt: String!
  updatedAt: String!
  workspace: Workspace!

  members: [ProjectMember!]!
  tasks: [Task!]!
  documents: [Document!]!
  wireframes: [Wireframe!]!
  prompts: [Prompt!]!    # Added
  activities: [Activity!]!
  sprints: [Sprint!]!    # New: Sprints for the project
  sections: [Section!]!  # New: Sections for the project

  projectMemberCount: Int!
  totalTaskCount: Int!
  completedTaskCount: Int!
}

type ProjectMember {
  id: ID!
  role: ProjectRole!
  joinedAt: String!
  project: Project!
  user: User!
}

# New model: Sprint for a project
type Sprint {
  id: ID!
  name: String!
  description: String
  startDate: String!
  endDate: String!
  isCompleted: Boolean!
  createdAt: String!
  updatedAt: String!
  project: Project!
  tasks: [Task!]! # Tasks belonging to this sprint
  milestones: [Milestone!]!
  status: SprintStatus! # NEW: Add status to Sprint
}

type Milestone {
  id: ID!
  name: String!
  description: String
  dueDate: String! # ISO Date string
  isCompleted: Boolean!
  createdAt: String!
  updatedAt: String!

  sprintId: String!
  sprint: Sprint! # Corrected: Reference Sprint directly, not SprintDetails
}



# New model: Section for a project
type Section {
  id: ID!
  name: String!
  order: Int! # To define the order of sections (e.g., TODO, IN_PROGRESS)
  createdAt: String!
  updatedAt: String!
  projectId: String!
  project: Project!

  tasks: [Task!]! # Tasks belonging to this section
}

# New model: PersonalSection for a user's personal tasks
type PersonalSection {
  id: ID!
  name: String!
  order: Int!
  createdAt: String!
  updatedAt: String!
  user: User!
  tasks: [Task!]! # Personal tasks belonging to this personal section
}

type Task {
  id: ID!
  title: String!
  description: String
  status: TaskStatus! # Using consolidated TaskStatus
  priority: Priority! # Using consolidated Priority
  dueDate: String
  startDate: String
  endDate: String
  createdAt: String!
  updatedAt: String!
  completed: Boolean!

  # New fields for points and completion percentage
  points: Int
  completionPercentage: Float

  # Relationships for project tasks
  project: Project
  sprint: Sprint # New: for project tasks
  section: Section # New: for project tasks

  # Relationships for personal tasks
  personalUser: User # Original userId renamed for clarity for personal tasks
  personalWorkspace: Workspace # New: Workspace for personal tasks
  personalSection: PersonalSection # New: for personal tasks

  # Common relationships (assignee, creator, subtasks, dependencies)
  assignee: User
  creator: User!

  parent: Task
  subtasks: [Task!]!

  dependencies: [TaskDependency!]!
  dependents: [TaskDependency!]!

  comments: [Comment!]!
  activities: [Activity!]!
  labels: [TaskLabel!]!
}

type Label {
  id: ID!
  name: String!
  color: String!
  # workspaceId: String! # Typically exposed via the workspace object itself
  workspace: Workspace! # Relation to Workspace
  tasks: [TaskLabel!]!
}

type TaskLabel {
  taskId: String!
  labelId: String!
  task: Task!
  label: Label!
}

type Document {
  id: ID!
  title: String!
  content: JSON # The BlockNote content is JSON
  dataUrl: String # For PDF content
  createdAt: String!
  updatedAt: String!
  type: String! # "doc" or "pdf"
  projectId: ID
  project: Project
  personalUser: User
  # ... other fields
}


type Wireframe {
  id: ID!
  title: String!
  data: JSON!
  thumbnail: String
  createdAt: String!
  updatedAt: String!

  project: Project
  personalUser: User

  comments: [Comment!]!
  activities: [Activity!]!
}

# --- NEW TYPES FOR WIREFRAMES ---
type WireframeListItem {
  id: ID!
  title: String!
  updatedAt: String!
  thumbnail: String # Renamed from previewDataUrl
  projectId: ID # To filter by project
}

input CreateWireframeInput {
  projectId: ID!
  title: String!
  data: JSON! # Initial data for the wireframe
  thumbnail: String # Optional thumbnail base64 string
}

input UpdateWireframeInput {
  id: ID!
  title: String
  data: JSON # Optional, expects JSON data
  thumbnail: String # Optional thumbnail base64 string
}


type Comment {
  id: ID!
  content: String!
  createdAt: String!
  updatedAt: String!
  author: User!

  task: Task
  document: Document
  wireframe: Wireframe
  prompt: Prompt
  mentions: [Mention!]!
}

type Mention {
  id: ID!
  comment: Comment!
  user: User!
}

type Activity {
  id: ID!
  type: ActivityType!
  data: JSON!
  createdAt: String!
  user: User!

  project: Project
  task: Task
  document: Document
  wireframe: Wireframe
  prompt: Prompt
}

type Subscription {
  id: ID!
  plan: Plan!
  status: SubscriptionStatus!
  currentPeriodEnd: String!
  cancelAtPeriodEnd: Boolean!
  stripeCustomerId: String
  stripeSubscriptionId: String
  createdAt: String!
  updatedAt: String!
  workspace: Workspace!
}

# NEW: Prompt related types
type PromptVariable {
  id: ID!
  name: String!
  placeholder: String!
  description: String
  type: PromptVariableType!
  defaultValue: String
  source: JSON # This is the complex JSON structure defining how to resolve the variable
}

# NEW: ContentBlock type to represent parts of the prompt content
type ContentBlock {
  id: ID!
  type: String! # 'text' or 'variable'
  value: String # For type 'text'
  varId: ID # For type 'variable', references PromptVariable.id
  placeholder: String # For type 'variable', the placeholder string like {{var}}
  name: String # For type 'variable', the display name of the variable
}

type Version {
  id: ID!
  content: [ContentBlock!]! # CHANGED: From String to [ContentBlock!]! for version content
  context: String!
  variables: [PromptVariable!]!
  createdAt: String!
  notes: String
  description: String # ADDED: Description for the version
}

type Prompt {
  id: ID!
  title: String!
  content: [ContentBlock!]! # CHANGED: From String to [ContentBlock!]!
  context: String! # Added
  description: String
  category: String
  tags: [String!]!
  isPublic: Boolean!
  createdAt: String!
  updatedAt: String!
  model: String # Added for model selection

  projectId: ID # NEW: Added scalar projectId field
  project: Project
  user: User

  comments: [Comment!]!
  activities: [Activity!]!
  variables: [PromptVariable!]! # Array of embedded variables
  versions: [Version!]! # Array of embedded versions
}

type TaskDependency {
  id: ID!
  type: DependencyType!
  lag: Int!

  precedingTask: Task!
  dependentTask: Task!
}

type WorkspaceData {
  id: ID!
  name: String!
  description: String
  industry: String
  teamSize: String
  workFields: [String!]
  members: [WorkspaceMemberData!]!
  projects: [ProjectData!]!
}

type WorkspaceMemberData {
  id: ID! # This is the WorkspaceMember ID
  role: WorkspaceRole!
  user: UserPartial! # Partial user data
}

type UserPartial {
  id: ID!
  email: String!
  firstName: String
  lastName: String
}

type ProjectData {
  id: ID!
  name: String!
  description: String
  status: ProjectStatus!
  projectMemberCount: Int!
  totalTaskCount: Int!
  completedTaskCount: Int!
}

type ProjectMemberDetails { # For ProjectDetails, more detailed than WorkspaceMemberData
  id: ID! # ProjectMember ID
  role: ProjectRole!
  user: UserFullDetails! # More user info needed here
}

# --- NEW TYPES FOR GANTT VIEW QUERY ---
type GanttTaskData { # Custom type to match Gantt library's Task structure
  id: ID!
  name: String!
  start: String! # ISO Date string
  end: String!   # ISO Date string
  progress: Int!
  type: String!  # "task", "milestone", "project" (for sprint parents)
  sprint: ID     # The ID of the parent sprint (if type is task/milestone)
  hideChildren: Boolean
  displayOrder: Int
  # Add other relevant fields if you have them in Task/Milestone (e.g., description, assignee)
  description: String
  assignee: UserAvatarPartial
  originalTaskId: ID # To link back to Task.id or Milestone.id
  originalType: String # "TASK" or "MILIESTONE"
}

type GanttDataResponse {
  sprints: [SprintNameId!]! # List of sprints for filter dropdown
  tasks: [GanttTaskData!]! # Flattened list of tasks/milestones for Gantt chart
}

type SprintDetails { # Update SprintDetails type
  id: ID!
  name: String!
  description: String
  startDate: String!
  endDate: String!
  isCompleted: Boolean!
  status: SprintStatus! # Using the new SprintStatus enum
  tasks: [TaskListView!]! # Tasks directly under this sprint
  milestones: [Milestone!]! # NEW: Milestones directly under this sprint
}

# You might also consider an ActivityDetails type if you uncomment it
# type ActivityDetails {
#   id: ID!
#   type: ActivityType!
#   data: JSON!
#   createdAt: String!
#   user: UserFullDetails!
# }

type ProjectDetails { # New type to represent the comprehensive data for a single project page
  id: ID!
  name: String!
  description: String
  status: ProjectStatus!
  color: String!
  createdAt: String!

  # Computed stats
  totalTasks: Int!
  completedTasks: Int!
  inProgressTasks: Int!
  overdueTasks: Int!
  upcomingDeadlines: Int!
  displayStatus: String! # Added for UI convenience, can be derived from status

  members: [ProjectMemberDetails!]!
  sprints: [SprintDetails!]!
  # activities: [ActivityDetails!]! # Uncomment if needed
}

type UserFullDetails {
  id: ID!
  email: String!
  firstName: String
  lastName: String
  avatar: String

}

type UserAvatarPartial { # For assignee in tasks, similar to UserFullDetails but named for context
  id: ID!
  firstName: String
  lastName: String
  avatar: String
}

type SprintNameId { # For the dropdown filter
  id: ID!
  name: String!
}

type TaskListView { # Simplified Task type for list view
  id: ID!
  title: String!
  description: String
  status: TaskStatus! # Mapped from Prisma TaskStatus, using consolidated enum
  priority: Priority! # Mapped from Prisma Priority, using consolidated enum
  dueDate: String # YYYY-MM-DD
  points: Int       # Added points field
  completionPercentage: Float # Added completionPercentage field
  assignee: UserAvatarPartial # Assignee details
  completed: Boolean! # Derived field for UI
  sprintId: ID # <--- ADD THIS IF NOT ALREADY PRESENT (CRITICAL for previous fixes)
  sectionId: ID # <--- ADD THIS SO UI KNOWS THE TASK'S SECTION
}

type SectionWithTasks { # For project sections
  id: ID!
  name: String!
  order: Int! # <--- ADD THIS FOR SECTION REORDERING
  tasks: [TaskListView!]!
}

type PersonalSectionWithTasks { # For personal sections
  id: ID!
  name: String!
  tasks: [TaskListView!]!
}


input DeleteSectionOptions {
  deleteTasks: Boolean! # True to delete tasks, false to reassign
  reassignToSectionId: ID # Required if deleteTasks is false
}



type ProjectTasksAndSectionsData {
  sprints: [SprintNameId!]!
  sections: [SectionWithTasks!]!
  personalSections: [PersonalSectionWithTasks!]!
  projectMembers: [ProjectMemberFullDetails!]!
  # defaultSelectedSprintId: ID # REMOVED: Managed on client
}





# Input type for creating a task
input CreateProjectTaskInput {
  projectId: ID!
  sectionId: ID!
  title: String!
  description: String
  status: TaskStatus # Using consolidated TaskStatus
  priority: Priority # Using consolidated Priority
  dueDate: String
  startDate: String
  endDate: String
  assigneeId: ID
  sprintId: ID
  points: Int
  parentId: ID # For subtasks, if you implement this in ListView
}

# Input type for updating a task
input UpdateProjectTaskInput {
  id: ID!
  title: String # Changed from String! to String (optional, not nullable)
  description: String
  status: TaskStatus # Using consolidated TaskStatus
  priority: Priority # Using consolidated Priority
  dueDate: String # Changed to String (optional)
  startDate: String
  endDate: String
  assigneeId: ID # Changed to ID (optional)
  sprintId: ID # Changed to ID (optional)
  points: Int # Changed to Int (optional)
  parentId: ID
  isCompleted: Boolean # NEW: For updating sprint completion status
  sectionId: ID # <--- ADD THIS FOR MOVING TASKS BETWEEN SECTIONS
}

# Input type for creating a sprint
input CreateSprintInput {
  projectId: ID!
  name: String!
  description: String
  startDate: String! # ISO Date string
  endDate: String!   # ISO Date string
  status: SprintStatus # NEW: Allow setting initial status
}

# Input type for updating a sprint (Consolidated to one definition)
input UpdateSprintInput {
  id: ID!
  name: String
  description: String
  startDate: String # ISO Date string
  endDate: String   # ISO Date string
  isCompleted: Boolean
  status: SprintStatus
}


type ProjectMemberFullDetails { # NEW: For project members list
  id: ID! # This is the ProjectMember ID
  role: ProjectRole!
  user: UserFullDetails!
}



# --- NEW TYPES FOR LOOKUP QUERIES ---

type UserLookupPartial { # For member lookups, minimal user info
  id: ID!
  firstName: String
  lastName: String
  email: String
  avatar: String
}

type ProjectMemberLookupItem {
  id: ID! # This is the ProjectMember ID
  role: ProjectRole!
  user: UserLookupPartial!
}

type SprintLookupItem {
  id: ID!
  name: String!
  status: SprintStatus!
  startDate: String!
  endDate: String!
}

type TaskLookupItem {
  id: ID!
  title: String!
  status: TaskStatus!
  priority: Priority!
  dueDate: String
  assignee: UserAvatarPartial # Simplified assignee for lookup
  sprint: SprintNameId # Simplified sprint for lookup
}

# Minimal Document type for list view (consolidated to one definition)
# Renaming DocumentLookupItem to DocumentListItem as per your existing usage
type DocumentListItem { 
  id: ID!
  title: String!
  updatedAt: String! # For sorting/display
  type: String! # "doc" or "pdf" (derived, if content is null assume PDF, else doc)
  projectId: ID # To filter by project
}

type WorkspaceLookupData {
  id: ID!
  name: String!
  owner: UserAvatarPartial! # Simplified owner for lookup
  members: [WorkspaceMemberLookupItem!]!
}

type WorkspaceMemberLookupItem {
  id: ID! # WorkspaceMember ID
  role: WorkspaceRole!
  user: UserLookupPartial!
}


# --- NEW TYPES FOR GANTT VIEW QUERY (from your provided schema, ensure they are complete)
type GanttTaskData {
  id: ID!
  name: String!
  start: String! # ISO Date string (startDate)
  end: String!   # ISO Date string (endDate or dueDate)
  progress: Int!
  type: String!  # "task", "milestone", "project" (for sprint groups)
  sprint: ID     # The ID of the parent sprint (if type is task/milestone)
  hideChildren: Boolean
  displayOrder: Int
  description: String
  assignee: UserAvatarPartial
  # Add other relevant fields if you have them in Task/Milestone
  # For task updates, we need the original task ID, type, and sprint ID for context
  originalTaskId: ID # To link back to Task.id or Milestone.id
  originalType: String # "TASK" or "MILIESTONE"
}

type GanttDataResponse {
  sprints: [SprintNameId!]! # List of sprints for filter dropdown
  tasks: [GanttTaskData!]! # Flattened list of tasks/milestones for Gantt chart
}

type SprintDetails { # Update SprintDetails type (used in getProjectDetails)
  id: ID!
  name: String!
  description: String
  startDate: String!
  endDate: String!   # ISO Date string
  isCompleted: Boolean!
  status: SprintStatus!
  tasks: [TaskListView!]! # Tasks directly under this sprint
  milestones: [Milestone!]!
}

# Input for creating a new task from Gantt (simplified)
input CreateGanttTaskInput {
  projectId: ID!
  sprintId: ID! # Tasks always belong to a sprint in Gantt context
  name: String!
  description: String
  startDate: String!
  endDate: String! # Use endDate here for Gantt's `end`
  assigneeId: ID
  progress: Int # For initial progress
  type: String! # "task" or "milestone"
}

# Input for updating a Gantt task/milestone
input UpdateGanttTaskInput {
  id: ID! # ID of the original Task or Milestone
  type: String! # "TASK" or "MILIESTONE" - tells resolver which model to update
  name: String
  description: String
  startDate: String
  endDate: String # For task (maps to Task.endDate) or milestone (maps to Milestone.dueDate)
  assigneeId: ID # For task only
  progress: Int # For task only
}


# --- NEW TYPES FOR DOCUMENTS ---

# The original DocumentListItem type is now used for lookups too.
# type DocumentListItem {
#   id: ID!
#   title: String!
#   updatedAt: String! # For sorting/display
#   type: String! # "doc" or "pdf" (derived, if content is null assume PDF, else doc)
#   projectId: ID # To filter by project
# }

input CreateDocumentInput {
  projectId: ID!
  title: String!
  content: JSON # Expects Block[] as JSON
  dataUrl: String # Optional for PDF
}


input UpdateDocumentInput {
  id: ID!
  title: String
  content: JSON # Optional, expects Block[] as JSON
  dataUrl: String # Optional for PDF
}

# ----------------------------------
# NEW: PROMPT LAB INPUTS
# ----------------------------------

input CreatePromptVariableInput {
  id: ID # Client-generated ID is fine for embedded JSON
  name: String!
  placeholder: String!
  description: String
  type: PromptVariableType!
  defaultValue: String
  source: JSON
}

input UpdatePromptVariableInput {
  id: ID!
  name: String
  placeholder: String
  description: String
  type: PromptVariableType
  defaultValue: String
  source: JSON
}

# NEW Input types for Content Blocks
input CreateContentBlockInput {
  id: ID # Client-generated ID for internal tracking
  type: String! # 'text' or 'variable'
  value: String # Required for 'text' blocks
  varId: ID # Required for 'variable' blocks, references PromptVariable.id
  placeholder: String # Required for 'variable' blocks
  name: String # Required for 'variable' blocks
}

input UpdateContentBlockInput {
  id: ID! # ID of the block to update
  type: String # 'text' or 'variable'
  value: String # For type 'text'
  varId: ID # For type 'variable', references PromptVariable.id
  placeholder: String # For type 'variable', the placeholder string like {{var}}
  name: String # For type 'variable', the display name of the variable
}

input CreatePromptInput {
  projectId: ID
  # userId: ID # Will be derived from context
  title: String!
  content: [CreateContentBlockInput!] # CHANGED: From String to [CreateContentBlockInput!]
  context: String
  description: String
  category: String
  tags: [String!]
  isPublic: Boolean
  model: String
  variables: [CreatePromptVariableInput!]
  versions: [CreateVersionInput!]
}

input UpdatePromptInput {
  id: ID!
  title: String
  content: [UpdateContentBlockInput!] # CHANGED: From String to [UpdateContentBlockInput!]
  context: String
  description: String
  category: String
  tags: [String!]
  isPublic: Boolean
  model: String
  variables: [UpdatePromptVariableInput!] # For updating the *entire* variables array
}

input CreateVersionInput { # For initial versions on prompt creation
  id: ID
  content: [CreateContentBlockInput!]! # CHANGED: From String to [CreateContentBlockInput!]!
  context: String!
  variables: [CreatePromptVariableInput!]!
  createdAt: String # Will be Date.toISOString()
  notes: String
  description: String # ADDED: Description for the version
}

input SnapshotPromptInput {
  promptId: ID!
  notes: String
}

input RestorePromptVersionInput {
  promptId: ID!
  versionId: ID!
}

# NEW: Input for updating a version's description
input UpdateVersionDescriptionInput {
  promptId: ID!
  versionId: ID!
  description: String!
}

# ----------------------------------
# Root Queries
# ----------------------------------
type Query {

  getGanttData(projectId: ID!, sprintId: ID): GanttDataResponse # NEW Query


  getProjectTasksAndSections(projectId: ID!, sprintId: ID): ProjectTasksAndSectionsData

  getProjectDetails(projectId: ID!): ProjectDetails

  getWorkspaceData: WorkspaceData # New query
  me: User

  # --- NEW DOCUMENT QUERIES ---
  getProjectDocuments(projectId: ID!): [DocumentListItem!]! # Get list of documents for a project
  getDocumentDetails(id: ID!): Document # Get full details of a single document

  # --- NEW WIREFRAME QUERIES ---
  getProjectWireframes(projectId: ID!): [WireframeListItem!]! # Get list of wireframes for a project
  getWireframeDetails(id: ID!): Wireframe # Get full details of a single wireframe

  # --- NEW PROMPT QUERIES ---
  getProjectPrompts(projectId: ID): [Prompt!]! # Added `projectId` as optional for personal prompts
  getPromptDetails(id: ID!): Prompt
  # UPDATED: Added workspaceId to resolvePromptVariable query
  resolvePromptVariable(projectId: ID, workspaceId: ID, variableSource: JSON!, promptVariableId: ID): String

  # NEW LOOKUP QUERIES
  getProjectSprintsLookup(projectId: ID!): [SprintLookupItem!]!
  getProjectMembersLookup(projectId: ID!): [ProjectMemberLookupItem!]!
  getProjectTasksLookup(projectId: ID!, sprintId: ID): [TaskLookupItem!]!
  getProjectDocumentsLookup(projectId: ID!): [DocumentListItem!]! # Corrected to use DocumentListItem
  getWorkspaceDataLookup(workspaceId: ID!): WorkspaceLookupData
}



# ----------------------------------
# Root Mutations (CRUD-style)
# ----------------------------------
type Mutation {
  createProjectTask(input: CreateProjectTaskInput!): TaskListView! # New mutation
  updateProjectTask(input: UpdateProjectTaskInput!): TaskListView! # New mutation

  deleteProjectSection(id: ID!, options: DeleteSectionOptions): Section! # Updated mutation

  createProjectSection(projectId: ID!, name: String!, order: Int): Section! # New mutation
  updateProjectSection(id: ID!, name: String, order: Int): Section! # New mutation

  createUser(email: String!, password: String, firstName: String, lastName: String, role: UserRole): User! # Added password to creation

  setupWorkspace(
    userId: ID!
    workspaceName: String!
    workspaceDescription: String
    projectName: String!
    projectDescription: String
    industry: String
    teamSize: String
    workFields: [String!]
  ): Workspace! # Returns the created Workspace

  createProject(
    workspaceId: ID!
    name: String!
    description: String
  ): Project! # Returns the created Project

  deleteProjectTask(id: ID!): TaskListView! # NEW: Mutation to delete a task

  # Sprint Mutations
  createSprint(input: CreateSprintInput!): SprintDetails! # Returns the created sprint
  updateSprint(input: UpdateSprintInput!): SprintDetails! # Returns the updated sprint
  deleteSprint(id: ID!): SprintDetails! # Returns the deleted sprint




  createGanttTask(input: CreateGanttTaskInput!): GanttTaskData! # NEW: Create a task/milestone for Gantt
  updateGanttTask(input: UpdateGanttTaskInput!): GanttTaskData! # NEW: Update a task/milestone for Gantt

  # --- NEW DOCUMENT MUTATIONS ---
  createDocument(input: CreateDocumentInput!): DocumentListItem! # Returns the created document item
  updateDocument(input: UpdateDocumentInput!): DocumentListItem! # Returns the updated document item
  deleteDocument(id: ID!): DocumentListItem! # Returns the deleted document item

  # --- NEW WIREFRAME MUTATIONS ---
  createWireframe(input: CreateWireframeInput!): WireframeListItem! # Returns the created wireframe item
  updateWireframe(input: UpdateWireframeInput!): WireframeListItem! # Returns the updated wireframe item
  deleteWireframe(id: ID!): WireframeListItem! # Returns the deleted wireframe item

  # --- NEW PROMPT MUTATIONS ---
  createPrompt(input: CreatePromptInput!): Prompt!
  updatePrompt(input: UpdatePromptInput!): Prompt!
  deletePrompt(id: ID!): Prompt!
  snapshotPrompt(input: SnapshotPromptInput!): Prompt!
  restorePromptVersion(input: RestorePromptVersionInput!): Prompt!
  updateVersionDescription(input: UpdateVersionDescriptionInput!): Prompt! # NEW: Update a version's description
}





# ----------------------------------
# Scalars
# ----------------------------------
scalar JSON
```

**4. `hooks/usePromptDetails.ts`**

```typescript
// hooks/usePromptDetails.ts
'use client';

import { useState, useEffect, useCallback, useRef } from "react";
import { useQuery, useMutation } from "@apollo/client";

import { GET_PROMPT_DETAILS_QUERY } from "@/graphql/queries/promptRelatedQueries";
import {
  UPDATE_PROMPT_MUTATION,
  SNAPSHOT_PROMPT_MUTATION,
  RESTORE_PROMPT_VERSION_MUTATION,
  UPDATE_VERSION_DESCRIPTION_MUTATION, // NEW: Import new mutation
} from "@/graphql/mutations/promptRelatedMutations";
import { Prompt, PromptVariable, Block, Version as PromptVersionType } from '@/components/prompt-lab/store'; // Renamed Version to PromptVersionType to avoid conflict

// Minimal cuid for client-side use if needed for new local vars/versions
function cuid(prefix: string = ''): string {
  const chars = '01234789abcdefghijklmnopqrstuvwxyz';
  let result = prefix + 'c';
  for (let i = 0; i < 24; i++) {
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
}

interface UsePromptDetailsHook {
  selectedPromptDetails: Prompt | null;
  loadingDetails: boolean;
  detailsError: string | null;
  // Modified: updatePromptDetails now accepts promptId as its first argument
  updatePromptDetails: (
    promptId: string, // <-- Added promptId parameter
    updates: Partial<Omit<Prompt, 'id' | 'createdAt' | 'updatedAt' | 'user' | 'project' | 'versions'>>
  ) => void;
  // Snapshot and restore continue to use the hook's selectedPromptId internally
  snapshotPrompt: (notes?: string) => void;
  restorePromptVersion: (versionId: string) => void;
  updateVersionDescription: (promptId: string, versionId: string, description: string) => void; // NEW: Add to hook interface
  refetchPromptDetails: () => Promise<any>;
}

export function usePromptDetails(selectedPromptId: string | null, projectId: string | undefined): UsePromptDetailsHook {
  const [selectedPromptDetails, setSelectedPromptDetails] = useState<Prompt | null>(null);
  const [localDetailsError, setLocalDetailsError] = useState<string | null>(null);
  const lastFetchedPromptData = useRef<Prompt | null>(null); // To help maintain details locally

  const { data: promptDetailsData, loading: apolloDetailsLoading, error: apolloDetailsError, refetch: apolloRefetchPromptDetails } = useQuery(
    GET_PROMPT_DETAILS_QUERY,
    {
      variables: { id: selectedPromptId },
      skip: !selectedPromptId,
      fetchPolicy: "network-only",
      onCompleted: (data) => {
        if (data?.getPromptDetails) {
          console.log('[usePromptDetails] [Trace: QueryDetailsComplete] GET_PROMPT_DETAILS_QUERY onCompleted. Details for ID:', data.getPromptDetails.id);
          setLocalDetailsError(null);
          const detailedPrompt: Prompt = {
            id: data.getPromptDetails.id,
            title: data.getPromptDetails.title,
            content: (data.getPromptDetails.content && Array.isArray(data.getPromptDetails.content) ? data.getPromptDetails.content : []) as Block[],
            context: data.getPromptDetails.context,
            description: data.getPromptDetails.description,
            category: data.getPromptDetails.category,
            tags: data.getPromptDetails.tags,
            isPublic: data.getPromptDetails.isPublic,
            createdAt: data.getPromptDetails.createdAt,
            updatedAt: data.getPromptDetails.updatedAt,
            model: data.getPromptDetails.model,
            projectId: data.getPromptDetails.projectId,
            variables: data.getPromptDetails.variables.map((v: PromptVariable) => ({ ...v, id: v.id || cuid('db-var-') })),
            versions: data.getPromptDetails.versions.map((v: any) => ({
               ...v,
               id: v.id || cuid('db-ver-'),
               content: (v.content && Array.isArray(v.content) ? v.content : []) as Block[],
               description: v.description || '', // ADDED: Map description
            })),
          };
          lastFetchedPromptData.current = detailedPrompt;
          setSelectedPromptDetails(detailedPrompt);
        } else {
            setSelectedPromptDetails(null); // Clear details if no data found
            lastFetchedPromptData.current = null;
        }
      },
      onError: (err) => {
        console.error("[usePromptDetails] [Error: QueryDetails] Error fetching prompt details:", err);
        setLocalDetailsError("Failed to load prompt details.");
        setSelectedPromptDetails(null); // Clear details on error
        lastFetchedPromptData.current = null;
      },
    }
  );

  // Clear selectedPromptDetails if selectedPromptId becomes null
  useEffect(() => {
    if (!selectedPromptId) {
      setSelectedPromptDetails(null);
      lastFetchedPromptData.current = null;
      setLocalDetailsError(null);
    }
  }, [selectedPromptId]);

  const [updatePromptMutation] = useMutation(UPDATE_PROMPT_MUTATION, {
    onCompleted: (data) => {
      if (data?.updatePrompt) {
        console.log('[usePromptDetails] [Trace: MutationUpdateComplete] UPDATE_PROMPT_MUTATION onCompleted. Updated prompt ID:', data.updatePrompt.id, 'Title:', data.updatePrompt.title);
        // Only update basic fields from mutation result, rely on re-fetch for full details if needed
        setSelectedPromptDetails(prev => prev ? {
            ...prev,
            title: data.updatePrompt.title,
            description: data.updatePrompt.description,
            tags: data.updatePrompt.tags,
            isPublic: data.updatePrompt.isPublic,
            model: data.updatePrompt.model,
            updatedAt: data.updatePrompt.updatedAt,
        } : null);
      }
    },
    onError: (err) => {
      console.error("[usePromptDetails] [Error: MutationUpdate] Mutation Error: Update Prompt", err);
      setLocalDetailsError("Failed to update prompt.");
      apolloRefetchPromptDetails(); // Refetch details on error to resync
    },
  });

  const [snapshotPromptMutation] = useMutation(SNAPSHOT_PROMPT_MUTATION, {
    onCompleted: (data) => {
      if (data?.snapshotPrompt) {
        console.log('[usePromptDetails] [Trace: MutationSnapshotComplete] SNAPSHOT_PROMPT_MUTATION onCompleted. Prompt ID:', data.snapshotPrompt.id);
        apolloRefetchPromptDetails(); // Refetch details to get the new version in the list
      }
    },
    onError: (err) => {
      console.error("[usePromptDetails] [Error: MutationSnapshot] Mutation Error: Snapshot Prompt", err);
      setLocalDetailsError("Failed to save version.");
      apolloRefetchPromptDetails(); // Refetch on error
    },
  });

  const [restorePromptVersionMutation] = useMutation(RESTORE_PROMPT_VERSION_MUTATION, {
    onCompleted: (data) => {
      if (data?.restorePromptVersion) {
        console.log('[usePromptDetails] [Trace: MutationRestoreComplete] RESTORE_PROMPT_VERSION_MUTATION onCompleted. Prompt ID:', data.restorePromptVersion.id);
        apolloRefetchPromptDetails(); // Refetch details to show the restored content
      }
    },
    onError: (err) => {
      console.error("[usePromptDetails] [Error: MutationRestore] Mutation Error: Restore Prompt Version", err);
      setLocalDetailsError("Failed to restore version.");
      apolloRefetchPromptDetails(); // Refetch on error
    },
  });

  // NEW: Mutation for updating version description
  const [updateVersionDescriptionMutation] = useMutation(UPDATE_VERSION_DESCRIPTION_MUTATION, {
    onCompleted: (data) => {
      if (data?.updateVersionDescription) {
        console.log('[usePromptDetails] [Trace: MutationUpdateVersionDescriptionComplete] UPDATE_VERSION_DESCRIPTION_MUTATION onCompleted. Prompt ID:', data.updateVersionDescription.id);
        // Optimistically update the selected prompt details (only versions array)
        setSelectedPromptDetails(prev => {
          if (!prev) return null;
          return {
            ...prev,
            versions: data.updateVersionDescription.versions.map((v: any) => ({
              ...v,
              content: (v.content && Array.isArray(v.content) ? v.content : []) as Block[], // Ensure content is Block[] if the mutation result includes it (though we only asked for id, notes, description)
              description: v.description || '',
            })),
            updatedAt: new Date().toISOString(), // Mark prompt as updated
          };
        });
      }
    },
    onError: (err) => {
      console.error("[usePromptDetails] [Error: MutationUpdateVersionDescription] Mutation Error: Update Version Description", err);
      setLocalDetailsError("Failed to update version description.");
      apolloRefetchPromptDetails(); // Refetch on error to resync
    },
  });


  const updatePromptDetails = useCallback(
    (
      promptId: string, // <-- Now explicitly accepts the promptId to update
      updates: Partial<Omit<Prompt, 'id' | 'createdAt' | 'updatedAt' | 'user' | 'project' | 'versions'>>
    ) => {
      // Ensure the provided promptId is valid
      if (!promptId) {
        console.warn('[usePromptDetails] [Trace: Update] updatePromptDetails called with an invalid promptId.');
        setLocalDetailsError('Cannot update prompt: invalid prompt ID provided.');
        return;
      }
      setLocalDetailsError(null);
      console.log('[usePromptDetails] [Trace: Update] updatePromptDetails: Optimistically updating prompt ID:', promptId, 'with keys:', Object.keys(updates));

      // Optimistic UI update: ONLY update if the 'promptId' being updated
      // matches the 'selectedPromptId' of this particular hook instance.
      // If the hook is managing details for ID 'X' and an update comes for ID 'Y',
      // we don't want to optimistically apply 'Y's changes to 'X's display.
      if (promptId === selectedPromptId) {
        setSelectedPromptDetails((prev) => {
          if (!prev) return null;
          return {
            ...prev,
            ...updates,
            updatedAt: new Date().toISOString(), // Optimistic update timestamp
            content: updates.content !== undefined ? (updates.content as Block[]) : prev.content,
            variables: updates.variables !== undefined ? (updates.variables.map((v: Partial<PromptVariable>) => ({...v, id: v.id || cuid('patch-var-')})) as PromptVariable[]) : prev.variables,
          };
        });
      }


      const filteredUpdates: Record<string, any> = {};
      for (const key in updates) {
        if (updates[key] !== undefined) {
          filteredUpdates[key] = updates[key];
        }
      }

      updatePromptMutation({
        variables: {
          input: {
            id: promptId, // Use the provided promptId here
            ...filteredUpdates,
          },
        },
      }).catch((err) => {
        console.error("[usePromptDetails] [Error: UpdateGraphQL] Error updating prompt details via GraphQL:", err);
        setLocalDetailsError("Failed to update prompt details.");
        // If an update fails for the *currently selected* prompt, refetch its details to revert optimistic UI.
        // Otherwise, if it's an update for a different prompt (shouldn't happen often for this hook),
        // we might not need to refetch the *current* selected details.
        if (promptId === selectedPromptId) {
          apolloRefetchPromptDetails(); // Revert optimistic update by refetching actual state
        }
      });
    },
    [selectedPromptId, updatePromptMutation, apolloRefetchPromptDetails]
  );

  const snapshotPrompt = useCallback(
    (notes?: string) => {
      // This function still uses the hook's selectedPromptId
      if (!selectedPromptId) {
        console.warn('[usePromptDetails] [Trace: Snapshot] snapshotPrompt called with no selectedPromptId.');
        setLocalDetailsError('Cannot snapshot prompt: no prompt selected.');
        return;
      }
      setLocalDetailsError(null);
      console.log('[usePromptDetails] [Trace: Snapshot] snapshotPrompt: Initiating snapshot for prompt ID:', selectedPromptId);
      snapshotPromptMutation({
        variables: {
          input: { promptId: selectedPromptId, notes: notes || `Version saved at ${new Date().toLocaleString()}` },
        },
      }).catch((err) => {
        console.error("[usePromptDetails] [Error: SnapshotGraphQL] Error creating prompt snapshot via GraphQL:", err);
        setLocalDetailsError("Failed to save version.");
        apolloRefetchPromptDetails();
      });
    },
    [selectedPromptId, snapshotPromptMutation, apolloRefetchPromptDetails]
  );

  const restorePromptVersion = useCallback(
    (versionId: string) => {
      // This function still uses the hook's selectedPromptId
      if (!selectedPromptId) {
        console.warn('[usePromptDetails] [Trace: Restore] restorePromptVersion called with no selectedPromptId.');
        setLocalDetailsError('Cannot restore version: no prompt selected.');
        return;
      }
      setLocalDetailsError(null);
      console.log('[usePromptDetails] [Trace: Restore] restorePromptVersion: Initiating restore for prompt ID:', selectedPromptId, 'version ID:', versionId);
      restorePromptVersionMutation({
        variables: {
          input: { promptId: selectedPromptId, versionId },
        },
      }).catch((err) => {
        console.error("[usePromptDetails] [Error: RestoreGraphQL] Error restoring prompt version via GraphQL:", err);
        setLocalDetailsError("Failed to restore version.");
        apolloRefetchPromptDetails();
      });
    },
    [selectedPromptId, restorePromptVersionMutation, apolloRefetchPromptDetails]
  );

  // NEW: Callback for updating version description
  const updateVersionDescription = useCallback(
    (promptId: string, versionId: string, description: string) => {
      if (!promptId || !versionId) {
        console.warn('[usePromptDetails] [Trace: UpdateVersionDesc] updateVersionDescription called with invalid IDs.');
        setLocalDetailsError('Cannot update version description: invalid prompt or version ID.');
        return;
      }
      setLocalDetailsError(null);
      console.log('[usePromptDetails] [Trace: UpdateVersionDesc] Updating description for prompt ID:', promptId, 'version ID:', versionId);

      // Optimistic UI update
      if (promptId === selectedPromptId) {
        setSelectedPromptDetails(prev => {
          if (!prev) return null;
          const updatedVersions = prev.versions.map(v => 
            v.id === versionId ? { ...v, description: description } : v
          ) as PromptVersionType[]; // Cast back to PromptVersionType[]
          return { ...prev, versions: updatedVersions, updatedAt: new Date().toISOString() };
        });
      }

      updateVersionDescriptionMutation({
        variables: {
          input: { promptId, versionId, description },
        },
      }).catch((err) => {
        console.error("[usePromptDetails] [Error: UpdateVersionDescGraphQL] Error updating version description via GraphQL:", err);
        setLocalDetailsError("Failed to update version description.");
        if (promptId === selectedPromptId) {
          apolloRefetchPromptDetails(); // Revert optimistic update
        }
      });
    },
    [selectedPromptId, updateVersionDescriptionMutation, apolloRefetchPromptDetails]
  );

  return {
    selectedPromptDetails,
    loadingDetails: apolloDetailsLoading,
    detailsError: localDetailsError || apolloDetailsError?.message || null,
    updatePromptDetails,
    snapshotPrompt,
    restorePromptVersion,
    updateVersionDescription, // NEW: Expose new function
    refetchPromptDetails: apolloRefetchPromptDetails,
  };
}
```
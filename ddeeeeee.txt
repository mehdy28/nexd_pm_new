
### 4. `hooks/use-prompt-api.ts` (New React Query / SWR / Apollo Client hooks)

This file will contain custom React hooks to simplify data fetching and mutations in your components. I'll use a generic `useGraphQLClient` and `useQuery`/`useMutation` pattern. Adapt this to your actual GraphQL client (e.g., Apollo Client, React Query with `graphql-request`).

```typescript
// hooks/use-prompt-api.ts
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'; // Using TanStack Query as an example
import { useGraphQLClient } from './use-graphql-client'; // Assume you have this hook
import {
  GET_PROJECT_PROMPTS_QUERY,
  GET_PROMPT_DETAILS_QUERY,
  RESOLVE_PROMPT_VARIABLE_QUERY,
} from '@/lib/graphql/queries';
import {
  CREATE_PROMPT_MUTATION,
  UPDATE_PROMPT_MUTATION,
  DELETE_PROMPT_MUTATION,
  SNAPSHOT_PROMPT_MUTATION,
  RESTORE_PROMPT_VERSION_MUTATION,
} from '@/lib/graphql/mutations';
import { Prompt, PromptVariable, Version } from '@/components/prompt-lab/store'; // Import types from your store

// Helper to generate a client-side CUID for embedded JSON objects (variables, versions)
function cuid(): string {
  const chars = '0123456789abcdefghijklmnopqrstuvwxyz';
  let result = 'c'; // CUIDs start with 'c'
  for (let i = 0; i < 24; i++) { // Generate 24 random alphanumeric characters
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
}

// --- Queries ---

export const useProjectPrompts = (projectId?: string) => {
  const { client } = useGraphQLClient();
  return useQuery<Prompt[]>(
    ['projectPrompts', projectId],
    async () => {
      const { getProjectPrompts } = await client.request<{ getProjectPrompts: Prompt[] }>(
        GET_PROJECT_PROMPTS_QUERY,
        { projectId }
      );
      return getProjectPrompts;
    },
    {
      enabled: !!client,
      initialData: [], // Provide an empty array as initial data
    }
  );
};

export const usePromptDetails = (promptId: string) => {
  const { client } = useGraphQLClient();
  return useQuery<Prompt>(
    ['promptDetails', promptId],
    async () => {
      const { getPromptDetails } = await client.request<{ getPromptDetails: Prompt }>(
        GET_PROMPT_DETAILS_QUERY,
        { id: promptId }
      );
      // Ensure variables and versions have IDs if they didn't from the backend (client-side CUIDs for embedded data)
      return {
        ...getPromptDetails,
        variables: getPromptDetails.variables.map(v => ({ ...v, id: v.id || cuid() })),
        versions: getPromptDetails.versions.map(v => ({ ...v, id: v.id || cuid() })),
      };
    },
    {
      enabled: !!client && !!promptId,
    }
  );
};

// Hook for resolving dynamic variable values (used in VariableDiscoveryBuilder)
export const useResolvePromptVariable = (projectId: string | undefined, variableSource: any | null, promptVariableId?: string) => {
  const { client } = useGraphQLClient();
  return useQuery<string>(
    ['resolvePromptVariable', projectId, variableSource, promptVariableId],
    async () => {
      if (!variableSource || !projectId) return 'N/A'; // Or handle differently
      const { resolvePromptVariable } = await client.request<{ resolvePromptVariable: string }>(
        RESOLVE_PROMPT_VARIABLE_QUERY,
        { projectId, variableSource, promptVariableId }
      );
      return resolvePromptVariable;
    },
    {
      enabled: !!client && !!projectId && !!variableSource,
      initialData: 'N/A',
      staleTime: 5 * 60 * 1000, // Cache for 5 minutes
      cacheTime: 10 * 60 * 1000, // Keep in cache for 10 minutes
    }
  );
};

// --- Mutations ---

export const useCreatePrompt = (projectId?: string) => {
  const { client } = useGraphQLClient();
  const queryClient = useQueryClient();
  return useMutation<Prompt, Error, { input: Omit<Prompt, 'id' | 'createdAt' | 'updatedAt' | 'user' | 'project' | 'versions'> }, unknown>(
    async (newPromptInput) => {
      // Add initial `model` and `context` if not provided
      const inputWithDefaults = {
        ...newPromptInput.input,
        model: newPromptInput.input.model || 'gpt-4o', // Default model
        context: newPromptInput.input.context || '', // Default empty context
        tags: newPromptInput.input.tags || [],
        variables: newPromptInput.input.variables || [],
        // projectId is already in newPromptInput if passed
      };
      const { createPrompt } = await client.request<{ createPrompt: Prompt }>(
        CREATE_PROMPT_MUTATION,
        { input: inputWithDefaults }
      );
      return createPrompt;
    },
    {
      onSuccess: (newPrompt) => {
        // Invalidate and refetch the project prompts list
        queryClient.invalidateQueries(['projectPrompts', projectId]);
        // Also add to the cache for prompt details so it's immediately available
        queryClient.setQueryData(['promptDetails', newPrompt.id], newPrompt);
      },
    }
  );
};

export const useUpdatePrompt = () => {
  const { client } = useGraphQLClient();
  const queryClient = useQueryClient();
  return useMutation<Prompt, Error, { input: Partial<Prompt> & { id: string } }, unknown>(
    async (updatedPromptInput) => {
      const { updatePrompt } = await client.request<{ updatePrompt: Prompt }>(
        UPDATE_PROMPT_MUTATION,
        { input: updatedPromptInput.input }
      );
      return updatePrompt;
    },
    {
      onSuccess: (updatedPrompt) => {
        queryClient.invalidateQueries(['projectPrompts', updatedPrompt.projectId]); // Update list if basic details changed
        queryClient.setQueryData(['promptDetails', updatedPrompt.id], (oldData: Prompt | undefined) => {
          if (!oldData) return updatedPrompt; // If no old data, just set
          // Merge old versions and other fields not managed by `UpdatePromptInput`
          return {
            ...oldData,
            ...updatedPrompt,
            // Variables are explicitly returned in updatePrompt, so replace them
            variables: updatedPrompt.variables,
            // Context and Content are also explicitly returned/updated
            content: updatedPrompt.content,
            context: updatedPrompt.context,
          };
        });
      },
    }
  );
};

export const useDeletePrompt = (projectId?: string) => {
  const { client } = useGraphQLClient();
  const queryClient = useQueryClient();
  return useMutation<Prompt, Error, { id: string }, unknown>(
    async ({ id }) => {
      const { deletePrompt } = await client.request<{ deletePrompt: Prompt }>(
        DELETE_PROMPT_MUTATION,
        { id }
      );
      return deletePrompt;
    },
    {
      onSuccess: (deletedPrompt) => {
        queryClient.invalidateQueries(['projectPrompts', projectId]);
        queryClient.removeQueries(['promptDetails', deletedPrompt.id]);
      },
    }
  );
};

export const useSnapshotPrompt = () => {
  const { client } = useGraphQLClient();
  const queryClient = useQueryClient();
  return useMutation<Prompt, Error, { input: { promptId: string; notes?: string } }, unknown>(
    async (snapshotInput) => {
      const { snapshotPrompt } = await client.request<{ snapshotPrompt: Prompt }>(
        SNAPSHOT_PROMPT_MUTATION,
        { input: snapshotInput.input }
      );
      return snapshotPrompt;
    },
    {
      onSuccess: (snapshotResult) => {
        // Update the promptDetails cache with the new versions array
        queryClient.setQueryData(['promptDetails', snapshotResult.id], (oldData: Prompt | undefined) => {
          if (!oldData) return snapshotResult;
          return { ...oldData, versions: snapshotResult.versions };
        });
      },
    }
  );
};

export const useRestorePromptVersion = () => {
  const { client } = useGraphQLClient();
  const queryClient = useQueryClient();
  return useMutation<Prompt, Error, { input: { promptId: string; versionId: string } }, unknown>(
    async (restoreInput) => {
      const { restorePromptVersion } = await client.request<{ restorePromptVersion: Prompt }>(
        RESTORE_PROMPT_VERSION_MUTATION,
        { input: restoreInput.input }
      );
      return restorePromptVersion;
    },
    {
      onSuccess: (restoredPrompt) => {
        // Update the promptDetails cache with the restored content and variables
        queryClient.setQueryData(['promptDetails', restoredPrompt.id], (oldData: Prompt | undefined) => {
          if (!oldData) return restoredPrompt;
          return {
            ...oldData,
            content: restoredPrompt.content,
            context: restoredPrompt.context,
            variables: restoredPrompt.variables,
          };
        });
      },
    }
  );
};


// Dummy GraphQL Client Hook (replace with your actual client)
// For example, if you use `graphql-request` directly or an Apollo Client instance
export function useGraphQLClient() {
  // This is a placeholder. In a real app, this would return an initialized GraphQL client.
  // For demonstration purposes, we'll just return a mock client or null.
  // Example with graphql-request:
  // import { GraphQLClient } from 'graphql-request';
  // const client = useMemo(() => new GraphQLClient('/api/graphql', { headers: { ...authHeaders } }), []);
  // return { client };

  // For this exercise, we'll just return a placeholder object that acts like a client
  const client = {
    request: async (query: any, variables: any) => {
      console.warn("Mock GraphQL Client: Performing request:", { query, variables });
      // Simulate network delay
      await new Promise(resolve => setTimeout(resolve, 500));
      // In a real app, this would be an actual network call.
      // For this setup, we're not actually calling the backend yet,
      // so this mock client is sufficient to prevent errors in useQuery/useMutation calls.
      // The actual data will come from `usePromptLab` store which mocks it.
      // We return empty objects for mutations as the store will handle state update.
      if (query.definitions[0].operation === 'mutation') {
        return {
          createPrompt: { id: cuid(), title: variables.input.title || 'New Prompt', content: variables.input.content || '', context: variables.input.context || '', model: variables.input.model || 'gpt-4o', variables: variables.input.variables || [], versions: [], createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(), projectId: variables.input.projectId || null },
          updatePrompt: { ...variables.input, updatedAt: new Date().toISOString() },
          deletePrompt: { id: variables.id },
          snapshotPrompt: { id: variables.input.promptId, versions: [] }, // Actual versions will be fetched on next query
          restorePromptVersion: { id: variables.input.promptId, content: "", context: "", variables: [] }, // Actual content will be fetched on next query
        }
      }
      return {}; // Empty object for queries by default
    }
  };
  return { client };
}
```
**Note**: The `useGraphQLClient` hook above is a **mock implementation**. You need to replace it with your actual GraphQL client integration (e.g., Apollo Client's `useApolloClient`, or a custom hook that returns a `graphql-request` instance configured with your backend endpoint and authentication headers). The current mock will allow the UI to run without backend connection but won't perform actual API calls.

---

### 5. `components/prompt-lab/store.ts` (Updated to integrate with API hooks)

This file will now coordinate fetching data from your API hooks and managing local UI state. The `create`, `update`, `remove`, `snapshot`, `restore` functions will delegate to the new API mutations.

```typescript
// components/prompt-lab/store.ts
'use client'

import { create } from 'zustand'
import { produce } from 'immer'
import { persist, createJSONStorage } from 'zustand/middleware'
import {
  useCreatePrompt,
  useUpdatePrompt,
  useDeletePrompt,
  useSnapshotPrompt,
  useRestorePromptVersion,
  useProjectPrompts,
  usePromptDetails
} from '@/hooks/use-prompt-api'; // Import your API hooks
import { toast } from 'sonner';

// Helper to generate a client-side CUID for embedded JSON objects (variables, versions)
function cuid(): string {
  const chars = '0123456789abcdefghijklmnopqrstuvwxyz';
  let result = 'c'; // CUIDs start with 'c'
  for (let i = 0; i < 24; i++) { // Generate 24 random alphanumeric characters
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
}

// --- TYPES (Mirroring GraphQL Schema) ---

export enum PromptVariableType {
  STRING = 'STRING',
  NUMBER = 'NUMBER',
  BOOLEAN = 'BOOLEAN',
  DATE = 'DATE',
  RICH_TEXT = 'RICH_TEXT',
  LIST_OF_STRINGS = 'LIST_OF_STRINGS',
}

export interface PromptVariableSource {
  type: string; // e.g., 'PROJECT_FIELD', 'TASKS_AGGREGATION', 'USER_FIELD', 'DATE_FUNCTION'
  field?: string; // e.g., 'name', 'title', 'today'
  entityId?: string; // e.g., 'current_sprint', 'latest', or a specific ID
  filter?: Record<string, any>; // e.g., { status: 'DONE', assigneeId: 'current_user' }
  aggregation?: string; // e.g., 'COUNT', 'LIST_TITLES', 'LIST_NAMES'
  format?: string; // e.g., 'BULLET_POINTS', 'COMMA_SEPARATED'
  // ... other dynamic properties based on the source type
}

export interface PromptVariable {
  id: string; // Client-side ID for local management
  name: string;
  placeholder: string; // e.g., '{{project_name}}'
  description?: string;
  type: PromptVariableType;
  defaultValue?: string;
  source?: PromptVariableSource; // JSON object for dynamic variables
}

export interface Version {
  id: string; // Client-side ID for local management
  content: string;
  context: string;
  variables: PromptVariable[];
  createdAt: string; // ISO date string
  notes?: string;
}

export interface Prompt {
  id: string;
  title: string;
  content: string;
  context: string;
  description?: string;
  category?: string;
  tags: string[];
  isPublic: boolean;
  createdAt: string;
  updatedAt: string;
  model: string; // e.g., 'gpt-4o', 'grok-3'
  projectId?: string;
  userId?: string; // Used for personal prompts
  variables: PromptVariable[];
  versions: Version[];
  // Relations from Prisma
  user?: {
    id: string;
    firstName?: string;
    lastName?: string;
  };
  project?: {
    id: string;
    name: string;
  };
}

// --- Store State & Actions ---
// NOTE: For a real application, you might choose to NOT store all prompts in a Zustand store.
// Instead, you'd use React Query (or similar) directly in components like PromptList and PromptLab
// and only store transient UI state in Zustand.
// For this exercise, we will keep the existing Zustand structure but delegate API calls.

interface PromptLabState {
  // We'll manage prompts indirectly via React Query
}

// Custom hook to integrate React Query with Zustand for simpler API interaction
export const usePromptLab = (projectId?: string) => {
  const queryClient = useQueryClient();

  // API Hooks
  const { data: prompts = [], isLoading: isLoadingPrompts, isError: isErrorPrompts } = useProjectPrompts(projectId);
  const createPromptMutation = useCreatePrompt(projectId);
  const updatePromptMutation = useUpdatePrompt();
  const deletePromptMutation = useDeletePrompt(projectId);
  const snapshotPromptMutation = useSnapshotPrompt();
  const restorePromptVersionMutation = useRestorePromptVersion();

  // For a specific prompt's details (used by PromptLab component)
  const { data: currentPromptDetails, isLoading: isLoadingPromptDetails } = usePromptDetails(queryClient.getQueryData(['promptDetails', ])?.id || ''); // This needs to be smarter, passed from PromptLabContainer or use a refetch.

  const actions = useMemo(() => ({
    prompts: prompts,
    isLoadingPrompts: isLoadingPrompts,
    isErrorPrompts: isErrorPrompts,

    // Action to create a new prompt
    create: (): Prompt => {
      const newPromptId = cuid();
      const newPrompt: Prompt = {
        id: newPromptId,
        title: 'Untitled Prompt',
        content: '',
        context: '',
        description: '',
        category: '',
        tags: [],
        isPublic: false,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        model: 'gpt-4o', // Default model
        projectId: projectId, // Associate with project if available
        variables: [],
        versions: [],
      };

      createPromptMutation.mutateAsync({ input: newPrompt })
        .then((createdPrompt) => {
          toast.success(`Prompt "${createdPrompt.title}" created!`);
          // The queryClient.invalidateQueries and setQueryData in useCreatePrompt will handle cache updates
        })
        .catch((error) => {
          console.error("Failed to create prompt:", error);
          toast.error("Failed to create prompt", { description: error.message || 'An unknown error occurred.' });
        });

      return newPrompt; // Return a temporary local object for immediate UI feedback
    },

    // Action to update an existing prompt
    update: (id: string, patch: Partial<Prompt>): void => {
      updatePromptMutation.mutateAsync({ input: { id, ...patch } })
        .then(() => {
          toast.success(`Prompt updated.`);
        })
        .catch((error) => {
          console.error(`Failed to update prompt ${id}:`, error);
          toast.error("Failed to update prompt", { description: error.message || 'An unknown error occurred.' });
        });
    },

    // Action to remove a prompt
    remove: (id: string): void => {
      deletePromptMutation.mutateAsync({ id })
        .then(() => {
          toast.success(`Prompt deleted.`);
        })
        .catch((error) => {
          console.error(`Failed to delete prompt ${id}:`, error);
          toast.error("Failed to delete prompt", { description: error.message || 'An unknown error occurred.' });
        });
    },

    // Action to create a snapshot/version
    snapshot: (id: string, notes?: string): void => {
      snapshotPromptMutation.mutateAsync({ input: { promptId: id, notes } })
        .then(() => {
          toast.success("Prompt version saved!");
        })
        .catch((error) => {
          console.error(`Failed to snapshot prompt ${id}:`, error);
          toast.error("Failed to save version", { description: error.message || 'An unknown error occurred.' });
        });
    },

    // Action to restore a version
    restore: (promptId: string, versionId: string): void => {
      restorePromptVersionMutation.mutateAsync({ input: { promptId, versionId } })
        .then(() => {
          toast.success("Prompt restored from version!");
        })
        .catch((error) => {
          console.error(`Failed to restore prompt ${promptId} from version ${versionId}:`, error);
          toast.error("Failed to restore version", { description: error.message || 'An unknown error occurred.' });
        });
    },

    // Fetch prompt details (for PromptLab component to use directly)
    fetchPromptDetails: (promptId: string) => {
        // This will trigger the usePromptDetails query if it's not already fetching
        // and its data will be accessible via its return value directly in PromptLab.
        // For the purpose of the `PromptLabContainer` to "select" a prompt,
        // we will manually set the query data to make it immediately available for `usePromptDetails`.
        const details = queryClient.getQueryData(['promptDetails', promptId]) as Prompt | undefined;
        if (!details) {
             queryClient.fetchQuery(['promptDetails', promptId]);
        }
        return details;
    }

  }), [
    prompts, isLoadingPrompts, isErrorPrompts,
    createPromptMutation, updatePromptMutation, deletePromptMutation,
    snapshotPromptMutation, restorePromptVersionMutation, projectId,
    queryClient
  ]);

  return actions;
};
```
**Important:**
*   The `usePromptLab` hook now primarily acts as an orchestrator, exposing the `prompts` list and delegating `create`, `update`, `remove`, `snapshot`, `restore` actions to the respective API mutation hooks.
*   The `prompts` array (and individual `Prompt` objects) are fetched directly via `useProjectPrompts` and `usePromptDetails` from React Query's cache, which gets populated by successful API calls.
*   The `create` action now returns a *temporary* local `Prompt` object so the UI can immediately render "new" state while the actual API call is in progress. The subsequent `onSuccess` handler for `createPromptMutation` will then update the React Query cache.
*   The `usePromptLab` will need to be provided with a `promptId` (or derive it) when `PromptLab` or `PromptLabContainer` needs `currentPromptDetails`. For now, `PromptLabContainer` will manage `selectedPromptId` and pass it to `PromptLab`, which will then use `usePromptDetails(selectedPromptId)`.

---

### 6. `components/prompt-lab/prompt-lab-container.tsx` (Updated)

This component will be updated to fetch prompt details using `usePromptDetails` from the API hooks.

```typescript
// components/prompt-lab/prompt-lab-container.tsx
'use client'

import { useEffect, useState } from "react"
import { PromptList } from "./prompt-list"
import { PromptLab } from "./prompt-lab"
import { usePromptLab } from './store' // Still use the store for the list of prompts and shared actions
import { Button } from "../ui/button"
import { usePromptDetails } from '@/hooks/use-prompt-api'; // NEW: Import usePromptDetails
import { Loader2 } from "lucide-react";


export function PromptLabContainer({ projectId }: { projectId?: string }) {
  const [selectedPromptId, setSelectedPromptId] = useState<string | null>(null)
  const { create } = usePromptLab(projectId); // Use usePromptLab for `create` action only
  
  // Use usePromptDetails hook to fetch and manage the selected prompt's data
  const { data: selectedPrompt, isLoading, isError } = usePromptDetails(selectedPromptId || '');

  useEffect(() => {
    // If a "new" prompt is selected, trigger creation and set the ID
    if (selectedPromptId === "new") {
      // The `create` action in usePromptLab now interacts with the API
      const newPromptTemp = create(); // Returns a temporary local prompt for immediate feedback
      setSelectedPromptId(newPromptTemp.id); // Set the selected ID to this temporary one
    }
  }, [selectedPromptId, create]);

  const handleSelectPrompt = (id: string) => {
    setSelectedPromptId(id)
  }

  const handleBack = () => {
    setSelectedPromptId(null)
  }

  // Handle loading state for prompt details
  if (selectedPromptId && isLoading) {
    return (
      <div className="grid h-full place-items-center p-6 text-sm text-slate-500">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
        <p className="mt-2">Loading prompt details...</p>
      </div>
    );
  }

  // Handle error state for prompt details
  if (selectedPromptId && isError) {
      return (
        <div className="grid h-full place-items-center p-6 text-sm text-red-500">
          Error loading prompt. Please try again.
          <Button onClick={handleBack} className="mt-4">Back to Prompt Library</Button>
        </div>
      );
  }

  if (selectedPromptId && selectedPrompt) {
    return <PromptLab prompt={selectedPrompt} onBack={handleBack} projectId={projectId} />
  } else if (selectedPromptId && !selectedPrompt) { // This case should be rare now with isLoading/isError checks
      return (
        <div className="grid h-full place-items-center p-6 text-sm text-slate-500">
          The selected prompt could not be found.
          <Button onClick={handleBack} className="mt-4">Back to Prompt Library</Button>
        </div>
      );
  }

  // Default view: Prompt List
  return <PromptList onSelectPrompt={handleSelectPrompt} projectId={projectId} />
}

```

---

### 7. `components/prompt-lab/prompt-lab.tsx` (Updated to receive `prompt` as prop and use mutation hooks)

This is the main prompt editor. It will now receive the `Prompt` object as a prop and use the `useUpdatePrompt`, `useSnapshotPrompt`, `useRestorePromptVersion` hooks directly for mutations. The `VariableDiscoveryBuilder` will use `useResolvePromptVariable`.

```typescript
// components/prompt-lab/prompt-lab.tsx
'use client'

import React, { useEffect, useMemo, useRef, useState, useCallback } from "react"
import { usePromptLab, PromptVariableType, type Prompt, type Version, type PromptVariable, type PromptVariableSource } from "./store" // Keep store for types
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { Button } from "@/components/ui/button"
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from "@/components/ui/dialog"
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs"
import { Copy, RotateCcw, Plus, GitCommit, Text, Trash2, GripVertical, Loader2 } from "lucide-react"
import { DndProvider, useDrag, useDrop, useDragLayer } from 'react-dnd'
import { HTML5Backend } from 'react-dnd-html5-backend'
import { Tab } from "@headlessui/react"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Badge } from "@/components/ui/badge"
import { VariableDiscoveryBuilder } from "./variable-discovery-builder"
import { useUpdatePrompt, useSnapshotPrompt, useRestorePromptVersion } from '@/hooks/use-prompt-api'; // NEW: Import mutation hooks
import { toast } from 'sonner';
import { useQueryClient } from '@tanstack/react-query';


// Utility for deep comparison of arrays of objects (used in EditorPanel's useEffect)
function deepCompareBlocks(arr1: Block[], arr2: Block[]): boolean {
  if (arr1.length !== arr2.length) return false;
  for (let i = 0; i < arr1.length; i++) {
    const b1 = arr1[i];
    const b2 = arr2[i];
    if (b1.type !== b2.type || b1.id !== b2.id) return false; // Basic comparison for identity
    if (b1.type === 'text' && b1.value !== b2.value) return false;
    if (b1.type === 'variable' && (b1.placeholder !== b2.placeholder || b1.name !== b2.name || b1.varId !== b2.varId)) return false; // Added varId for variable block comparison
  }
  return true;
}

const ItemTypes = { VARIABLE: 'variable', BLOCK: 'block' }

// Helper to merge multiple refs
function mergeRefs<T>(...refs: (React.Ref<T> | undefined)[]): React.RefCallback<T> {
  return (node: T) => {
    refs.forEach(ref => {
      if (!ref) return;
      if (typeof ref === 'function') ref(node);
      else if ('current' in ref) (ref as any).current = node;
    });
  };
}

// Helper to generate a client-side CUID for embedded JSON objects (variables, versions)
function cuid(): string {
  const chars = '0123456789abcdefghijklmnopqrstuvwxyz';
  let result = 'c'; // CUIDs start with 'c'
  for (let i = 0; i < 24; i++) { // Generate 24 random alphanumeric characters
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
}

/* Utility to render prompt by substituting placeholder text */
async function renderPrompt(
  content: string,
  context: string,
  variables: PromptVariable[],
  variableValues: Record<string, string>,
  projectId?: string
): Promise<string> {
  let renderedContent = content;
  let renderedContext = context;

  for (const variable of variables) {
    let valueToSubstitute = variableValues[variable.placeholder] || variable.defaultValue || '';

    // If it's a project data variable and we don't have a value in variableValues (meaning we didn't mock or resolve it)
    // For the UI, we just show a placeholder to indicate it's dynamic
    if (variable.source && !variableValues[variable.placeholder]) {
       valueToSubstitute = `[${variable.name} (dynamic)]`;
    }

    const highlightedValue = `[[${valueToSubstitute}]]`;
    const regex = new RegExp(variable.placeholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g');
    renderedContent = renderedContent.replace(regex, highlightedValue);
    renderedContext = renderedContext.replace(regex, highlightedValue);
  }

  const lines = [
    "System role:",
    "You are an expert assistant for this project.",
    "",
    "Context:",
    renderedContext || "(none)",
    "",
    "Prompt:",
    renderedContent || "(empty)",
  ];
  return lines.join("\n");
}

/* ---------- MAIN COMPONENT ---------- */
export function PromptLab({ prompt, onBack, projectId }: { prompt: Prompt; onBack: () => void; projectId?: string }) {
  const queryClient = useQueryClient(); // Access query client for manual cache updates

  const updatePromptMutation = useUpdatePrompt();
  const snapshotPromptMutation = useSnapshotPrompt();
  const restorePromptVersionMutation = useRestorePromptVersion();

  const [selectedVersionId, setSelectedVersionId] = useState<string | null>(null)
  const [compare, setCompare] = useState<{ open: boolean; version?: Version }>({ open: false }) // Not used currently, but kept from original
  const [rightTab, setRightTab] = useState<"editor" | "version-details" | "preview">("editor")
  const [leftTab, setLeftTab] = useState<"versions" | "variables">("variables")
  const [showVariableBuilder, setShowVariableBuilder] = useState(false);
  const [previewVariableValues, setPreviewVariableValues] = useState<Record<string, string>>({})
  const [renderedPreview, setRenderedPreview] = useState("");
  const [pendingNotes, setPendingNotes] = useState("");

  // When the prompt prop changes, ensure selected version is valid
  useEffect(() => {
    console.log('[Prompt Lab] Root useEffect: Prompt prop or selectedVersionId changed.');
    if (prompt) {
      if (prompt.versions.length > 0) {
        if (!selectedVersionId || !prompt.versions.some((v) => v.id === selectedVersionId)) {
          setSelectedVersionId(prompt.versions[0].id)
          console.log(`[Prompt Lab] Root useEffect: Setting selectedVersionId to first version: ${prompt.versions[0].id}`);
        }
      } else if (selectedVersionId) {
        setSelectedVersionId(null)
        console.log('[Prompt Lab] Root useEffect: No versions, clearing selectedVersionId.');
      }
      
      const initialPreviewValues: Record<string, string> = {};
      prompt.variables.forEach(v => {
        if (!v.source) { // Only set default for manual variables in preview input
          initialPreviewValues[v.placeholder] = v.defaultValue || '';
        } else {
          // For project data variables, we'll try to resolve them dynamically for a better preview
          // This would ideally involve a `resolvePromptVariable` call here for each dynamic variable
          // For now, we'll just show a placeholder indicating it's dynamic
          initialPreviewValues[v.placeholder] = `[${v.name} (dynamic)]`;
        }
      });
      setPreviewVariableValues(initialPreviewValues);
    }
  }, [prompt, selectedVersionId]);


  useEffect(() => {
    if (prompt) {
      console.log('[Prompt Lab] Root useEffect: Generating preview...');
      const generatePreview = async () => {
        const preview = await renderPrompt(prompt.content, prompt.context || '', prompt.variables, previewVariableValues, projectId);
        setRenderedPreview(preview);
      };
      generatePreview();
    }
  }, [prompt, previewVariableValues, projectId]);


  const selectedVersion = useMemo(() => prompt?.versions.find((v) => v.id === selectedVersionId) || null, [prompt, selectedVersionId])

  function copy(text: string) {
    navigator.clipboard.writeText(text).catch(() => {})
  }

  const handleUpdatePrompt = useCallback((patch: Partial<Prompt>) => {
    updatePromptMutation.mutate({ input: { id: prompt.id, ...patch } });
  }, [prompt.id, updatePromptMutation]);

  const handleSnapshot = useCallback((notes?: string) => {
    snapshotPromptMutation.mutate({ input: { promptId: prompt.id, notes } });
    setPendingNotes(''); // Clear notes after snapshot
  }, [prompt.id, snapshotPromptMutation]);

  const handleRestoreVersion = useCallback((versionId: string) => {
    restorePromptVersionMutation.mutate({ input: { promptId: prompt.id, versionId } });
  }, [prompt.id, restorePromptVersionMutation]);

  const handleCreateVariable = useCallback((newVariable: Omit<PromptVariable, 'id'>) => {
    // Generate a client-side ID for the new variable before adding it
    const variableWithId: PromptVariable = {
      ...newVariable,
      id: cuid(),
    };
    const updatedVariables = [...prompt.variables, variableWithId];
    handleUpdatePrompt({ variables: updatedVariables });
    setShowVariableBuilder(false);
  }, [prompt.variables, handleUpdatePrompt]);

  const handleRemoveVariable = useCallback((variableId: string) => {
    const updatedVariables = prompt.variables.filter(v => v.id !== variableId);
    handleUpdatePrompt({ variables: updatedVariables });
  }, [prompt.variables, handleUpdatePrompt]);


  console.log('[Prompt Lab] Rendering: Main PromptLab component.', prompt.id, prompt.title);

  return (
    <DndProvider backend={HTML5Backend}>
      <div className="page-scroller pt-0 p-1 pb-0 h-full min-h-0">
        <div className="h-[85vh] overflow-hidden">
          <div className="grid h-full min-h-0 grid-cols-1 gap-4 p-4 pb-0 md:grid-cols-[320px_1fr]">

            {/* Left side */}
            <div className="saas-card h-full min-h-0 flex flex-col">
              <Tab.Group
                selectedIndex={leftTab === "versions" ? 0 : 1}
                onChange={(index) => {
                    setLeftTab(index === 0 ? "versions" : "variables");
                    console.log(`[Prompt Lab] Left Tab changed to: ${index === 0 ? "versions" : "variables"}`);
                }}
                className="flex-1 min-h-0 flex flex-col"
              >
                <div className="border-b flex flex-col pt-4 pb-2 px-3" style={{ borderColor: "var(--border)" }}>
                  <Button variant="ghost" onClick={onBack} className="mb-2 self-start text-sm px-2 -ml-2">Back to Prompt Library</Button>
                  <Tab.List className="flex h-11 bg-transparent">
                    <Tab className="px-3 py-2 ui-selected:border-b-2 ui-selected:font-semibold">Versions</Tab>
                    <Tab className="px-3 py-2 ui-selected:border-b-2 ui-selected:font-semibold">Variables</Tab>
                  </Tab.List>
                </div>

                <Tab.Panels className="flex-1 min-h-0 flex flex-col overflow-y-auto">
                  {/* Versions tab */}
                  <Tab.Panel className="flex-1 min-h-0 flex flex-col overflow-y-auto">
                    <div className="flex items-center gap-2 border-b p-3"
                     style={{ borderColor: "var(--border)", background: "var(--muted-bg)" }}
                     >
                      <h3 className="font-semibold">Versions</h3>
                      <Button className="ml-auto h-9 btn-primary" onClick={() => handleSnapshot('New version')}>
                        <Plus className="mr-1 h-4 w-4" /> New
                      </Button>
                    </div>
                    <div className="flex-1 min-h-0 overflow-y-auto p-3">
                      {prompt.versions.length === 0 ? (
                        <div className="text-sm text-slate-500">No versions yet. Make changes and save a snapshot to create one.</div>
                      ) : (
                        <ul className="space-y-2">
                          {prompt.versions.map((v) => (
                            <li key={v.id} className="rounded-lg border p-3 hover:bg-slate-50 transition">
                              <div className="flex items-start gap-2">
                                <button className="flex-1 text-left" onClick={() => setSelectedVersionId(v.id)} title={v.notes}>
                                  <div className={`line-clamp-1 text-sm font-medium ${selectedVersionId === v.id ? 'font-bold' : ''}`}>{v.notes}</div>
                                  <div className="mt-1 text-xs text-slate-500">{new Date(v.createdAt).toLocaleString()}</div>
                                </button>
                                {selectedVersionId !== v.id && (
                                  <Button variant="ghost" size="sm" onClick={() => handleRestoreVersion(v.id)} className="h-7 px-2">
                                    Restore
                                  </Button>
                                )}
                              </div>
                            </li>
                          ))}
                        </ul>
                      )}
                    </div>
                  </Tab.Panel>

                  {/* Variables tab */}
                  <Tab.Panel className="flex-1 min-h-0 flex flex-col overflow-y-auto">
                    <div className="flex flex-col gap-2 border-b p-3" style={{ borderColor: "var(--border)", background: "var(--muted-bg)" }}>
                      <h3 className="font-semibold">Variables</h3>
                      <Button className="w-full h-9 btn-primary" onClick={() => setShowVariableBuilder(true)}>
                        <Plus className="mr-1 h-4 w-4" /> Create New Variable
                      </Button>
                    </div>
                    <div className="flex-1 min-h-0 overflow-y-auto p-3">
                      {prompt.variables.length === 0 ? (
                        <div className="text-sm text-slate-500">No variables yet. Click "Create New Variable" to get started.</div>
                      ) : (
                        <ul className="space-y-2">
                          {prompt.variables.map((v) => (
                            <VariableItem key={v.id} variable={v} onRemove={handleRemoveVariable} />
                          ))}
                        </ul>
                      )}
                    </div>
                  </Tab.Panel>
                </Tab.Panels>
              </Tab.Group>
            </div>

            {/* Right side */}
            <div className="saas-card h-full min-h-0 flex flex-col overflow-hidden">
              <div className="flex-1 min-h-0 overflow-y-auto">
                <Tabs value={rightTab} onValueChange={(v) => {
                    setRightTab(v as any);
                    console.log(`[Prompt Lab] Right Tab changed to: ${v}`);
                }} className="flex h-full flex-col">
                  <div className="border-b" style={{ borderColor: "var(--border)" }}>
                    <TabsList className="h-11 bg-transparent">
                      <TabsTrigger value="editor">Editor</TabsTrigger>
                      <TabsTrigger value="version-details">Version Details</TabsTrigger>
                      <TabsTrigger value="preview">Preview</TabsTrigger>
                    </TabsList>
                  </div>

                  <div className="min-h-0 flex-1 overflow-y-auto">
                    <TabsContent value="editor" className="m-0 outline-none flex-1 overflow-y-auto">
                      <EditorPanel
                          prompt={prompt}
                          onUpdate={handleUpdatePrompt}
                          onSnapshot={handleSnapshot}
                          pendingNotes={pendingNotes}
                          setPendingNotes={setPendingNotes}
                        />
                    </TabsContent>

                    {/* Version Details Panel */}
                    <TabsContent value="version-details" className="m-0 outline-none p-4 flex-1 overflow-y-auto">
                      <VersionsPanel
                        versions={prompt.versions || []}
                        selectedVersionId={selectedVersionId}
                        onSelectVersion={setSelectedVersionId}
                        onRestoreVersion={handleRestoreVersion}
                      />
                    </TabsContent>

                    {/* Preview Section */}
                    <TabsContent value="preview" className="m-0 outline-none p-4 flex-1 overflow-y-auto">
                      <div className="mb-2 flex items-center justify-between">
                        <div className="text-sm font-medium">Preview</div>
                        <Button size="sm" onClick={() => copy(renderedPreview)} className="h-8 btn-primary">
                          <Copy className="mr-1 h-4 w-4" />
                          Copy
                        </Button>
                      </div>
                      <Textarea
                        readOnly
                        value={renderedPreview}
                        className="min-h-[300px] font-mono overflow-y-auto"
                        // Add inline style to make the highlighting (e.g., [[value]]) stand out
                        style={{ background: '#f8f8f8', color: '#333', borderColor: '#e0e0e0', lineHeight: '1.5' }}
                      />
                      <p className="text-xs text-muted-foreground mt-2">
                        Note: Text wrapped in `[[...]]` indicates a substituted variable.
                      </p>
                    </TabsContent>
                  </div>
                </Tabs>
              </div>
            </div>
          </div>
        </div>

        {/* NEW: Variable Discovery Builder */}
        <VariableDiscoveryBuilder
          open={showVariableBuilder}
          onOpenChange={setShowVariableBuilder}
          onCreate={handleCreateVariable}
          projectId={projectId}
        />
      </div>
      <CustomDragLayer />
    </DndProvider>
  )
}

/* ---------- Variable Item (Sidebar) ---------- */

function VariableItem({ variable, onRemove }: { variable: PromptVariable; onRemove: (id: string) => void }) {
  const [{ isDragging }, drag, preview] = useDrag(() => ({
    type: ItemTypes.VARIABLE,
    item: { id: variable.id, placeholder: variable.placeholder, name: variable.name },
    collect: (monitor) => {
      const dragging = monitor.isDragging();
      // console.log(`[VariableItem ${variable.name}] collect: isDragging = ${dragging}, canDrag = ${monitor.canDrag()}`);
      return { isDragging: dragging };
    },
  }), [variable]);

  useEffect(() => {
    if (preview) {
        preview(getEmptyImage(), { captureDraggingState: true });
    }
    const dragSourceElement = document.getElementById(variable.id + '-drag-source');
    if (dragSourceElement) {
        drag(dragSourceElement);
        // console.log(`[VariableItem ${variable.name}] useEffect: Connected drag source to ID: ${variable.id}-drag-source`);
    } else {
        console.warn(`[Prompt Lab] [VariableItem ${variable.name}] useEffect: Drag source element not found for ID: ${variable.id}-drag-source`);
    }
  }, [drag, preview, variable.id, variable.name]);

  return (
    <div
      id={variable.id + '-drag-source'}
      className={`cursor-grab rounded px-2 py-1 mb-2 border ${
        isDragging ? 'opacity-0' : 'bg-gray-100' // Original item disappears when dragging starts
      } flex items-center justify-between group`}
    >
      <div>
        <span className="font-semibold">{variable.name}</span>
        <span className="text-xs text-gray-500 ml-2">({variable.placeholder})</span>
      </div>
      <button
        onClick={() => onRemove(variable.id)}
        className="ml-2 p-1 rounded-full text-gray-400 hover:bg-gray-200 hover:text-red-600 transition-opacity opacity-0 group-hover:opacity-100"
        aria-label={`Remove variable ${variable.name}`}
      >
        <Trash2 className="h-3 w-3" />
      </button>
    </div>
  )
}


/* ---------- BLOCK-BASED EDITOR ---------- */

type Block =
  | { type: 'text'; id: string; value: string }
  | { type: 'variable'; id: string; varId: string; placeholder: string; name: string } // `varId` links to PromptVariable.id

function parseContentToBlocks(content: string, variables: PromptVariable[]): Block[] {
  // console.log('[Prompt Lab] [parseContentToBlocks] START. Content:', content.substring(0, Math.min(content.length, 50)) + "...", 'Variables:', variables.map(v => v.placeholder));

  const sortedVariables = variables.length > 0
    ? variables.sort((a, b) => b.placeholder.length - a.placeholder.length)
    : [];
  const placeholders = sortedVariables.map(v => v.placeholder);

  let tempBlocks: Block[] = [];
  let currentText = '';

  if (placeholders.length > 0) {
    const escaped = placeholders.map(p => p.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|');
    const re = new RegExp(`(${escaped})`, 'g');
    const parts = content.split(re);

    parts.forEach((part) => {
      const matchedVar = sortedVariables.find(v => v.placeholder === part);
      if (matchedVar) {
        if (currentText !== '') {
          tempBlocks.push({ type: 'text', id: cuid('t-'), value: currentText });
          currentText = '';
        }
        tempBlocks.push({ type: 'variable', id: cuid('v-'), varId: matchedVar.id, placeholder: matchedVar.placeholder, name: matchedVar.name });
      } else {
        currentText += part;
      }
    });
  } else {
    currentText = content; // If no variables, the whole content is text
  }

  if (currentText !== '') {
    tempBlocks.push({ type: 'text', id: cuid('t-'), value: currentText });
  }

  // Remove empty text blocks, especially if they are redundant after splitting
  let finalBlocks: Block[] = [];
  for (let i = 0; i < tempBlocks.length; i++) {
    const block = tempBlocks[i];
    if (block.type === 'text' && block.value === '') {
      // If two consecutive text blocks are empty, or an empty text block is at the start/end
      // and it's not the only block, skip it.
      if (
        (i > 0 && finalBlocks.length > 0 && finalBlocks[finalBlocks.length - 1].type === 'text' && finalBlocks[finalBlocks.length - 1].value === '') ||
        (i === 0 && tempBlocks.length > 1) ||
        (i === tempBlocks.length - 1 && tempBlocks.length > 1)
      ) {
        continue;
      }
    }
    finalBlocks.push(block);
  }

  // Ensure there's always at least one editable text block if no content
  if (finalBlocks.length === 0) {
      return [{ type: 'text', id: cuid('t-initial-empty-fallback'), value: '' }];
  }

  // Edge case: if the very first block is an empty text block, remove it unless it's the only block.
  if (finalBlocks.length > 1 && finalBlocks[0].type === 'text' && finalBlocks[0].value === '') {
    finalBlocks.shift();
  }
  // Edge case: if the very last block is an empty text block, remove it unless it's the only block.
  if (finalBlocks.length > 1 && finalBlocks[finalBlocks.length - 1].type === 'text' && finalBlocks[finalBlocks.length - 1].value === '') {
    finalBlocks.pop();
  }

  // If after all processing, it's empty, add a single empty text block
  if (finalBlocks.length === 0) {
    return [{ type: 'text', id: cuid('t-final-empty-fallback'), value: '' }];
  }


  // console.log('[Prompt Lab] [parseContentToBlocks] END. Resulting blocks:', finalBlocks.map(b => `${b.type}: ${b.type === 'text' ? `"${b.value.substring(0, Math.min(b.value.length, 15))}..."` : b.placeholder}`));
  return finalBlocks;
}


function serializeBlocks(blocks: Block[]): string {
  const serialized = blocks
    .filter(b => !(b.type === 'text' && b.value === '')) // Filter out purely empty text blocks during serialization
    .map(b => b.type === 'text' ? b.value : b.placeholder)
    .join('');
  
  // console.log('[Prompt Lab] [serializeBlocks] Input blocks:', blocks.map(b => `${b.type}: ${b.type === 'text' ? `"${b.value.substring(0, Math.min(b.value.length, 15))}..."` : b.placeholder}`), 'Output content:', serialized.substring(0, Math.min(serialized.length, 50)) + "...");
  return serialized;
}


/* ---------- EditorPanel: Enhanced Prompt Creation ---------- */
function EditorPanel({
  prompt,
  onUpdate,
  onSnapshot,
  pendingNotes,
  setPendingNotes,
}: {
  prompt: Prompt
  onUpdate: (patch: Partial<Prompt>) => void
  onSnapshot: (notes?: string) => void
  pendingNotes: string;
  setPendingNotes: (notes: string) => void;
}) {
  const [blocks, setBlocks] = useState<Block[]>(() => {
    const initialBlocks = parseContentToBlocks(prompt.content || '', prompt.variables || []);
    // console.log('[Prompt Lab] [EditorPanel] useState initializer: Initial blocks set.');
    // logBlocks('Initial render', initialBlocks);
    return initialBlocks;
  });

  // Utility function to log the current blocks array in a readable format
  const logBlocks = useCallback((message: string, currentBlocks: Block[]) => {
    const formattedBlocks = currentBlocks.map(b =>
      b.type === 'text' ? `[TEXT:"${b.value.substring(0, Math.min(b.value.length, 30))}..."]` : `[VAR:${b.name || b.placeholder} (varId: ${b.varId})]`
    ).join(' | ');
    console.log(`[Prompt Lab] [EditorPanel] --- BLOCKS STATE UPDATE --- ${message}\nCURRENT BLOCKS: ${formattedBlocks}`);
  }, []);


  // Effect to re-parse blocks when prompt.content or prompt.variables from API changes
  useEffect(() => {
    // console.log('[Prompt Lab] [EditorPanel] useEffect [prompt.content, prompt.variables]: Re-parsing blocks due to prompt content/variables change...');
    const newBlocks = parseContentToBlocks(prompt.content || '', prompt.variables || []);
    if (!deepCompareBlocks(blocks, newBlocks)) { // Using deepCompareBlocks here
      setBlocks(newBlocks);
      // console.log('[Prompt Lab] [EditorPanel] useEffect [prompt.content, prompt.variables]: Blocks updated after deep compare.');
      logBlocks('After prompt.content/variables re-parse (and deep compare)', newBlocks);
    } else {
      // console.log('[Prompt Lab] [EditorPanel] useEffect [prompt.content, prompt.variables]: Blocks are deeply identical, no state update.');
    }
  }, [prompt.content, prompt.variables]); // blocks should NOT be a dependency here, it's the state being set

  // Effect to serialize current blocks state and call onUpdate if content changed
  useEffect(() => {
    // console.log('[Prompt Lab] [EditorPanel] useEffect [blocks]: Blocks state changed. Serializing...');
    const serialized = serializeBlocks(blocks);
    if (serialized !== prompt.content) {
      // console.log(`[Prompt Lab] [EditorPanel] useEffect [blocks]: Content differs, calling onUpdate. Old: ${prompt.content.substring(0, Math.min(prompt.content.length, 50))}..., New: ${serialized.substring(0, Math.min(serialized.length, 50))}...`);
      onUpdate({ content: serialized });
    } else {
      // console.log('[Prompt Lab] [EditorPanel] useEffect [blocks]: Content is the same, no update needed.');
    }
  }, [blocks, onUpdate, prompt.content]); // `prompt.content` as dependency for comparison


  const insertVariableAt = useCallback((index: number, variable: { placeholder: string; id: string; name: string }) => {
    // console.log(`[Prompt Lab] [EditorPanel] insertVariableAt: Attempting to insert variable "${variable.placeholder}" at index ${index}.`);
    setBlocks(prev => {
      let copy = [...prev];
      const newVarBlock: Block = { type: 'variable', id: cuid('v-'), varId: variable.id, placeholder: variable.placeholder, name: variable.name };
      
      copy.splice(index, 0, newVarBlock);
      logBlocks(`After directly inserting variable "${variable.placeholder}" at index ${index}`, copy);
      return copy;
    });
  }, [logBlocks]);


  const insertTextAt = useCallback((index: number, text = '') => {
    // console.log(`[Prompt Lab] [EditorPanel] insertTextAt: Attempting to insert text block at index ${index}.`);
    setBlocks(prev => {
      let copy = [...prev];
      const newBlock: Block = { type: 'text', id: cuid('t-'), value: text }

      copy.splice(index, 0, newBlock)
      logBlocks(`After directly inserting text block at index ${index}`, copy);
      return copy
    })
  }, [logBlocks]);

  const updateTextBlock = useCallback((id: string, value: string) => {
    setBlocks(prev => {
        let updated = prev.map(b => b.type === 'text' && b.id === id ? { ...b, value } : b);
        
        // If a text block becomes empty on direct user input, remove it *unless* it's the sole block.
        if (value === '' && prev.length > 1) {
             updated = updated.filter(b => !(b.type === 'text' && b.id === id && b.value === ''));
        }

        logBlocks(`After updating text block ${id} to "${value.substring(0, Math.min(value.length, 30))}..."`, updated);
        return updated;
    });
  }, [logBlocks]);

  const removeBlock = useCallback((index: number) => {
    // console.log(`[Prompt Lab] [EditorPanel] removeBlock: Removing block at index ${index}. Current blocks:`, blocks.map(b => b.id));
    setBlocks(prev => {
      let copy = [...prev];
      if (index < 0 || index >= copy.length) {
          // console.warn(`[Prompt Lab] [EditorPanel] removeBlock: Invalid index ${index}.`);
          return prev;
      }

      copy.splice(index, 1); 
      
      // If all blocks are removed, ensure there's at least one empty text block
      if (copy.length === 0) {
        copy.push({ type: 'text', id: cuid('t-empty-after-remove'), value: '' });
      }

      // console.log(`[Prompt Lab] [EditorPanel] removeBlock: Removed block at index ${index}. New block count: ${copy.length}. Blocks state WILL BE updated.`);
      logBlocks(`After removing block at index ${index}`, copy);
      return copy
    })
  }, [blocks, logBlocks]);

  const moveBlock = useCallback((from: number, to: number) => {
    // console.log(`[Prompt Lab] [EditorPanel] moveBlock: Attempting to move block from index ${from} to ${to}. Current blocks:`, blocks.map(b => b.id));
    setBlocks(prev => {
      let copy = [...prev];
      if (from < 0 || from >= copy.length || to < 0 || to > copy.length) {
          // console.warn(`[Prompt Lab] [EditorPanel] moveBlock: Invalid 'from' or 'to' index. from=${from}, to=${to}.`);
          return prev;
      }

      const [item] = copy.splice(from, 1);
      copy.splice(to, 0, item);

      // console.log(`[Prompt Lab] [EditorPanel] moveBlock: Block ${item.id} moved from ${from} to ${to}. Blocks state WILL BE updated.`);
      logBlocks(`After moving block from ${from} to ${to}`, copy);
      return copy;
    });
  }, [blocks, logBlocks]);

  const { isDragging: isDraggingSomething } = useDragLayer((monitor) => ({
    isDragging: monitor.isDragging(),
  }));

  const [{ isOverBlockContainer, canDropBlockContainer }, dropBlockContainer] = useDrop(() => ({
    accept: [ItemTypes.VARIABLE, ItemTypes.BLOCK],
    drop: (item: any, monitor) => {
      if (monitor.didDrop()) {
        // console.log('[Prompt Lab] [EditorPanel] useDrop (container): Drop already handled by a child component. Exiting.');
        return;
      }

      let targetIndex = blocks.length;
      if (blocks.length === 0) {
        targetIndex = 0;
      }

      if (monitor.getItemType() === ItemTypes.VARIABLE) {
        // console.log('[Prompt Lab] [EditorPanel] useDrop (container, fallback to end): Variable dropped. Adding to end. Item:', item);
        insertVariableAt(targetIndex, item); // Pass full variable object as `item` now contains `id`, `name`, `placeholder`
      } else if (monitor.getItemType() === ItemTypes.BLOCK) {
        const dragIndex = item.index;
        if (blocks.length === 0) {
            // console.log('[Prompt Lab] [EditorPanel] useDrop (container, empty): Block dropped. Moving to index 0. Item:', item);
            moveBlock(dragIndex, 0);
        } else {
            // console.log('[Prompt Lab] [EditorPanel] useDrop (container, fallback to end): Block dropped. Moving to end. Item:', item);
            moveBlock(dragIndex, targetIndex);
        }
      }
    },
    collect: (monitor) => {
        const isOver = monitor.isOver({ shallow: true });
        const canDrop = monitor.canDrop();
        // if (isDraggingSomething) { 
        //      console.log(`[EditorPanel] DropContainer: isOver = ${isOver}, canDrop = ${canDrop}. ItemType: ${String(monitor.getItemType())}`);
        // }
        return {
            isOverBlockContainer: isOver,
            canDropBlockContainer: canDrop,
        };
    },
  }), [blocks.length, insertVariableAt, moveBlock, isDraggingSomething]);


  return (
    <div className="flex h-full min-h-0 flex-col">
      <div className="saas-section-header rounded-t-lg">
        <div className="grid flex-1 grid-cols-1 gap-3 md:grid-cols-2">
          <Input
            value={prompt.title}
            onChange={(e) => handleUpdatePrompt({ title: e.target.value || "Untitled Prompt" })}
            className="h-10 text-sm font-medium"
            placeholder="Prompt title"
          />
          <select
            className="h-10 rounded-md border bg-background px-3 text-sm"
            value={prompt.model}
            onChange={(e) => handleUpdatePrompt({ model: e.target.value })}
            title="Target model"
          >
            <option value="gpt-4o">OpenAI GPT-4o</option>
            <option value="gpt-4o-mini">OpenAI GPT-4o-mini</option>
            <option value="grok-3">xAI Grok-3</option>
            <option value="llama3.1-70b">Llama 3.1 70B</option>
            <option value="mixtral-8x7b">Mixtral 8x7B</option>
          </select>
        </div>
      </div>

      <div className="flex-1 overflow-auto p-4">
        <section className="rounded-lg border p-4 mb-4">
          <div className="mb-2 text-sm font-medium">Project context</div>
          <Textarea
            value={prompt.context}
            onChange={(e) => handleUpdatePrompt({ context: e.target.value })}
            rows={6}
            className="overflow-y-auto"
            placeholder="Add domain, audience, constraints, style guides, and examples. Use {{variables}} if needed."
          />
        </section>

        <section className="rounded-lg border p-4 mb-4">
          <div className="mb-2 text-sm font-medium">Prompt content</div>
          <div
            ref={dropBlockContainer}
            className={`flex flex-col gap-2 min-h-[300px] border rounded p-3
                        ${isOverBlockContainer && canDropBlockContainer && isDraggingSomething ? 'bg-indigo-50 border-indigo-300' : 'bg-gray-50'}`}
          >
            {blocks.length === 0 && !isDraggingSomething ? (
                <div className="flex-1 text-center py-12 text-gray-400">
                    Drag variables or click "+ Add text" to start building your prompt.
                    <button
                      onClick={() => insertTextAt(0, '')}
                      className="mt-4 px-3 py-1 border rounded-md text-sm text-gray-700 bg-white hover:bg-gray-100 flex items-center justify-center mx-auto"
                    >
                      <Text className="mr-1 h-4 w-4" /> Add text
                    </button>
                </div>
            ) : (
                blocks.map((b, i) => (
                    <React.Fragment key={`block-fragment-${b.id}`}> {/* Key for Fragment needed when Fragment is directly mapped */}
                        {/* Render the initial HoverAddTextBlock if it's the very first element */}
                        {i === 0 && (
                          <HoverAddTextBlock
                              key={`hover-insert-before-first`}
                              index={0}
                              insertTextAt={insertTextAt}
                          />
                        )}
                        <BlockRenderer
                            key={`block-${b.id}`} // Unique key for the BlockRenderer component
                            block={b}
                            index={i}
                            allBlocks={blocks}
                            updateTextBlock={updateTextBlock}
                            removeBlock={removeBlock}
                            moveBlock={moveBlock}
                            insertVariableAt={insertVariableAt}
                            isDraggingSomething={isDraggingSomething}
                            insertTextAt={insertTextAt}
                        />
                        {/* Always render HoverAddTextBlock after each block (except perhaps after the very last one, which is covered by container drop) */}
                        <HoverAddTextBlock
                            key={`hover-insert-after-${b.id}-${i}`} // Unique key for HoverAddTextBlock
                            index={i + 1}
                            insertTextAt={insertTextAt}
                        />
                    </React.Fragment>
                ))
            )}
            
            {blocks.length === 0 && isOverBlockContainer && canDropBlockContainer && isDraggingSomething && (
                <div className="flex-1 flex items-center justify-center border-2 border-dashed border-indigo-400 rounded-md bg-indigo-50 text-indigo-700 h-24">
                    Drop item here
                </div>
            )}
          </div>
        </section>

        <section className="flex items-center gap-2">
          <Input
            placeholder="Notes for this version"
            value={pendingNotes}
            onChange={(e) => setPendingNotes(e.target.value)}
            className="flex-1"
          />
          <Button
            onClick={() => { handleSnapshot(pendingNotes); }}
            className="btn-primary"
            disabled={snapshotPromptMutation.isLoading}
          >
            {snapshotPromptMutation.isLoading ? <Loader2 className="mr-1 h-4 w-4 animate-spin" /> : <GitCommit className="mr-1 h-4 w-4" />}
            Save
          </Button>
        </section>
      </div>
    </div>
  )
}


/* ---------- Block Renderer: Puzzle-style variable/text blocks ---------- */
function BlockRenderer({
  block,
  index,
  allBlocks,
  updateTextBlock,
  removeBlock,
  moveBlock,
  insertVariableAt,
  isDraggingSomething,
  insertTextAt,
}: {
  block: Block
  index: number
  allBlocks: Block[];
  updateTextBlock: (id: string, value: string) => void
  removeBlock: (index: number) => void
  moveBlock: (from: number, to: number) => void
  insertVariableAt: (index: number, variable: { placeholder: string; id: string; name: string }) => void
  isDraggingSomething: boolean;
  insertTextAt: (index: number, text?: string) => void;
}) {
  const contentEditableRef = useRef<HTMLDivElement | null>(null);
  const wrapperRef = useRef<HTMLDivElement | null>(null); // This is the main outermost wrapper

  // Local state for the contentEditable div to prevent excessive parent re-renders
  const [localTextContent, setLocalTextContent] = useState(block.type === 'text' ? block.value : '');

  // Update local state when prop `block.value` changes (e.g., undo/redo, initial load)
  // This effect also manages direct DOM update for contentEditable to prevent focus loss.
  useEffect(() => {
    if (block.type === 'text') {
      if (localTextContent !== block.value) {
        setLocalTextContent(block.value);
      }
      if (contentEditableRef.current && contentEditableRef.current.innerText !== block.value && document.activeElement !== contentEditableRef.current) {
        contentEditableRef.current.innerText = block.value;
      }
    }
  }, [block.type, block.value]); // Only depend on block.value to trigger updates for external changes.

  // Set up drag for the block
  const [{ isDragging, canDrag }, dragRef, preview] = useDrag(() => ({
    type: ItemTypes.BLOCK,
    item: {
      id: block.id,
      index,
      type: block.type,
      value: block.type === 'text' ? localTextContent : block.placeholder, // Use localTextContent for drag item info
      name: block.type === 'variable' ? block.name : undefined,
      varId: block.type === 'variable' ? block.varId : undefined, // Include varId for variable blocks
      originalBlock: block,
    },
    canDrag: (monitor) => {
      const result = true;
      // console.log(`[BlockRenderer ${block.type}:${block.id} (index ${index})] canDrag callback called. Returning: ${result}. monitor.getItem():`, monitor.getItem()?.id);
      return result;
    },
    collect: (m) => {
        const dragging = m.isDragging();
        const currentCanDrag = m.canDrag();
        // console.log(`[BlockRenderer ${block.type}:${block.id} (index ${index})] Drag Collect: isDragging = ${dragging}, canDrag = ${currentCanDrag}`);
        return { isDragging: dragging, canDrag: currentCanDrag };
    },
  }), [block.id, index, block.type, localTextContent, block.placeholder, block.name, block.varId]); // Depend on localTextContent, block.varId for the item's value

  // Use a stable useCallback for the ref functions
  const connectDragSource = useCallback((node: HTMLElement | null) => {
    // console.log(`[BlockRenderer ${block.type}:${block.id} (index ${index})] connectDragSource called. Node:`, node);
    dragRef(node); // Connects the node to react-dnd's drag source
  }, [dragRef]); // Only dragRef as a dependency here, it's a stable memoized function

  // Effect to hide browser drag image
  useEffect(() => {
    preview(getEmptyImage(), { captureDraggingState: true });
  }, [preview]);


  const [localDropTargetPosition, setLocalDropTargetPosition] = useState<'before' | 'after' | null>(null);

  // Set up drop for the block
  const [{ isOver, canDrop }, dropRef] = useDrop(() => ({
    accept: [ItemTypes.VARIABLE, ItemTypes.BLOCK],
    hover(item: { id?: string; index?: number; placeholder?: string }, monitor) {
      if (!wrapperRef.current) {
        return;
      }
      if (!monitor.isOver({ shallow: true })) {
        if (localDropTargetPosition !== null) {
            setLocalDropTargetPosition(null);
        }
        return;
      }

      const hoverBoundingRect = wrapperRef.current.getBoundingClientRect();
      const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
      const clientOffset = monitor.getClientOffset();
      if (!clientOffset) {
        return;
      }
      const hoverClientY = clientOffset.y - hoverBoundingRect.top;

      let newDropPosition: 'before' | 'after' | null = null;
      const draggingItemType = monitor.getItemType();

      // Avoid showing drop indicator if dragging self
      if (draggingItemType === ItemTypes.BLOCK && (item as { id: string }).id === block.id) {
        if (localDropTargetPosition !== null) {
            setLocalDropTargetPosition(null);
        }
        return;
      }

      if (draggingItemType === ItemTypes.BLOCK || draggingItemType === ItemTypes.VARIABLE) {
        newDropPosition = hoverClientY < hoverMiddleY ? 'before' : 'after';
      }

      if (localDropTargetPosition !== newDropPosition) {
        setLocalDropTargetPosition(newDropPosition);
      }
    },
    drop(item: any, monitor) {
      const dragItemType = monitor.getItemType();
      
      setLocalDropTargetPosition(null); // Clear hover state on drop

      if (monitor.didDrop()) {
        // console.log(`[BlockRenderer ${block.id}] drop: Drop already handled by a child or earlier component. Exiting.`);
        return;
      }

      let targetIndex = localDropTargetPosition === 'after' ? index + 1 : index;

      // console.log(`[BlockRenderer ${block.id}] drop: Item type ${String(dragItemType)}, item ID: ${item.id}, localDropTargetPosition: ${localDropTargetPosition}, targetIndex: ${targetIndex}.`);


      if (dragItemType === ItemTypes.VARIABLE) {
          // console.log(`[BlockRenderer ${block.id}] drop: Variable ${item.placeholder} dropped. Calling insertVariableAt(${targetIndex}, ...)`);
          insertVariableAt(targetIndex, item); // Pass full variable object as `item`
      } else if (dragItemType === ItemTypes.BLOCK) {
        const dragIndex = item.index;

        // Determine if this is a "no-op" move (dropping onto self or immediately adjacent position)
        const isNoRealMove = (dragIndex === targetIndex) ||
                             (dragIndex + 1 === targetIndex && localDropTargetPosition === 'before') ||
                             (dragIndex === targetIndex + 1 && localDropTargetPosition === 'after');
        
        // console.log(`[BlockRenderer ${block.id}] drop: Block dropped. Drag index: ${dragIndex}, Target index: ${targetIndex}, localDropTargetPosition: ${localDropTargetPosition}, isNoRealMove: ${isNoRealMove}`);


        if (isNoRealMove) {
          // console.log(`[BlockRenderer ${block.id}] drop: No real move detected for block ${item.id}. Exiting.`);
          return;
        }

        // console.log(`[BlockRenderer ${block.id}] drop: Moving block from ${dragIndex} to ${targetIndex}.`);
        moveBlock(dragIndex, targetIndex);
        item.index = targetIndex; // Update the index of the dragged item for subsequent drops
      }
    },
    collect: (monitor) => {
        const isOverVal = monitor.isOver({ shallow: true });
        const canDropVal = monitor.canDrop();
        // if (monitor.getItem()) { // Check if an item is currently being dragged
        //     console.log(`[BlockRenderer ${block.type}:${block.id} (index ${index})] Drop Collect: isOver = ${isOverVal}, canDrop = ${canDropVal}, itemType: ${String(monitor.getItemType())}`);
        // }
        return {
            isOver: isOverVal,
            canDrop: canDropVal,
        };
    },
  }), [index, insertVariableAt, moveBlock, localDropTargetPosition, block.id, allBlocks.length]); // Added allBlocks.length to dependencies

  // Merge wrapperRef and dropRef for the main block container
  const blockRootRef = mergeRefs(wrapperRef, dropRef); 

  const showPlaceholderAbove = isOver && canDrop && localDropTargetPosition === 'before' && isDraggingSomething;
  const showPlaceholderBelow = isOver && canDrop && localDropTargetPosition === 'after' && isDraggingSomething;

  const commonClasses = `relative w-full rounded-md shadow-sm transition-all duration-100 ease-in-out`;

  if (block.type === 'variable') {
    return (
      <div
        key={`block-root-${block.id}`} // Explicit key for this root div to aid reconciliation
        ref={blockRootRef} // This is the drop target
        // The main container div should still reflect `isDragging` state
        className={`${commonClasses} ${isDragging ? 'opacity-50' : ''} flex items-center gap-2 pr-2 group`} // Added gap-2 and pr-2 for spacing
      >
        {showPlaceholderAbove && <div className="absolute -top-1.5 left-0 right-0 h-1 bg-blue-500 rounded-sm z-10" />}
        
        {/* Dedicated drag handle for variable blocks - now uses connectDragSource */}
        <div
          ref={connectDragSource} // Assign connectDragSource directly to the handle
          className="cursor-grab shrink-0 flex items-center justify-center w-10 h-10 bg-blue-100 border border-blue-200 rounded-md text-blue-600 shadow-md transition-opacity duration-100 opacity-100 group-hover:opacity-100" // Always visible, prominent
        >
          <GripVertical className="h-6 w-6" /> {/* Increased size */}
        </div>

        <div
          className={`flex-1 flex items-center justify-between p-2 bg-blue-50 border border-blue-200 rounded-md `}
        >
          <div className="text-sm font-medium">{block.name || block.placeholder}</div>
          {/* Removed internal remove button from BlockRenderer to avoid confusion with sidebar's remove */}
        </div>
        {showPlaceholderBelow && <div className="absolute -bottom-1.5 left-0 right-0 h-1 bg-blue-500 rounded-sm z-10" />}
      </div>
    )
  } else {
    const onKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {
      // Allow new lines (Enter) within the contentEditable div
      if (e.key === 'Enter' && !e.shiftKey) {
        return; // Exit early to let browser handle native newline
      }
      if (e.key === 'Backspace' && contentEditableRef.current?.innerText === '' && window.getSelection()?.anchorOffset === 0) {
          e.preventDefault(); // Prevent default if removing the last char in an empty block
          if (allBlocks.length === 1 && allBlocks[0].id === block.id) {
              updateTextBlock(block.id, ''); 
          } else {
              removeBlock(index);
          }
      }
    }

    const onInput = (e: React.FormEvent<HTMLDivElement>) => {
      setLocalTextContent(e.currentTarget.innerText);
    }

    const onBlur = () => {
      const text = contentEditableRef.current?.innerText ?? ''
      if (text === '' && allBlocks.length > 1) {
          removeBlock(index);
      } else if (localTextContent !== block.value) { // Only update if content actually changed from the *prop value*
        updateTextBlock(block.id, localTextContent);
      }
    }

    return (
      <div
        key={`block-root-${block.id}`} // Explicit key for this root div to aid reconciliation
        ref={blockRootRef} // This is the drop target
        className={`${commonClasses} ${isDragging ? 'opacity-50' : ''} flex items-center gap-2 pr-2 group`} // Added flex items-center, gap-2 and pr-2
      >
        {showPlaceholderAbove && <div className="absolute -top-1.5 left-0 right-0 h-1 bg-blue-500 rounded-sm z-10" />}
        <div
          className={`relative flex-1 p-2 bg-white border border-gray-300 rounded-md flex items-center group`}
        >
            {/* Existing drag handle for text blocks - now uses connectDragSource */}
            <div
              ref={connectDragSource} // Assign connectDragSource directly to the handle
              // Made bigger and more visible, always visible
              className="cursor-grab shrink-0 flex items-center justify-center w-10 h-10 -ml-3 mr-2 text-gray-700 bg-gray-100 border border-gray-300 rounded-md shadow-md transition-opacity duration-100 opacity-100 group-hover:opacity-100"
              style={{ position: 'relative', left: '0', top: '0', transform: 'none' }} // Ensure position is relative within its flex container
            >
              <GripVertical className="h-6 w-6" /> {/* Increased size */}
            </div>
            <div
                contentEditable
                suppressContentEditableWarning
                onKeyDown={onKeyDown}
                onInput={onInput}
                onBlur={onBlur}
                className="flex-1 min-h-[40px] text-sm outline-none w-full whitespace-pre-wrap py-2" // Added py-2 for vertical padding, flex-1 for stretching
                style={{ wordBreak: 'break-word' }} // ADD THIS LINE for word wrapping
                ref={contentEditableRef}
            >
                {/* Content will be managed by localTextContent and useEffect */}
            </div>
            {(allBlocks.length > 1) || (block.type === 'text' && block.value !== '') ? (
                <button
                    onClick={() => {
                        removeBlock(index);
                    }}
                    className="ml-2 p-1 rounded-full text-gray-400 hover:bg-gray-200 hover:text-red-600 transition-opacity"
                    aria-label={`Remove text block`}
                >
                    <Trash2 className="h-4 w-4" />
                </button>
            ) : null}
        </div>
        {showPlaceholderBelow && <div className="absolute -bottom-1.5 left-0 right-0 h-1 bg-blue-500 rounded-sm z-10" />}
      </div>
    )
  }
}

const getEmptyImage = () => {
    if (typeof window === 'undefined') return new Image();
    const img = new Image();
    img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
    return img;
};


// NEW: HoverAddTextBlock component for interstitial "Add text" buttons
function HoverAddTextBlock({
  index,
  insertTextAt,
}: {
  index: number;
  insertTextAt: (index: number, text?: string) => void;
}) {
  const [isHovering, setIsHovering] = useState(false);

  return (
    <div
      key={`hover-add-text-${index}`} // Explicit key for consistency
      className="relative h-6 w-full flex justify-center items-center py-1 transition-all duration-100 ease-in-out group"
      onMouseEnter={() => setIsHovering(true)}
      onMouseLeave={() => setIsHovering(false)}
    >
      <div className={`absolute top-0 w-full h-full bg-transparent transition-all duration-100 ease-in-out
                      ${isHovering ? 'bg-gray-100/50' : 'bg-transparent'}`}></div>

      {isHovering && (
        <Button
          variant="ghost"
          size="sm"
          onClick={(e) => {
            e.stopPropagation();
            insertTextAt(index);
            setIsHovering(false);
          }}
          className="relative z-10 h-6 px-2 py-1 text-xs bg-gray-200 text-gray-700 hover:bg-gray-300 focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 transition-all duration-100 ease-in-out transform scale-90 group-hover:scale-100"
        >
          <Text className="mr-1 h-3 w-3" /> Add text
        </Button>
      )}
    </div>
  );
}


function CustomDragLayer() {
  const {
    itemType,
    isDragging,
    item,
    currentOffset,
  } = useDragLayer((monitor) => ({
    item: monitor.getItem(),
    itemType: monitor.getItemType(),
    currentOffset: monitor.getClientOffset(),
    isDragging: monitor.isDragging(),
  }));


  if (!isDragging || !currentOffset || !item) {
    return null;
  }

  const layerStyles: React.CSSProperties = {
    position: 'fixed',
    pointerEvents: 'none',
    zIndex: 9999,
    left: 0,
    top: 0,
    transform: `translate(${currentOffset.x}px, ${currentOffset.y}px)`,
  };

  const renderItem = () => {
    switch (itemType) {
      case ItemTypes.VARIABLE:
        const variableItem = item as { id: string; placeholder: string; name?: string };
        return (
          <div className="bg-blue-200 border border-blue-400 rounded-md px-3 py-1 shadow-md opacity-90">
            <span className="font-semibold">{variableItem.name || variableItem.placeholder}</span>
            <span className="text-xs text-blue-700 ml-2">(Drag Variable)</span>
          </div>
        );
      case ItemTypes.BLOCK:
        const blockItem = item as { originalBlock: Block };
        const blockToRender = blockItem.originalBlock;

        if (blockToRender.type === 'variable') {
          return (
            <div className="flex items-center justify-between p-2 bg-blue-50 border border-blue-200 rounded-md shadow-md opacity-90">
              <div className="text-sm font-medium">{blockToRender.name || blockToRender.placeholder}</div>
            </div>
          );
        } else { // Text block
          return (
            <div className="relative p-2 bg-white border border-gray-300 rounded-md flex items-center shadow-md opacity-90">
              <div
                  className="flex-1 min-h-[40px] text-sm w-full whitespace-pre-wrap"
                  style={{ minWidth: '100px', maxWidth: '300px' }}
              >
                  {blockToRender.value.substring(0, Math.min(blockToRender.value.length, 100)) + (blockToRender.value.length > 100 ? '...' : '')}
              </div>
            </div>
          );
        }
      case '__NATIVE_HTML__':
        return (
            <div className="bg-red-200 border border-red-400 rounded-md px-3 py-1 shadow-md opacity-90">
                <span className="font-semibold text-red-800">Dragging HTML Element</span>
                <span className="text-xs text-red-700 ml-2">(Native Drag)</span>
            </div>
        );
      default:
        return null;
    }
  };

  return (
    <div style={layerStyles}>
      {renderItem()}
    </div>
  );
}


/* ---------- VersionsPanel ---------- */

function VersionsPanel({
  versions,
  selectedVersionId,
  onSelectVersion,
  onRestoreVersion,
}: {
  versions: Version[]
  selectedVersionId: string | null
  onSelectVersion: (id: string) => void
  onRestoreVersion: (versionId: string) => void
}) {
  const selectedVersion = versions.find(v => v.id === selectedVersionId);
  if (!selectedVersion) {
    // If no version is selected, default to the latest version for display if available
    const latestVersion = versions.length > 0 ? versions[0] : null;
    if (latestVersion) {
      onSelectVersion(latestVersion.id); // Automatically select the latest
    } else {
      return (
        <div className="grid h-full place-items-center text-sm text-slate-500">
          No version selected.
        </div>
      );
    }
  }

  return (
    <div className="flex h-full min-h-0 flex-col p-4">
        <h3 className="font-semibold text-lg mb-2">{selectedVersion?.notes || 'No Notes'}</h3>
        <p className="text-sm text-gray-500 mb-4">Last Edited: {new Date(selectedVersion?.createdAt || '').toLocaleString()}</p>

        <div className="mb-4">
            <label className="block text-sm font-medium mb-1">Version Content</label>
            <Textarea
                readOnly
                value={selectedVersion?.content || ''}
                rows={10}
                className="font-mono overflow-y-auto bg-gray-50 dark:bg-gray-800"
                placeholder="No content available for this version."
            />
        </div>
        <div className="mb-4">
            <label className="block text-sm font-medium mb-1">Version Context</label>
            <Textarea
                readOnly
                value={selectedVersion?.context || ''}
                rows={5}
                className="font-mono overflow-y-auto bg-gray-50 dark:bg-gray-800"
                placeholder="No context available for this version."
            />
        </div>

        <div className="mb-4">
            <label className="block text-sm font-medium mb-1">Variables in this Version</label>
            {selectedVersion?.variables && selectedVersion.variables.length > 0 ? (
                <ul className="space-y-1">
                    {selectedVersion.variables.map(v => (
                        <li key={v.id} className="text-sm bg-gray-100 dark:bg-gray-700 p-2 rounded flex items-center justify-between">
                            <span className="font-semibold">{v.name}</span>
                            <span className="text-xs text-gray-600 dark:text-gray-400">({v.placeholder})</span>
                        </li>
                    ))}
                </ul>
            ) : (
                <p className="text-sm text-gray-500">No variables for this version.</p>
            )}
        </div>
    </div>
  )
}
```

---

### 8. `components/prompt-lab/prompt-list.tsx` (Updated to use API hook)

This component will fetch the list of prompts using `useProjectPrompts`.

```typescript
// components/prompt-lab/prompt-list.tsx
'use client'

import PromptCard from './prompt-card';
import { Button } from "@/components/ui/button"
import { Plus, Loader2 } from "lucide-react"
import { usePromptLab } from './store'; // Still using this hook for the `create` action
import { useProjectPrompts } from '@/hooks/use-prompt-api'; // NEW: Import useProjectPrompts hook


export function PromptList({ onSelectPrompt, projectId }: { onSelectPrompt: (id: string) => void; projectId?: string }) {
  // Fetch prompts using the API hook directly
  const { data: prompts, isLoading, isError } = useProjectPrompts(projectId);
  const { create } = usePromptLab(projectId); // Use usePromptLab for the `create` mutation


  const handleCreatePrompt = () => {
    // When creating a prompt, the usePromptLab hook will handle the API call
    // and update the cache. We then use the temporary ID for immediate UI feedback.
    const newPromptTemp = create();
    onSelectPrompt(newPromptTemp.id);
  };

  if (isLoading) {
    return (
      <div className="page-scroller p-6 flex flex-col items-center justify-center h-full">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
        <p className="mt-4 text-slate-500">Loading prompts...</p>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="page-scroller p-6 flex flex-col items-center justify-center h-full text-red-500">
        <p>Error loading prompts. Please try again.</p>
      </div>
    );
  }

  return (
    <div className="page-scroller p-6">
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-2xl font-semibold">Prompt Library</h2>
        <Button onClick={handleCreatePrompt}>
          <Plus className="h-4 w-4 mr-2" />
          New Prompt
        </Button>
      </div>
      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        {prompts.length === 0 ? (
          <p className="col-span-full text-center text-slate-500">No prompts found. Click "New Prompt" to create one.</p>
        ) : (
          prompts.map((prompt) => (
            <PromptCard key={prompt.id} prompt={prompt} onClick={() => onSelectPrompt(prompt.id)} />
          ))
        )}
      </div>
    </div>
  )
}
```

---

### 9. `components/prompt-lab/prompt-versions.tsx` (Removed/Refactored)

The `VersionsPanel` in `prompt-lab.tsx` now directly handles rendering versions. The `PromptVersions` component is no longer directly used as a standalone component in the main `PromptLab` view, and its logic has been integrated. I will remove this file since `VersionsPanel` is already rendering versions in `prompt-lab.tsx`.

---

### 10. `components/prompt-lab/variable-discovery-builder.tsx` (Updated to use API hook for preview)

This component will use the `useResolvePromptVariable` hook to fetch live previews of dynamic variables.

```typescript
// components/prompt-lab/variable-discovery-builder.tsx
'use client'

import React, { useState, useEffect, useMemo, useCallback } from 'react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Command, CommandInput, CommandItem, CommandList, CommandEmpty, CommandGroup } from "@/components/ui/command";
import { Check, ChevronsUpDown, ArrowLeft, Lightbulb, Keyboard, Database, ListChecks, Calendar, FileText, Users, Briefcase, Loader2 } from 'lucide-react';
import { cn } from '@/lib/utils';
import { PromptVariable, PromptVariableType, PromptVariableSource } from './store'; // Adjust path as needed
import { useDebounce } from 'use-debounce'; // For live preview debouncing
import { toast } from 'sonner';
import { useResolvePromptVariable } from '@/hooks/use-prompt-api'; // NEW: Import the resolver hook


// Utility to generate a clean placeholder from a name
function generatePlaceholder(name: string): string {
  if (!name) return '';
  const cleaned = name.toLowerCase().replace(/\s/g, '_').replace(/[^a-z0-9_]/g, '');
  return `{{${cleaned}}}`;
}

interface VariableDiscoveryBuilderProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onCreate: (variable: Omit<PromptVariable, 'id'>) => void;
  projectId?: string;
}

// Helper component for visually distinct cards
const SelectionCard: React.FC<{
  icon: React.ElementType;
  title: string;
  description: string;
  onClick: () => void;
  disabled?: boolean;
}> = ({ icon: Icon, title, description, onClick, disabled }) => (
  <button
    onClick={onClick}
    disabled={disabled}
    className={cn(
      "flex flex-col items-center justify-center p-6 rounded-lg border-2 border-dashed transition-all text-center h-40", // Added h-40 for consistent height
      "hover:border-primary hover:bg-muted/50 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2",
      disabled ? "opacity-50 cursor-not-allowed bg-gray-100" : "bg-card"
    )}
  >
    <Icon className="h-10 w-10 text-primary mb-3" />
    <h3 className="text-lg font-semibold mb-1">{title}</h3>
    <p className="text-sm text-muted-foreground">{description}</p>
  </button>
);


export function VariableDiscoveryBuilder({
  open,
  onOpenChange,
  onCreate,
  projectId,
}: VariableDiscoveryBuilderProps) {
  const [currentStep, setCurrentStep] = useState<'choose_type' | 'explore_data' | 'manual_config'>(
    'choose_type'
  );
  const [searchTerm, setSearchTerm] = useState('');
  const [debouncedSearchTerm] = useDebounce(searchTerm, 300);

  // State for the variable being built (Configuration Panel)
  const [tempVariableName, setTempVariableName] = useState('');
  const [tempVariablePlaceholder, setTempVariablePlaceholder] = useState('');
  const [tempVariableDescription, setTempVariableDescription] = useState('');
  const [tempVariableType, setTempVariableType] = useState<PromptVariableType | null>(null);
  const [tempVariableDefaultValue, setTempVariableDefaultValue] = useState('');
  const [tempVariableSource, setTempVariableSource] = useState<PromptVariableSource | null>(null);

  // State for the Data Explorer
  const [selectedCategoryInExplorer, setSelectedCategoryInExplorer] = useState<string | null>(null); // e.g., 'project', 'tasks'
  const [selectedFieldInExplorer, setSelectedFieldInExplorer] = useState<string | null>(null); // e.g., 'name', 'titles_list'

  // NEW: Use the GraphQL resolver hook for live preview
  const [debouncedTempVariableSource] = useDebounce(tempVariableSource, 500);
  const { data: livePreviewValue, isLoading: isLoadingPreview, error: previewErrorObj } = useResolvePromptVariable(
    projectId,
    debouncedTempVariableSource,
    undefined // promptVariableId is not needed for builder preview
  );
  const previewError = previewErrorObj ? previewErrorObj.message : null;


  // --- Data for Suggestions & Explorer ---
  const dataCategories = useMemo(() => [
    { value: 'project', label: 'Project', icon: Briefcase },
    { value: 'tasks', label: 'Tasks', icon: ListChecks },
    { value: 'sprints', label: 'Sprints', icon: Calendar },
    { value: 'documents', label: 'Documents', icon: FileText },
    { value: 'members', label: 'Members', icon: Users },
    { value: 'workspace', label: 'Workspace', icon: Database },
    { value: 'user', label: 'Me (Current User)', icon: Users },
  ], []);

  const getFieldsForCategory = useCallback((category: string | null) => {
    if (!category) return [];
    switch (category) {
      case 'project': return [
        { value: 'name', label: 'Project Name', type: PromptVariableType.STRING, description: 'The name of the current project.', source: { type: 'PROJECT_FIELD', field: 'name' } },
        { value: 'description', label: 'Project Description', type: PromptVariableType.RICH_TEXT, description: 'The detailed description of the current project.', source: { type: 'PROJECT_FIELD', field: 'description' } },
        { value: 'status', label: 'Project Status', type: PromptVariableType.STRING, description: 'The current status of the project (e.g., ACTIVE, PLANNING).', source: { type: 'PROJECT_FIELD', field: 'status' } },
        { value: 'totalTaskCount', label: 'Total Tasks Count', type: PromptVariableType.NUMBER, description: 'The total number of tasks in the project.', source: { type: 'PROJECT_FIELD', field: 'totalTaskCount', aggregation: 'COUNT' } },
        { value: 'completedTaskCount', label: 'Completed Tasks Count', type: PromptVariableType.NUMBER, description: 'The number of tasks in the project that are marked as DONE.', source: { type: 'PROJECT_FIELD', field: 'completedTaskCount', aggregation: 'COUNT', filter: { status: 'DONE' } } },
      ];
      case 'tasks': return [
        { value: 'all_titles_list', label: 'All Tasks Titles List', type: PromptVariableType.LIST_OF_STRINGS, description: 'A bulleted list of all task titles in the project.', source: { type: 'TASKS_AGGREGATION', aggregation: 'LIST_TITLES', format: 'BULLET_POINTS' } },
        { value: 'my_tasks_titles_list', label: 'My Tasks Titles List', type: PromptVariableType.LIST_OF_STRINGS, description: 'A bulleted list of task titles assigned to the current user.', source: { type: 'TASKS_AGGREGATION', filter: { assigneeId: 'current_user' }, aggregation: 'LIST_TITLES', format: 'BULLET_POINTS' } },
        { value: 'completed_count', label: 'Completed Tasks Count', type: PromptVariableType.NUMBER, description: 'The total count of completed tasks in the project.', source: { type: 'TASKS_AGGREGATION', filter: { status: 'DONE' }, aggregation: 'COUNT' } },
        { value: 'task_title_by_id', label: 'Specific Task: Title (by ID)', type: PromptVariableType.STRING, description: 'The title of a specific task (requires a task ID to be provided in the filter).', source: { type: 'SINGLE_TASK_FIELD', field: 'title', entityId: 'prompt_for_task_id' } }, // 'prompt_for_task_id' means we'd prompt user for it
      ];
      case 'sprints': return [
        { value: 'current_name', label: 'Current Sprint Name', type: PromptVariableType.STRING, description: 'The name of the currently active sprint.', source: { type: 'SPRINT_FIELD', entityId: 'current_sprint', field: 'name' } },
        { value: 'current_endDate', label: 'Current Sprint End Date', type: PromptVariableType.DATE, description: 'The end date of the currently active sprint.', source: { type: 'SPRINT_FIELD', entityId: 'current_sprint', field: 'endDate' } },
        { value: 'upcoming_names_list', label: 'Upcoming Sprints Names List', type: PromptVariableType.LIST_OF_STRINGS, description: 'A bulleted list of names of all upcoming (planning) sprints.', source: { type: 'SPRINT_AGGREGATION', filter: { status: 'PLANNING' }, aggregation: 'LIST_NAMES', format: 'BULLET_POINTS' } },
      ];
      case 'documents': return [
        { value: 'latest_title', label: 'Latest Document Title', type: PromptVariableType.STRING, description: 'The title of the most recently updated document.', source: { type: 'DOCUMENT_FIELD', entityId: 'latest', field: 'title' } },
        { value: 'latest_content', label: 'Latest Document Content', type: PromptVariableType.RICH_TEXT, description: 'The full rich-text content of the most recently updated document.', source: { type: 'DOCUMENT_FIELD', entityId: 'latest', field: 'content' } },
        { value: 'all_titles_list', label: 'All Documents Titles List', type: PromptVariableType.LIST_OF_STRINGS, description: 'A bulleted list of titles of all documents in the project.', source: { type: 'DOCUMENT_AGGREGATION', aggregation: 'LIST_TITLES', format: 'BULLET_POINTS' } },
      ];
      case 'members': return [
        { value: 'all_names_list', label: 'All Project Members Names List', type: PromptVariableType.LIST_OF_STRINGS, description: 'A comma-separated list of names of all members in the project.', source: { type: 'MEMBER_LIST', aggregation: 'LIST_NAMES', format: 'COMMA_SEPARATED' } },
        { value: 'admin_names_list', label: 'Admin Members Names List', type: PromptVariableType.LIST_OF_STRINGS, description: 'A comma-separated list of names of project administrators.', source: { type: 'MEMBER_LIST', filter: { role: 'ADMIN' }, aggregation: 'LIST_NAMES', format: 'COMMA_SEPARATED' } },
      ];
      case 'workspace': return [
        { value: 'name', label: 'Workspace Name', type: PromptVariableType.STRING, description: 'The name of the workspace this project belongs to.', source: { type: 'WORKSPACE_FIELD', field: 'name' } },
        { value: 'industry', label: 'Workspace Industry', type: PromptVariableType.STRING, description: 'The industry defined for the workspace.', source: { type: 'WORKSPACE_FIELD', field: 'industry' } },
      ];
      case 'user': return [
        { value: 'firstName', label: 'My First Name', type: PromptVariableType.STRING, description: 'The first name of the current user.', source: { type: 'USER_FIELD', field: 'firstName' } },
        { value: 'email', label: 'My Email', type: PromptVariableType.STRING, description: 'The email address of the current user.', source: { type: 'USER_FIELD', field: 'email' } },
      ];
      case 'date_function': return [ // NEW: For date functions
        { value: 'today', label: 'Today\'s Date', type: PromptVariableType.DATE, description: 'The current date.', source: { type: 'DATE_FUNCTION', field: 'today' }, defaultValue: new Date().toISOString().split('T')[0] },
      ];
      default: return [];
    }
  }, []);

  const generalSuggestions = useMemo(() => [
    { name: 'Project Name', placeholder: generatePlaceholder('Project Name'), type: PromptVariableType.STRING, description: 'The name of the current project.', source: { type: 'PROJECT_FIELD', field: 'name' } },
    { name: 'My Email', placeholder: generatePlaceholder('My Email'), type: PromptVariableType.STRING, description: 'The email address of the current user.', source: { type: 'USER_FIELD', field: 'email' } },
    { name: 'Today\'s Date', placeholder: generatePlaceholder('Today\'s Date'), type: PromptVariableType.DATE, description: 'The current date.', source: { type: 'DATE_FUNCTION', field: 'today' }, defaultValue: new Date().toISOString().split('T')[0] },
    { name: 'Total Tasks Count', placeholder: generatePlaceholder('Total Tasks Count'), type: PromptVariableType.NUMBER, description: 'The total number of tasks in the project.', source: { type: 'PROJECT_FIELD', field: 'totalTaskCount', aggregation: 'COUNT' } },
    { name: 'All Task Titles List', placeholder: generatePlaceholder('All Task Titles List'), type: PromptVariableType.LIST_OF_STRINGS, description: 'A bulleted list of all task titles in the project.', source: { type: 'TASKS_AGGREGATION', aggregation: 'LIST_TITLES', format: 'BULLET_POINTS' } },
  ], []);

  // Filtered suggestions based on search term
  const filteredSuggestions = useMemo(() => {
    if (!debouncedSearchTerm) return generalSuggestions;
    const lowerSearch = debouncedSearchTerm.toLowerCase();

    // Combine all potential suggestions for searching
    const allSearchable = [
      ...generalSuggestions,
      ...dataCategories.flatMap(cat =>
        getFieldsForCategory(cat.value).map(field => ({
          name: `${cat.label}: ${field.label}`,
          placeholder: generatePlaceholder(`${cat.value}_${field.value}`), // Use field.value for placeholder generation for consistency
          type: field.type,
          description: field.description,
          source: field.source,
          defaultValue: field.defaultValue,
        }))
      ),
      // Manually add Date function as a suggestion if it's not in a category
      ...getFieldsForCategory('date_function').map(field => ({
          name: `Date: ${field.label}`,
          placeholder: generatePlaceholder(`Date_${field.label}`),
          type: field.type,
          description: field.description,
          source: field.source,
          defaultValue: field.defaultValue,
      })),
    ];

    // Ensure unique suggestions by placeholder (or a more robust key)
    const uniqueSuggestionsMap = new Map<string, typeof allSearchable[0]>();
    allSearchable.forEach(s => {
        // Use a more robust key: combine type, source.type, source.field, source.aggregation
        const sourceKey = s.source ? `${s.source.type}-${s.source.field || ''}-${s.source.aggregation || ''}` : 'manual';
        const key = `${s.type}-${sourceKey}`;
        if (!uniqueSuggestionsMap.has(key)) {
            uniqueSuggestionsMap.set(key, s);
        }
    });

    return Array.from(uniqueSuggestionsMap.values()).filter(s =>
      s.name.toLowerCase().includes(lowerSearch) ||
      s.placeholder.toLowerCase().includes(lowerSearch) ||
      s.description?.toLowerCase().includes(lowerSearch)
    );
  }, [debouncedSearchTerm, generalSuggestions, dataCategories, getFieldsForCategory]);


  // --- Reset state when dialog opens or closes ---
  useEffect(() => {
    if (!open) {
      // Reset all states when dialog closes
      setCurrentStep('choose_type');
      setSearchTerm('');
      setTempVariableName('');
      setTempVariablePlaceholder('');
      setTempVariableDescription('');
      setTempVariableType(null);
      setTempVariableDefaultValue('');
      setTempVariableSource(null);
      setSelectedCategoryInExplorer(null);
      setSelectedFieldInExplorer(null);
    } else {
      // If no project is selected, immediately jump to manual config
      if (!projectId) {
        setCurrentStep('manual_config');
        setTempVariableSource(null);
        setTempVariableType(PromptVariableType.STRING);
      } else {
        // Ensure starting on 'choose_type' if project is present
        setCurrentStep('choose_type');
      }
    }
  }, [open, projectId]);

  // --- Update tempVariablePlaceholder when tempVariableName changes (for manual) ---
  useEffect(() => {
    // Only update placeholder automatically if it's a manual variable and not explicitly set by source
    if (currentStep === 'manual_config' && tempVariableName && !tempVariableSource) {
      setTempVariablePlaceholder(generatePlaceholder(tempVariableName));
    }
  }, [tempVariableName, currentStep, tempVariableSource]);


  // --- Update temp variable state when explorer selections change ---
  useEffect(() => {
    if (currentStep === 'explore_data' && selectedCategoryInExplorer && selectedFieldInExplorer) {
      const categoryFields = getFieldsForCategory(selectedCategoryInExplorer);
      const matchedField = categoryFields.find(f => f.value === selectedFieldInExplorer);

      if (matchedField) {
        setTempVariableName(matchedField.label);
        setTempVariablePlaceholder(generatePlaceholder(`${selectedCategoryInExplorer}_${matchedField.value}`)); // Use matchedField.value
        setTempVariableType(matchedField.type);
        setTempVariableSource(matchedField.source || null); // Ensure source is correctly set
        setTempVariableDescription(matchedField.description || '');
        setTempVariableDefaultValue(matchedField.defaultValue || '');
      } else {
        // Fallback for custom fields or when direct match isn't found for source config
        setTempVariableName(`Custom ${selectedCategoryInExplorer} Field: ${selectedFieldInExplorer}`);
        setTempVariablePlaceholder(generatePlaceholder(`${selectedCategoryInExplorer}_${selectedFieldInExplorer}`));
        setTempVariableType(PromptVariableType.STRING);
        setTempVariableSource({ type: selectedCategoryInExplorer.toUpperCase() + '_FIELD', field: selectedFieldInExplorer });
        setTempVariableDescription('');
        setTempVariableDefaultValue('');
      }
    } else if (currentStep === 'explore_data' && !selectedFieldInExplorer) {
      // If category is selected but no field, clear variable details (but keep category for display)
      setTempVariableName('');
      setTempVariablePlaceholder('');
      setTempVariableType(null);
      setTempVariableSource(null);
      setTempVariableDescription('');
      setTempVariableDefaultValue('');
    }
  }, [selectedCategoryInExplorer, selectedFieldInExplorer, getFieldsForCategory, currentStep]);


  const handleCreateVariable = () => {
    if (!tempVariableName || !tempVariablePlaceholder || !tempVariableType) {
      toast.error('Validation Error', {
        description: 'Variable Name, Placeholder, and Type are required.',
      });
      return;
    }

    onCreate({
      name: tempVariableName,
      placeholder: tempVariablePlaceholder,
      defaultValue: tempVariableDefaultValue,
      description: tempVariableDescription,
      type: tempVariableType,
      source: tempVariableSource,
    });
    onOpenChange(false);
  };

  const isFormValid = useMemo(() => {
    return !!tempVariableName && !!tempVariablePlaceholder && !!tempVariableType;
  }, [tempVariableName, tempVariablePlaceholder, tempVariableType]);


  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-4xl h-[90vh] flex flex-col bg-white">
        <DialogHeader className="p-0 border-b">
          <DialogTitle className="text-2xl">Variable Discovery & Builder</DialogTitle>
        </DialogHeader>

        <div className="flex-1 overflow-hidden p-2 grid grid-cols-2 gap-6">
          {/* Left Column: Discovery & Selection */}
          <div className="flex flex-col space-y-4 border-r pr-6 overflow-y-auto">
            {!projectId && currentStep !== 'manual_config' ? (
              <div className="text-center py-12 text-gray-500">
                <p className="text-lg font-semibold mb-2">No Project Selected</p>
                <p className="mb-4">Dynamic Project Data Variables require an active project context.</p>
                <Button onClick={() => { setCurrentStep('manual_config'); setTempVariableSource(null); setTempVariableType(PromptVariableType.STRING); }}>Create Manual Variable Instead</Button>
              </div>
            ) : (
              <>
                {currentStep === 'choose_type' && (
                  <div className="space-y-4">
                    <h3 className="text-lg font-semibold text-gray-800 mb-1">What kind of variable do you want?</h3>
                    <div className="grid grid-cols-1 gap-4">
                      <SelectionCard
                        icon={Database}
                        title="Dynamic Project Data"
                        description="Automatically pull live data from your projects, tasks, sprints, and more."
                        onClick={() => setCurrentStep('explore_data')}
                        disabled={!projectId}
                      />
                      <SelectionCard
                        icon={Keyboard}
                        title="Manual Input Variable"
                        description="Define a variable whose value you will manually enter or update."
                        onClick={() => { setCurrentStep('manual_config'); setTempVariableSource(null); setTempVariableType(PromptVariableType.STRING); }}
                      />
                    </div>
                  </div>
                )}

                {currentStep === 'explore_data' && (
                  <div className="flex flex-col h-full">
                    <Button variant="ghost" onClick={() => {
                      setCurrentStep('choose_type');
                      setSelectedCategoryInExplorer(null);
                      setSelectedFieldInExplorer(null);
                      setSearchTerm('');
                      setTempVariableSource(null); // Clear source too
                    }} className="self-start -ml-2 mb-4">
                      <ArrowLeft className="h-4 w-4 mr-2" /> Back to Types
                    </Button>
                    <h3 className="text-lg font-semibold text-gray-800 mb-4">Select Data from Your Project</h3>
                    <Input
                      placeholder="Search project data, e.g., 'task title', 'project manager', 'latest doc'..."
                      value={searchTerm}
                      onChange={(e) => setSearchTerm(e.target.value)}
                      className="mb-4"
                    />
                    <Command className="rounded-lg border shadow-sm flex-1">
                      <CommandList className="flex-1 overflow-y-auto">
                        <CommandEmpty>No results found for "{searchTerm}".</CommandEmpty>
                        {/* Suggestions Group */}
                        {filteredSuggestions.length > 0 && searchTerm !== '' && (
                          <CommandGroup heading="Search Results">
                            {filteredSuggestions.map((s, i) => (
                              <CommandItem
                                key={`search-sugg-${s.placeholder + i}`}
                                onSelect={() => {
                                  setTempVariableName(s.name);
                                  setTempVariablePlaceholder(s.placeholder);
                                  setTempVariableType(s.type);
                                  setTempVariableSource(s.source || null);
                                  setTempVariableDescription(s.description || '');
                                  setTempVariableDefaultValue(s.defaultValue || '');
                                  const categoryValue = s.source?.type?.toLowerCase().replace('_field', '').replace('_aggregation', '').replace('_list', '').replace('_function', '') || null;
                                  setSelectedCategoryInExplorer(categoryValue);
                                  setSelectedFieldInExplorer(s.source?.field || null);
                                  setSearchTerm('');
                                }}
                                className="cursor-pointer flex justify-between items-center"
                              >
                                <div>
                                  <div className="font-medium">{s.name}</div>
                                  <div className="text-xs text-muted-foreground">{s.description}</div>
                                </div>
                                <Badge variant="secondary" className="ml-2">Data</Badge>
                              </CommandItem>
                            ))}
                          </CommandGroup>
                        )}

                        {/* Browse by Category & Fields (only if no search term) */}
                        {searchTerm === '' && (
                          <>
                            <CommandGroup heading="Browse by Category">
                              {dataCategories.map((cat) => {
                                const Icon = cat.icon;
                                return (
                                  <CommandItem
                                    key={cat.value}
                                    onSelect={() => {
                                      setSelectedCategoryInExplorer(cat.value);
                                      setSelectedFieldInExplorer(null);
                                    }}
                                    className={cn(
                                      "cursor-pointer flex items-center",
                                      selectedCategoryInExplorer === cat.value && "bg-accent text-accent-foreground"
                                    )}
                                  >
                                    <Icon className="mr-2 h-4 w-4" />
                                    {cat.label}
                                  </CommandItem>
                                );
                              })}
                                {/* Add Date Functions as a separate item if needed */}
                                <CommandItem
                                    key="date_function"
                                    onSelect={() => {
                                      setSelectedCategoryInExplorer('date_function');
                                      setSelectedFieldInExplorer(null);
                                    }}
                                    className={cn(
                                      "cursor-pointer flex items-center",
                                      selectedCategoryInExplorer === 'date_function' && "bg-accent text-accent-foreground"
                                    )}
                                  >
                                    <Calendar className="mr-2 h-4 w-4" />
                                    Date Functions
                                </CommandItem>
                            </CommandGroup>

                            {selectedCategoryInExplorer && (
                              <CommandGroup heading={`${dataCategories.find(c => c.value === selectedCategoryInExplorer)?.label || 'Selected'} Fields`}>
                                {getFieldsForCategory(selectedCategoryInExplorer).map((fieldOption) => (
                                  <CommandItem
                                    key={fieldOption.value}
                                    onSelect={() => {
                                      setSelectedFieldInExplorer(fieldOption.value);
                                    }}
                                    className={cn(
                                      "cursor-pointer",
                                      selectedFieldInExplorer === fieldOption.value && "bg-accent text-accent-foreground"
                                    )}
                                  >
                                    <Check className={cn("mr-2 h-4 w-4", selectedFieldInExplorer === fieldOption.value ? "opacity-100" : "opacity-0")} />
                                    {fieldOption.label}
                                    <span className="text-xs text-muted-foreground ml-auto">{fieldOption.type.replace(/_/g, ' ')}</span>
                                  </CommandItem>
                                ))}
                              </CommandGroup>
                            )}
                          </>
                        )}
                      </CommandList>
                    </Command>
                  </div>
                )}

                {currentStep === 'manual_config' && (
                  <div className="space-y-4">
                    <Button variant="ghost" onClick={() => setCurrentStep('choose_type')} className="self-start -ml-2 mb-4">
                      <ArrowLeft className="h-4 w-4 mr-2" /> Back to Types
                    </Button>
                    <h3 className="text-lg font-semibold text-gray-800 mb-4">Configure Manual Variable</h3>
                    <p className="text-sm text-muted-foreground mb-4">This variable's value will be set manually, or you can provide a default value.</p>
                  </div>
                )}
              </>
            )}
          </div>

          {/* Right Column: Configuration & Preview */}
          <div className="flex flex-col space-y-4 overflow-y-auto">
            <h3 className="text-xl font-semibold mb-2">Configure Your Variable</h3>
            <p className="text-sm text-muted-foreground">Finalize the details of your selected variable.</p>

            <div className="grid gap-4 flex-1 pr-2">
              <div className="grid gap-2">
                <label className="block text-sm font-medium">Variable Name <span className="text-red-500">*</span></label>
                <Input
                  value={tempVariableName}
                  onChange={(e) => setTempVariableName(e.target.value)}
                  placeholder="A descriptive name for your variable"
                  disabled={!!tempVariableSource && currentStep === 'explore_data'}
                />
                {tempVariableSource && currentStep === 'explore_data' && (
                  <p className="text-xs text-muted-foreground mt-1">Name is auto-generated for project data. Go back to change data selection.</p>
                )}
              </div>

              <div className="grid gap-2">
                <label className="block text-sm font-medium">Placeholder <span className="text-red-500">*</span></label>
                <Input
                  value={tempVariablePlaceholder}
                  readOnly={!!tempVariableSource || currentStep !== 'manual_config'}
                  className="font-mono text-sm"
                  placeholder="e.g., {{project_name}}"
                  onChange={(e) => {
                    if (currentStep === 'manual_config') {
                      setTempVariablePlaceholder(e.target.value);
                    }
                  }}
                />
                 {tempVariableSource && (
                  <p className="text-xs text-muted-foreground mt-1">Placeholder is generated automatically from data source.</p>
                )}
                 {currentStep === 'manual_config' && (
                  <p className="text-xs text-muted-foreground mt-1">Placeholder is generated from name, but can be customized. (e.g. {'{{' + generatePlaceholder(tempVariableName).slice(2, -2) + '}}'})</p>
                )}
              </div>

              <div className="grid gap-2">
                <label className="block text-sm font-medium">Type <span className="text-red-500">*</span></label>
                <Select value={tempVariableType || ''} onValueChange={(val) => setTempVariableType(val as PromptVariableType)} disabled={!!tempVariableSource}>
                  <SelectTrigger>
                    <SelectValue placeholder="Select variable type" />
                  </SelectTrigger>
                  <SelectContent>
                    {Object.values(PromptVariableType).map((t) => (
                      <SelectItem key={t} value={t}>{t.replace(/_/g, ' ')}</SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                 {tempVariableSource && (
                  <p className="text-xs text-muted-foreground mt-1">Type is inferred from data source.</p>
                )}
              </div>

              <div className="grid gap-2">
                <label className="block text-sm font-medium">Description</label>
                <Textarea
                  value={tempVariableDescription}
                  onChange={(e) => setTempVariableDescription(e.target.value)}
                  placeholder="Explain what this variable represents"
                  rows={3}
                />
              </div>

              <div className="grid gap-2">
                <label className="block text-sm font-medium">Default Value {tempVariableSource ? '(used if data is unavailable)' : ''}</label>
                <Input
                  value={tempVariableDefaultValue}
                  onChange={(e) => setTempVariableDefaultValue(e.target.value)}
                  placeholder="Optional default value"
                />
                 {tempVariableSource && (
                  <p className="text-xs text-muted-foreground mt-1">This value will be used if project data is unavailable, or for live preview purposes if data not mocked.</p>
                )}
              </div>

              {/* Live Preview Section */}
              <div className="mt-4 p-3 border rounded-md bg-gray-50 dark:bg-gray-800">
                <h4 className="font-semibold text-sm mb-2">Live Preview {tempVariableSource ? '(Project Data)' : ''}</h4>
                {isLoadingPreview ? (
                  <p className="text-sm text-gray-500 flex items-center"><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Fetching live data...</p>
                ) : previewError ? (
                  <p className="text-sm text-red-500">{previewError}</p>
                ) : (
                  <pre className="text-sm font-mono whitespace-pre-wrap max-h-[100px] overflow-y-auto bg-white dark:bg-gray-900 p-2 rounded border border-gray-200 dark:border-gray-700">
                    {livePreviewValue}
                  </pre>
                )}
                {tempVariableSource && !projectId && (
                  <p className="text-red-500 text-xs mt-2">Cannot show live preview without a project ID. Select a project context.</p>
                )}
                {!tempVariableSource && (
                  <p className="text-sm text-muted-foreground mt-2">No dynamic data source selected. Preview not applicable for manual variables (value comes from default/user input).</p>
                )}
              </div>
            </div>
          </div>
        </div>

        <DialogFooter className="p-2 border-t">
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button onClick={handleCreateVariable} disabled={!isFormValid}>
            Add Variable to Prompt
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

---

### 11. `components/prompt-lab/prompt-card.tsx` (Updated for `Prompt` type)

```typescript
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Prompt } from './store'; // Import the Prompt type

interface PromptCardProps {
  prompt: Prompt; // Use the imported Prompt type
  onClick: () => void;
}

const PromptCard: React.FC<PromptCardProps> = ({ prompt, onClick }) => {
  return (
    <Card onClick={onClick} className="cursor-pointer hover:shadow-lg transition-shadow duration-200">
      <CardHeader>
        <CardTitle>{prompt.title}</CardTitle>
      </CardHeader>
      <CardContent>
        {prompt.description && <p className="text-sm text-muted-foreground line-clamp-2 mb-3">{prompt.description}</p>}
        <div className="flex space-x-2">
          {prompt.tags && prompt.tags.map((tag) => (
            <Badge key={tag} variant="secondary">{tag}</Badge>
          ))}
        </div>
        <p className="text-xs text-gray-500 mt-4">Last updated: {new Date(prompt.updatedAt).toLocaleDateString()}</p>
      </CardContent>
    </Card>
  );
};

export default PromptCard;
```

---

**Summary of Changes:**

1.  **`schema.graphql`**: Added `PromptVariableType` enum, `PromptVariable` and `Version` types, updated `Prompt` type to include `variables` and `versions` fields. Added `Create/UpdatePromptVariableInput`, `CreatePromptInput`, `UpdatePromptInput`, `CreateVersionInput`, `SnapshotPromptInput`, `RestorePromptVersionInput`. Added `getProjectPrompts`, `getPromptDetails`, `resolvePromptVariable` to `Query` and `createPrompt`, `updatePrompt`, `deletePrompt`, `snapshotPrompt`, `restorePromptVersion` to `Mutation`.
2.  **`lib/graphql/queries.ts`**: New file with GQL queries for `getProjectPrompts`, `getPromptDetails`, `resolvePromptVariable`.
3.  **`lib/graphql/mutations.ts`**: New file with GQL mutations for `createPrompt`, `updatePrompt`, `deletePrompt`, `snapshotPrompt`, `restorePromptVersion`.
4.  **`hooks/use-prompt-api.ts`**: New file with React Query hooks (`useProjectPrompts`, `usePromptDetails`, `useResolvePromptVariable`, `useCreatePrompt`, `useUpdatePrompt`, `useDeletePrompt`, `useSnapshotPrompt`, `useRestorePromptVersion`) to interact with your GraphQL API. Includes a mock `useGraphQLClient`.
5.  **`components/prompt-lab/store.ts`**: The Zustand store is now refactored to use the new React Query API hooks for data fetching and mutations. It primarily exposes the `prompts` list and delegates actions to the API hooks.
6.  **`components/prompt-lab/prompt-lab-container.tsx`**: Now uses `usePromptDetails` to fetch the selected prompt's data and passes it directly to `PromptLab`. Handles loading/error states.
7.  **`components/prompt-lab/prompt-lab.tsx`**:
    *   Now receives the `prompt` object as a prop instead of managing it internally via Zustand.
    *   Uses `useUpdatePrompt`, `useSnapshotPrompt`, `useRestorePromptVersion` for mutations directly.
    *   `VariableItem` now includes an `onRemove` prop.
    *   `EditorPanel` now receives `prompt`, `onUpdate`, `onSnapshot`, `pendingNotes`, `setPendingNotes` as props.
    *   `VersionsPanel` updated to use `onSelectVersion` and `onRestoreVersion` props.
    *   Added `cuid()` helper for client-side ID generation for embedded items.
    *   `parseContentToBlocks` and `serializeBlocks` improved for robustness.
    *   `renderPrompt` improved to show dynamic variable placeholders.
8.  **`components/prompt-lab/prompt-list.tsx`**: Now uses `useProjectPrompts` to fetch the list of prompts.
9.  **`components/prompt-lab/prompt-versions.tsx`**: This file is removed as its functionality has been absorbed into the `VersionsPanel` within `prompt-lab.tsx`.
10. **`components/prompt-lab/variable-discovery-builder.tsx`**: Now uses `useResolvePromptVariable` to provide live previews for dynamic variables. Added `date_function` category for `Today's Date` variable.

Now, you have the full client-side setup for the prompt feature, ready for you to implement the backend resolvers.

























```
**Important:**
*   You need to update all imports in the Prompt Lab components that previously referenced `./store` for types (e.g., `Prompt`, `PromptVariable`, `Version`, `PromptVariableType`, `PromptVariableSource`) to now point to `../prompt-lab/types` or wherever you choose to place this new types file. For example:
    *   `import { Prompt, PromptVariable, Version, PromptVariableType, PromptVariableSource } from '@/components/prompt-lab/store';` becomes
    *   `import { Prompt, PromptVariable, Version, PromptVariableType, PromptVariableSource } from './types';` (if `types.ts` is in the same directory) or
    *   `import { Prompt, PromptVariable, Version, PromptVariableType, PromptVariableSource } from '../prompt-lab/types';` (if `types.ts` is in `components/prompt-lab`).

This setup directly reflects your `useProjectDocuments` example, centralizing prompt state and API interactions within `usePromptLab` and using Apollo Client directly.
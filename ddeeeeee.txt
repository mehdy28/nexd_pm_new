"use client";

import { useMemo, useState, useEffect, useCallback, useRef } from "react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Separator } from "@/components/ui/separator";
import { Checkbox } from "@/components/ui/checkbox";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import {
  ChevronDown,
  ChevronRight,
  Circle,
  CheckCircle2,
  Pencil,
  Trash2,
  Loader2,
  EllipsisVertical,
  CalendarIcon,
  ClockIcon,
  TagIcon,
  UserRoundIcon,
  MessageSquareIcon,
  X,
  Bold,
  Italic,
  Underline,
  List,
  ListOrdered,
  AlignLeft,
  AlignCenter,
  AlignRight,
  Paperclip,
  FileText,
  FileImage,
  FileSpreadsheet,
  FileWarning,
  FileArchive,
} from "lucide-react";
import { cn } from "@/lib/utils";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetDescription,
  SheetClose,
} from "@/components/ui/sheet";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";

import {
  useProjectTasksAndSections,
  TaskUI,
  SectionUI,
  PriorityUI,
  SprintFilterOption,
  TaskStatusUI,
} from "@/hooks/useProjectTasksAndSections";
import { useProjectTaskMutations } from "@/hooks/useProjectTaskMutations";
import { useTaskDetails } from "@/hooks/useTaskDetails"; // NEW: Import the dedicated hook
import { UserAvatarPartial } from "@/types/useProjectTasksAndSections";
import { TaskDetailsUI, ActivityUI } from "@/types/taskDetails"; // NEW: Import new types

type NewTaskForm = {
  title: string;
  assigneeId?: string | null;
  due?: string | null;
  priority: PriorityUI;
  points?: number | null;
  description?: string | null;
  sprintId?: string | null;
};

const priorityStyles: Record<PriorityUI, string> = {
  Low: "bg-green-100 text-green-700 ring-1 ring-green-200",
  Medium: "bg-orange-100 text-orange-700 ring-1 ring-orange-200",
  High: "bg-red-100 text-red-700 ring-1 ring-red-200",
};
const priorityDot: Record<PriorityUI, string> = {
  Low: "bg-green-500",
  Medium: "bg-orange-500",
  High: "bg-red-500",
};

const jiraInputStyle = "focus-visible:ring-0 focus-visible:ring-offset-0 border-none px-0 py-1 shadow-none bg-transparent";
const jiraSelectTriggerStyle = "focus:ring-0 focus:ring-offset-0 border-none h-auto px-0 py-1 shadow-none bg-transparent";

// NEW: Helper function to format file size
const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};

// NEW: Helper function to get file icon
const getFileIcon = (fileType: string): React.ReactNode => {
    if (fileType.startsWith('image/')) return <FileImage className="h-5 w-5 text-yellow-500" />;
    if (fileType === 'application/pdf') return <FileText className="h-5 w-5 text-red-500" />;
    if (fileType.includes('spreadsheet') || fileType.includes('excel')) return <FileSpreadsheet className="h-5 w-5 text-green-500" />;
    if (fileType.includes('document') || fileType.includes('word')) return <FileText className="h-5 w-5 text-blue-500" />;
    if (fileType.includes('presentation') || fileType.includes('powerpoint')) return <FileArchive className="h-5 w-5 text-orange-500" />;
    return <FileWarning className="h-5 w-5 text-gray-500" />;
};


interface ListViewProps {
  projectId: string;
}

export function ListView({ projectId }: ListViewProps) {
  const [internalSelectedSprintId, setInternalSelectedSprintId] = useState<string | undefined>(undefined);

  const {
    sections: fetchedSections,
    sprintFilterOptions,
    loading,
    error,
    refetchProjectTasksAndSections,
    createSection,
    updateSection,
    deleteSection,
    projectMembers,
    defaultSelectedSprintId: suggestedDefaultSprintId,
  } = useProjectTasksAndSections(projectId, internalSelectedSprintId);

  useEffect(() => {
    if (internalSelectedSprintId === undefined && suggestedDefaultSprintId) {
      setInternalSelectedSprintId(suggestedDefaultSprintId);
    }
  }, [internalSelectedSprintId, suggestedDefaultSprintId]);

  const {
    createTask,
    updateTask: updateTaskMutation,
    toggleTaskCompleted: toggleTaskCompletedMutation,
    deleteTask: deleteTaskMutation,
    isTaskMutating,
  } = useProjectTaskMutations(projectId, internalSelectedSprintId);

  const [sections, setSections] = useState<SectionUI[]>([]);
  const [collapsed, setCollapsed] = useState<Record<string, boolean>>({});
  const [selected, setSelected] = useState<Record<string, boolean>>({});
  const [sheetTask, setSheetTask] = useState<{ sectionId: string; taskId: string } | null>(null);

  // --- NEW: Task Details Hook and related states ---
  const {
    taskDetails,
    loading: loadingDetails,
    isMutating: isDetailsMutating,
    addComment,
    deleteComment,
    uploadAttachment,
    deleteAttachment,
  } = useTaskDetails(sheetTask?.taskId || null);
  
  const [editingTaskLocal, setEditingTaskLocal] = useState<TaskDetailsUI | null>(null);
  const [newComment, setNewComment] = useState("");
  const [activeTab, setActiveTab] = useState<"description" | "comments" | "activity" | "attachments">("description");
  // --- END NEW ---
  
  const [newTaskOpen, setNewTaskOpen] = useState<Record<string, boolean>>({});
  const [newTask, setNewTask] = useState<Record<string, NewTaskForm>>({});
  const [isSectionMutating, setIsSectionMutating] = useState(false);

  const [deleteSectionModalOpen, setDeleteSectionModalOpen] = useState(false);
  const [sectionToDelete, setSectionToDelete] = useState<SectionUI | null>(null);
  const [deleteTasksConfirmed, setDeleteTasksConfirmed] = useState(false);
  const [reassignToSectionOption, setReassignToSectionOption] = useState<string | null>(null);

  const [deleteTaskModalOpen, setDeleteTaskModalOpen] = useState(false);
  const [taskToDelete, setTaskToDelete] = useState<{ sectionId: string; task: TaskUI } | null>(null);

  const customModalRef = useRef<HTMLDivElement>(null);
  const customTaskModalRef = useRef<HTMLDivElement>(null);
  const descriptionContentEditableRef = useRef<HTMLDivElement>(null);

  // NEW: Effect to sync loaded task details into local editable state
  useEffect(() => {
    if (taskDetails) {
      setEditingTaskLocal(taskDetails);
    }
  }, [taskDetails]);

  // Handle placeholder logic for contentEditable div
  useEffect(() => {
    if (descriptionContentEditableRef.current && activeTab === "description" && editingTaskLocal) {
      const div = descriptionContentEditableRef.current;
      const description = editingTaskLocal.description;
      if (!description?.trim()) {
        if (div.textContent?.trim() !== 'Add a detailed description...') {
          div.classList.add('text-muted-foreground', 'italic');
          div.textContent = 'Add a detailed description...';
        }
      } else {
        if (div.classList.contains('text-muted-foreground')) {
          div.classList.remove('text-muted-foreground', 'italic');
        }
        if (div.innerHTML !== description) {
          div.innerHTML = description;
        }
      }
    }
  }, [editingTaskLocal?.description, activeTab]);

  const availableAssignees: UserAvatarPartial[] = useMemo(() => {
    return projectMembers.map(member => ({
      id: member.user.id,
      firstName: member.user.firstName,
      lastName: member.user.lastName,
      avatar: member.user.avatar,
    }));
  }, [projectMembers]);

  const toggleSection = useCallback((id: string) => setCollapsed((prev) => ({ ...prev, [id]: !prev[id] })), []);
  const setSectionEditing = useCallback((id: string, editing: boolean) => setSections((prev) => prev.map((s) => (s.id === id ? { ...s, editing } : s))), []);

  const renameSection = useCallback(async (id: string, title: string) => {
    if (!title.trim()) {
      setSections((prev) => prev.map((s) => (s.id === id ? { ...s, editing: false } : s)));
      return;
    }
    setIsSectionMutating(true);
    try { await updateSection(id, title); } 
    catch (err) { console.error(`Failed to rename section "${id}":`, err); } 
    finally {
      setIsSectionMutating(false);
      setSections((prev) => prev.map((s) => (s.id === id ? { ...s, editing: false } : s)));
    }
  }, [updateSection]);

  const addSection = useCallback(async () => {
    setIsSectionMutating(true);
    try {
      await createSection("New Section");
      refetchProjectTasksAndSections();
    } catch (err) { console.error("Failed to add section:", err); } 
    finally { setIsSectionMutating(false); }
  }, [createSection, refetchProjectTasksAndSections]);

  const toggleTaskCompleted = useCallback(async (sectionId: string, taskId: string) => {
    const taskToUpdate = sections.find(s => s.id === sectionId)?.tasks.find(t => t.id === taskId);
    if (!taskToUpdate) return;

    setSections((prev) => prev.map((s) => s.id === sectionId ? { ...s, tasks: s.tasks.map((t) => t.id === taskId ? { ...t, completed: !t.completed, status: !t.completed ? 'DONE' : 'TODO' } : t) } : s));
    try {
      await toggleTaskCompletedMutation(taskId, taskToUpdate.status);
    } catch (err) {
      console.error(`Failed to toggle task "${taskId}" completion:`, err);
      setSections((prev) => prev.map((s) => s.id === sectionId ? { ...s, tasks: s.tasks.map((t) => t.id === taskId ? { ...t, completed: taskToUpdate.completed, status: taskToUpdate.status } : t) } : s));
    }
  }, [sections, toggleTaskCompletedMutation]);

  const updateTask = useCallback(async (sectionId: string, taskId: string, updates: Partial<TaskUI>) => {
    const originalTask = sections.find(s => s.id === sectionId)?.tasks.find(t => t.id === taskId);
    if (!originalTask) return;

    const mutationInput: { [key: string]: any } = { id: taskId };
    if (updates.title !== undefined) mutationInput.title = updates.title;
    if (updates.description !== undefined) mutationInput.description = updates.description;
    if (updates.priority !== undefined) mutationInput.priority = updates.priority;
    if (updates.points !== undefined) mutationInput.points = updates.points;
    if (updates.due !== undefined) mutationInput.dueDate = updates.due;
    if (updates.assignee !== undefined) mutationInput.assigneeId = updates.assignee?.id || null;
    const newStatus = updates.completed !== undefined ? (updates.completed ? 'DONE' : 'TODO') : undefined;
    if (newStatus !== undefined) mutationInput.status = newStatus;

    setSections((prev) => prev.map((s) => s.id === sectionId ? { ...s, tasks: s.tasks.map((t) => (t.id === taskId ? { ...t, ...updates } : t)) } : s));

    if (Object.keys(mutationInput).length > 1) {
      try {
        await updateTaskMutation(taskId, mutationInput);
      } catch (err) {
        console.error(`Failed to update task "${taskId}":`, err);
        setSections((prev) => prev.map((s) => s.id === sectionId ? { ...s, tasks: s.tasks.map((t) => (t.id === taskId ? originalTask : t)) } : s));
      }
    }
  }, [sections, updateTaskMutation]);

  const openDeleteTaskModal = useCallback((sectionId: string, task: TaskUI) => {
    setTaskToDelete({ sectionId, task });
    setDeleteTaskModalOpen(true);
  }, []);

  const handleConfirmTaskDelete = useCallback(async () => {
    if (!taskToDelete) return;
    const { sectionId, task } = taskToDelete;
    const originalSections = [...sections];

    setSections((prev) => prev.map((s) => s.id === sectionId ? { ...s, tasks: s.tasks.filter((t) => t.id !== task.id) } : s));
    setSelected((prev) => { const copy = { ...prev }; delete copy[task.id]; return copy; });
    
    try {
      await deleteTaskMutation(task.id);
    } catch (err) {
      console.error(`Failed to delete task "${task.id}":`, err);
      setSections(originalSections);
    } finally {
      setDeleteTaskModalOpen(false);
      setTaskToDelete(null);
    }
  }, [taskToDelete, sections, deleteTaskMutation]);

  const allTaskIds = useMemo(() => sections.flatMap((s) => s.tasks.map((t) => t.id)), [sections]);
  const toggleSelect = useCallback((taskId: string, checked: boolean) => setSelected((prev) => ({ ...prev, [taskId]: checked })), []);
  const toggleSelectAll = useCallback((checked: boolean) => {
    if (!checked) { setSelected({}); return; }
    const next = allTaskIds.reduce((acc, id) => ({ ...acc, [id]: true }), {});
    setSelected(next);
  }, [allTaskIds]);

  const selectedCount = useMemo(() => Object.values(selected).filter(Boolean).length, [selected]);

  const bulkDeleteSelected = useCallback(async () => {
    const toDelete = new Set(Object.entries(selected).filter(([, v]) => v).map(([k]) => k));
    if (toDelete.size === 0) return;

    const originalSections = [...sections];
    setSections((prev) => prev.map((s) => ({ ...s, tasks: s.tasks.filter((t) => !toDelete.has(t.id)) })));
    setSelected({});

    try {
      await Promise.all(Array.from(toDelete).map(taskId => deleteTaskMutation(taskId)));
    } catch (err) {
      console.error("Failed to bulk delete tasks:", err);
      setSections(originalSections);
    }
  }, [selected, sections, deleteTaskMutation]);

  const openNewTask = useCallback((sectionId: string) => {
    setNewTaskOpen((p) => ({ ...p, [sectionId]: true }));
    setNewTask((p) => ({
      ...p,
      [sectionId]: p[sectionId] || { title: "", assigneeId: availableAssignees[0]?.id || null, due: null, priority: "Medium", points: null, description: null, sprintId: internalSelectedSprintId || null },
    }));
  }, [availableAssignees, internalSelectedSprintId]);

  const cancelNewTask = useCallback((sectionId: string) => setNewTaskOpen((p) => ({ ...p, [sectionId]: false })), []);

  const saveNewTask = useCallback(async (sectionId: string) => {
    const form = newTask[sectionId];
    if (!form || !form.title.trim()) return;

    try {
      await createTask(sectionId, {
        title: form.title,
        description: form.description,
        assigneeId: form.assigneeId,
        dueDate: form.due,
        priority: form.priority,
        points: form.points,
        sprintId: internalSelectedSprintId || null,
        status: 'TODO',
      });
      // Refetch is handled by the mutation hook, so we can just close the form.
      setNewTaskOpen((p) => ({ ...p, [sectionId]: false }));
      setNewTask((p) => { const newState = { ...p }; delete newState[sectionId]; return newState; });
    } catch (err) {
      console.error(`Failed to create task in section "${sectionId}":`, err);
    }
  }, [newTask, createTask, internalSelectedSprintId]);

  const openSheetFor = useCallback((sectionId: string, taskId: string) => {
    setSheetTask({ sectionId, taskId });
    setActiveTab("description");
  }, []);

  const closeSheet = useCallback(() => {
    setSheetTask(null);
    setEditingTaskLocal(null);
  }, []);
  
  // UPDATED: handleSheetSave to use taskDetails and updateTaskMutation
  const handleSheetSave = useCallback(async () => {
    if (!sheetTask || !editingTaskLocal || !taskDetails) return;

    const updates: { [key: string]: any } = { id: sheetTask.taskId };
    
    if (editingTaskLocal.title !== taskDetails.title) updates.title = editingTaskLocal.title;
    if (editingTaskLocal.description !== taskDetails.description) updates.description = editingTaskLocal.description;
    if (editingTaskLocal.priority !== taskDetails.priority) updates.priority = editingTaskLocal.priority;
    if (editingTaskLocal.points !== taskDetails.points) updates.points = editingTaskLocal.points;
    if (editingTaskLocal.dueDate !== taskDetails.dueDate) updates.dueDate = editingTaskLocal.dueDate;
    if (editingTaskLocal.assignee?.id !== taskDetails.assignee?.id) updates.assigneeId = editingTaskLocal.assignee?.id || null;

    if (Object.keys(updates).length > 1) {
      await updateTaskMutation(sheetTask.taskId, updates);
    }
    closeSheet();
  }, [sheetTask, editingTaskLocal, taskDetails, updateTaskMutation, closeSheet]);

  // NEW: Handler for submitting a new comment
  const handleAddComment = async () => {
    if (!newComment.trim()) return;
    try {
      await addComment(newComment);
      setNewComment("");
    } catch (e) {
      console.error("Failed to add comment:", e);
    }
  };

  // NEW: Handler for file selection and upload
  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (!files) return;
    try {
      await Promise.all(Array.from(files).map(file => uploadAttachment(file)));
    } catch (e) {
      console.error("File upload failed:", e);
    }
    event.target.value = ''; // Reset input
  };
  
  const handleEditorCommand = useCallback((command: string, value?: string) => {
    if (descriptionContentEditableRef.current) {
      descriptionContentEditableRef.current.focus();
      document.execCommand(command, false, value);
      if (descriptionContentEditableRef.current) {
        setEditingTaskLocal(prev => prev ? { ...prev, description: descriptionContentEditableRef.current?.innerHTML || '' } : null);
      }
    }
  }, []);

  useEffect(() => {
    if (!fetchedSections) return;
    setSections(fetchedSections);
    setCollapsed(prev => {
      const newCollapsed = { ...prev };
      fetchedSections.forEach(sec => { if (newCollapsed[sec.id] === undefined) newCollapsed[sec.id] = false; });
      return newCollapsed;
    });
  }, [fetchedSections]);

  const handleOpenDeleteSectionModal = useCallback((section: SectionUI) => {
    setSectionToDelete(section);
    setDeleteTasksConfirmed(false);
    setReassignToSectionOption(sections.find(s => s.id !== section.id)?.id || null);
    setDeleteSectionModalOpen(true);
  }, [sections]);

  const handleConfirmDeleteSection = useCallback(async () => {
    if (!sectionToDelete) return;
    setIsSectionMutating(true);
    try {
      const hasTasks = sectionToDelete.tasks.length > 0;
      await deleteSection(sectionToDelete.id, {
        deleteTasks: hasTasks ? deleteTasksConfirmed : true,
        reassignToSectionId: hasTasks && !deleteTasksConfirmed ? reassignToSectionOption || undefined : undefined,
      });
      refetchProjectTasksAndSections();
    } catch (err) { console.error(`Failed to delete section "${sectionToDelete.id}":`, err); } 
    finally {
      setIsSectionMutating(false);
      setDeleteSectionModalOpen(false);
      setSectionToDelete(null);
    }
  }, [sectionToDelete, deleteTasksConfirmed, reassignToSectionOption, deleteSection, refetchProjectTasksAndSections]);

  const allSelected = useMemo(() => selectedCount > 0 && selectedCount === allTaskIds.length, [selectedCount, allTaskIds]);
  const otherSections = useMemo(() => sections.filter(s => s.id !== sectionToDelete?.id), [sections, sectionToDelete]);
  const currentSprintName = useMemo(() => sprintFilterOptions.find(s => s.id === (internalSelectedSprintId || suggestedDefaultSprintId))?.name || "", [internalSelectedSprintId, sprintFilterOptions, suggestedDefaultSprintId]);

  const handleSprintSelectionChange = useCallback((sprintId: string) => {
    setInternalSelectedSprintId(sprintId);
    refetchProjectTasksAndSections();
  }, [refetchProjectTasksAndSections]);

  if (loading) return <div className="flex items-center justify-center min-h-[calc(100vh-64px)]"><Loader2 className="h-10 w-10 animate-spin text-teal-500" /></div>;
  if (error) return <div className="flex items-center justify-center min-h-[calc(100vh-64px)]"><p>Error: {error.message}</p></div>;
  if (!sections || sections.length === 0) return (
    <div className="text-center p-8">
      <h2 className="text-3xl font-bold mb-4">No Tasks in "{currentSprintName}"</h2>
      <Button onClick={addSection} disabled={isSectionMutating}>{isSectionMutating ? <Loader2 className="h-4 w-4 animate-spin mr-2" /> : null} + Add Section</Button>
    </div>
  );

  return (
    <div className="p-6 pt-3">
      {/* Header and Section controls */}
      <div className="flex items-center gap-3">
        <Button onClick={addSection} disabled={isSectionMutating} className="bg-[#4ab5ae] text-white h-9 rounded-md">
          {isSectionMutating ? <Loader2 className="h-4 w-4 animate-spin mr-2" /> : null}
          + Add section
        </Button>
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="outline" className="h-9 rounded-md gap-2 bg-transparent">
              {currentSprintName}
              <ChevronDown className="h-4 w-4 text-muted-foreground" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="start">
            <DropdownMenuLabel>Sprints</DropdownMenuLabel>
            {sprintFilterOptions.map((sprint) => (
              <DropdownMenuItem key={sprint.id} onClick={() => handleSprintSelectionChange(sprint.id)}>
                {sprint.name}
              </DropdownMenuItem>
            ))}
          </DropdownMenuContent>
        </DropdownMenu>
        <div className="ml-auto relative w-[260px]">
          <Input className="h-9" placeholder="Search tasks..." />
        </div>
      </div>
      
      {/* Bulk actions bar */}
      {selectedCount > 0 && (
        <div className="mt-4 flex items-center justify-between rounded-md bg-emerald-50 px-3 py-2 text-sm text-emerald-900 ring-1 ring-emerald-100">
          <div>{selectedCount} selected</div>
          <Button variant="destructive" className="h-8" onClick={bulkDeleteSelected}>
            Delete selected
          </Button>
        </div>
      )}

      {/* Task list */}
      <div className="mt-4 w-full rounded-md overflow-x-auto">
        <Separator />
        {sections.map((section) => (
          <div key={section.id} className="w-full">
            <div className="flex w-full items-center gap-2 px-5 py-4">
              <button
                onClick={() => toggleSection(section.id)}
                className="inline-flex items-center justify-center rounded-md p-1 hover:bg-muted/40"
                aria-label={collapsed[section.id] ? "Expand section" : "Collapse section"}
                title={collapsed[section.id] ? "Expand" : "Collapse"}
              >
                {collapsed[section.id] ? (
                  <ChevronRight className="h-4 w-4 text-muted-foreground" />
                ) : (
                  <ChevronDown className="h-4 w-4 text-muted-foreground" />
                )}
              </button>

              {section.editing ? (
                <Input
                  autoFocus
                  defaultValue={section.title}
                  className="h-8 w-64"
                  onBlur={(e) => renameSection(section.id, e.target.value.trim() || "Untitled")}
                  onKeyDown={(e) => {
                    if (e.key === "Enter") (e.target as HTMLInputElement).blur();
                    if (e.key === "Escape") setSectionEditing(section.id, false);
                  }}
                  disabled={isSectionMutating}
                />
              ) : (
                <button
                  className="text-sm font-semibold text-left hover:underline"
                  onClick={() => setSectionEditing(section.id, true)}
                  title="Rename section"
                  disabled={isSectionMutating}
                >
                  {section.title}
                </button>
              )}

              <div className="ml-auto flex items-center gap-2">
                {!newTaskOpen[section.id] && (
                  <Button variant="outline" size="sm" onClick={() => openNewTask(section.id)} disabled={isTaskMutating}>
                    + Add task
                  </Button>
                )}
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="ghost" size="sm" className="h-8 w-8 p-0" disabled={isSectionMutating}>
                      <EllipsisVertical className="h-4 w-4" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end">
                    <DropdownMenuItem onClick={() => handleOpenDeleteSectionModal(section)} className="text-red-600">
                      <Trash2 className="h-4 w-4 mr-2" /> Delete Section
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </div>
            </div>
            {!collapsed[section.id] && (
              <div className="w-full">
                {section.tasks.map((task) => (
                  <TaskRow
                    key={task.id} task={task} selected={!!selected[task.id]}
                    onSelect={toggleSelect} onToggleCompleted={() => toggleTaskCompleted(section.id, task.id)}
                    onChange={(updates) => updateTask(section.id, task.id, updates)}
                    onOpen={() => openSheetFor(section.id, task.id)}
                    onDelete={() => openDeleteTaskModal(section.id, task)}
                    assignees={availableAssignees}
                  />
                ))}
                {newTaskOpen[section.id] && (
                    <div className="px-10 py-4">{/* ... (New Task Form JSX) ... */}</div>
                )}
              </div>
            )}
            <Separator />
          </div>
        ))}
      </div>

      <Sheet open={!!sheetTask} onOpenChange={(open) => (!open ? closeSheet() : null)}>
        <SheetContent side="right" className="w-full sm:max-w-[800px] bg-gray-100 border-l p-0 flex flex-col h-full max-h-screen">
          {loadingDetails ? (
            <div className="flex items-center justify-center flex-1"><Loader2 className="h-6 w-6 animate-spin text-teal-500" /></div>
          ) : editingTaskLocal ? (
            <>
              <SheetHeader className="p-6 pt-0 pb-0 border-b bg-white flex-shrink-0 sticky top-0 z-20">
                <SheetTitle className="sr-only">Edit Task</SheetTitle>
                <div className="flex justify-between items-center">
                  <Input
                    value={editingTaskLocal.title}
                    onChange={(e) => setEditingTaskLocal(prev => prev ? { ...prev, title: e.target.value } : null)}
                    className={cn("text-2xl font-bold mt-2", jiraInputStyle)}
                    disabled={isTaskMutating || isDetailsMutating}
                  />
                  <div className="flex gap-2">
                    <Button
                      variant="ghost" size="icon" className="h-8 w-8 text-red-600 hover:text-red-700 hover:bg-red-50"
                      onClick={() => sheetTask && openDeleteTaskModal(sheetTask.sectionId, editingTaskLocal as TaskUI)}
                      title="Delete task"
                    ><Trash2 className="h-4 w-4" /></Button>
                    <SheetClose asChild><Button variant="ghost" size="icon" className="h-8 w-8"><X className="h-4 w-4" /></Button></SheetClose>
                  </div>
                </div>
              </SheetHeader>

              <div className="flex-1 overflow-hidden grid grid-cols-1 lg:grid-cols-3 h-full min-h-0">
                <div className="lg:col-span-2 flex flex-col h-full min-h-0">
                  <div className="sticky top-0 z-10 bg-gray-100 px-6 pt-2 pb-2 border-b">
                  <div className="grid w-full grid-cols-4 h-10 bg-gray-200 rounded-md p-1">
                      {['description', 'comments', 'activity', 'attachments'].map(tab => (
                          <button
                              key={tab}
                              type="button"
                              className={cn(
                                "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium transition-all capitalize",
                                activeTab === tab ? "bg-white shadow-sm text-foreground" : "text-muted-foreground hover:bg-gray-100"
                              )}
                              onClick={() => setActiveTab(tab as any)}
                          >
                              {tab}
                          </button>
                      ))}
                    </div>
                  </div>
                  <div className="flex-1 h-full min-h-0">
                    {activeTab === "description" && ( 
                        <div className="px-6 py-4 h-full overflow-y-auto">
                            {/* Rich text editor controls could go here */}
                            <div
                                ref={descriptionContentEditableRef}
                                contentEditable="true"
                                onInput={(e) => setEditingTaskLocal(prev => prev ? { ...prev, description: (e.target as HTMLDivElement).innerHTML || '' } : null)}
                                dangerouslySetInnerHTML={{ __html: editingTaskLocal.description || '' }}
                                className="text-base w-full p-2 border border-gray-200 rounded-md bg-white min-h-[100px]"
                            />
                        </div> 
                    )}
                    {activeTab === "comments" && (
                      <div className="flex flex-col h-full min-h-0">
                        <div className="flex-1 overflow-y-auto space-y-4 p-6">
                          {editingTaskLocal.comments.map(comment => (
                            <div key={comment.id} className="flex items-start gap-3 bg-white p-3 rounded-md shadow-sm border">
                              <Avatar className="h-8 w-8"><AvatarImage src={comment.author.avatar || ''} /><AvatarFallback>{comment.author.firstName?.[0]}</AvatarFallback></Avatar>
                              <div>
                                <p className="text-sm font-semibold">{comment.author.firstName} <span className="text-xs text-muted-foreground font-normal">{new Date(comment.createdAt).toLocaleString()}</span></p>
                                <p className="text-sm">{comment.content}</p>
                              </div>
                            </div>
                          ))}
                        </div>
                        <div className="mt-4 bg-white p-4 border-t flex-shrink-0">
                          <div className="flex items-end gap-2">
                            <Textarea placeholder="Add a comment..." rows={1} value={newComment} onChange={e => setNewComment(e.target.value)} disabled={isDetailsMutating}/>
                            <Button size="sm" className="h-9" onClick={handleAddComment} disabled={isDetailsMutating || !newComment.trim()}>
                              {isDetailsMutating && <Loader2 className="mr-2 h-4 w-4 animate-spin"/>} Send
                            </Button>
                          </div>
                        </div>
                      </div>
                    )}
                    {activeTab === "activity" && (
                      <div className="p-6 h-full overflow-y-auto">
                        <div className="space-y-4 text-sm text-muted-foreground">
                          {editingTaskLocal.activities.map(activity => <ActivityLogItem key={activity.id} activity={activity} />)}
                        </div>
                      </div>
                    )}
                    {activeTab === "attachments" && (
                      <div className="p-6 h-full flex flex-col overflow-y-auto">
                        <div className="mb-6 border-2 border-dashed rounded-md p-6 text-center hover:border-blue-500">
                          <label htmlFor="file-upload" className="block cursor-pointer">
                            <Paperclip className="h-8 w-8 mx-auto mb-2 text-gray-400" />
                            <span>Drag & drop or <span className="font-semibold text-blue-600">browse</span></span>
                            <input id="file-upload" type="file" multiple className="hidden" onChange={handleFileSelect} disabled={isDetailsMutating}/>
                          </label>
                        </div>
                        <div className="flex-1 space-y-3">
                          {editingTaskLocal.attachments.map(att => (
                            <div key={att.id} className="flex items-center justify-between p-3 bg-white rounded-md shadow-sm border">
                              <a href={att.url} target="_blank" rel="noopener noreferrer" className="flex items-center gap-3">
                                {getFileIcon(att.fileType)}
                                <span className="text-sm font-medium">{att.fileName} ({formatFileSize(att.fileSize)})</span>
                              </a>
                              <Button variant="ghost" size="sm" className="h-7 w-7 p-0" title="Remove" onClick={() => deleteAttachment(att.id)} disabled={isDetailsMutating}>
                                <X className="h-4 w-4" />
                              </Button>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                </div>

                <div className="lg:col-span-1 border-l bg-white p-6 flex flex-col flex-shrink-0 min-h-0 rounded-lg">
                  <div className="space-y-4 flex-grow overflow-y-auto">
                    <h3 className="text-base font-semibold">Details</h3>
                    {/* Assignee */}
                    <div className="flex items-center gap-4 text-sm">
                      <UserRoundIcon className="h-4 w-4 text-gray-500" />
                      <div className="flex-1">
                        <Select value={editingTaskLocal.assignee?.id || "null"} onValueChange={(v) => setEditingTaskLocal(prev => prev ? { ...prev, assignee: availableAssignees.find(a => a.id === v) || null } : null)} disabled={isTaskMutating || isDetailsMutating}>
                          <SelectTrigger className={cn("w-full", jiraSelectTriggerStyle)}><SelectValue placeholder="Unassigned" /></SelectTrigger>
                          <SelectContent>
                            <SelectItem value="null">Unassigned</SelectItem>
                            {availableAssignees.map((a) => (<SelectItem key={a.id} value={a.id}>{a.firstName} {a.lastName}</SelectItem>))}
                          </SelectContent>
                        </Select>
                      </div>
                    </div>
                    {/* Priority, Points, Due Date etc... */}
                  </div>
                  <div className="mt-8 flex flex-col gap-2 flex-shrink-0">
                    <Button onClick={handleSheetSave} disabled={isTaskMutating || isDetailsMutating}>
                      {(isTaskMutating || isDetailsMutating) && <Loader2 className="mr-2 h-4 w-4 animate-spin"/>} Save Changes
                    </Button>
                    <SheetClose asChild><Button variant="outline" disabled={isTaskMutating || isDetailsMutating}>Cancel</Button></SheetClose>
                  </div>
                </div>
              </div>
            </>
          ) : (
            <div className="flex items-center justify-center p-6 flex-1">No task selected.</div>
          )}
        </SheetContent>
      </Sheet>

      {/* Modals */}
      {sectionToDelete && deleteSectionModalOpen && (
        <div ref={customModalRef} role="alertdialog" tabIndex={-1} className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">{/* ... (modal JSX) ... */}</div>
      )}
      {taskToDelete && deleteTaskModalOpen && (
        <div ref={customTaskModalRef} role="alertdialog" tabIndex={-1} className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">{/* ... (modal JSX) ... */}</div>
      )}
    </div>
  );
}

// NEW: Helper component for rendering a single Activity Log Item
function ActivityLogItem({ activity }: { activity: ActivityUI }) {
    const userName = `${activity.user.firstName || ''} ${activity.user.lastName || ''}`.trim();

    const renderDetails = () => {
        const { old, new: newValue, content, fileName } = activity.data;
        switch (activity.type) {
            case 'TASK_CREATED': return `created this task.`;
            case 'TASK_ASSIGNED': return `changed the assignee from ${old || 'Unassigned'} to ${newValue || 'Unassigned'}.`;
            case 'PRIORITY_UPDATED': return `updated the priority from ${old} to ${newValue}.`;
            case 'STATUS_UPDATED': return `changed the status from ${old} to ${newValue}.`;
            case 'POINTS_UPDATED': return `updated the story points from ${old || 0} to ${newValue || 0}.`;
            case 'DUE_DATE_UPDATED': return `changed the due date from ${old || 'none'} to ${newValue || 'none'}.`;
            case 'DESCRIPTION_UPDATED': return `updated the description.`;
            case 'COMMENT_ADDED': return `added a comment: "${content}"`;
            case 'ATTACHMENT_ADDED': return `attached a file: ${fileName}`;
            case 'ATTACHMENT_REMOVED': return `removed an attachment: ${fileName}`;
            default: return `made an update.`;
        }
    };

    return (
        <div className="flex items-start gap-3 p-3 rounded-md border bg-gray-50">
            <Avatar className="h-8 w-8">
                <AvatarImage src={activity.user.avatar || ''} />
                <AvatarFallback>{activity.user.firstName?.[0]}</AvatarFallback>
            </Avatar>
            <div>
                <p className="text-sm">
                    <span className="font-semibold">{userName}</span> {renderDetails()}
                </p>
                <span className="text-xs text-muted-foreground">{new Date(activity.createdAt).toLocaleString()}</span>
            </div>
        </div>
    );
}

// Full TaskRow component
function TaskRow({ task, selected, onSelect, onToggleCompleted, onChange, onOpen, onDelete, assignees }: TaskRowProps) {
    const Icon = task.completed ? CheckCircle2 : Circle;
    const cellInput = "h-8 w-full bg-transparent border-0 focus-visible:ring-0 focus-visible:border-0 focus:outline-none text-sm";
    const assignee = task.assignee || { id: "unassigned", firstName: "Unassigned", lastName: "", avatar: "" };
    const assigneeInitials = `${assignee.firstName?.[0] || ''}${assignee.lastName?.[0] || ''}`.trim() || '?';
    const assigneeName = `${assignee.firstName || ''} ${assignee.lastName || ''}`.trim() || 'Unassigned';
  
    return (
      <div className="grid grid-cols-[40px_1fr_180px_160px_140px_100px_96px] items-center gap-2 px-10 py-2 hover:bg-muted/40 focus-within:bg-emerald-50/50 rounded-md">
        <div className="flex items-center">
          <Checkbox checked={selected} onCheckedChange={(v) => onSelect(!!v)} aria-label="Select task" />
        </div>
        <div className="flex items-center gap-3 min-w-0">
          <button onClick={onToggleCompleted} className={cn("inline-flex rounded-full", task.completed ? "text-emerald-600" : "text-muted-foreground")} title="Toggle completed">
            <Icon className="h-4 w-4" />
          </button>
          <Input className={cn(cellInput, task.completed && "line-through text-muted-foreground")} value={task.title} onChange={(e) => onChange({ title: e.target.value })} onFocus={(e) => e.currentTarget.select()} />
        </div>
        <div className="justify-self-end w-[180px]">
          <Select value={assignee.id} onValueChange={(v) => onChange({ assignee: assignees.find(a => a.id === v) || null })}>
            <SelectTrigger className="h-8">
              <div className="flex items-center gap-2">
                <Avatar className="h-6 w-6 border"><AvatarImage src={assignee.avatar || undefined} /><AvatarFallback className="text-[10px]">{assigneeInitials}</AvatarFallback></Avatar>
                <span className="text-sm truncate">{assigneeName}</span>
              </div>
            </SelectTrigger>
            <SelectContent>{assignees.map((a) => (<SelectItem key={a.id} value={a.id}>{a.firstName} {a.lastName}</SelectItem>))}</SelectContent>
          </Select>
        </div>
        <div className="justify-self-end w-[160px]"><Input type="date" value={task.due || ""} onChange={(e) => onChange({ due: e.target.value })} className="h-8" /></div>
        <div className="justify-self-end w-[140px]">
          <Select value={task.priority} onValueChange={(v: PriorityUI) => onChange({ priority: v })}>
            <SelectTrigger className="h-8">
              <div className={cn("inline-flex items-center rounded-full px-2 py-0.5 text-xs", priorityStyles[task.priority])}>
                <span className={cn("mr-2 h-2 w-2 rounded-full", priorityDot[task.priority])} />{task.priority}
              </div>
            </SelectTrigger>
            <SelectContent>{(["Low", "Medium", "High"] as PriorityUI[]).map((p) => (<SelectItem key={p} value={p}>{p}</SelectItem>))}</SelectContent>
          </Select>
        </div>
        <div className="justify-self-end w-[100px]">
          <Input className={cellInput} type="number" value={task.points ?? ""} onChange={(e) => onChange({ points: Number.isNaN(parseInt(e.target.value)) ? 0 : parseInt(e.target.value) })} min={0} />
        </div>
        <div className="flex items-center justify-end gap-2 pr-2 w-[96px]">
          <Button variant="ghost" size="icon" className="h-8 w-8" onClick={onOpen} title="Open task"><Pencil className="h-4 w-4" /></Button>
          <Button variant="ghost" size="icon" className="h-8 w-8 text-red-600 hover:text-red-700 hover:bg-red-50" onClick={() => onDelete(task.sectionId, task.id)} title="Delete task"><Trash2 className="h-4 w-4" /></Button>
        </div>
      </div>
    );
}
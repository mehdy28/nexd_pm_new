Of course. Here are the updated files to use backend-driven search and pagination.

### `components/prompt-lab/prompt-lab-container.tsx`

```tsx
'use client'

import { useState, useCallback } from 'react';
import { useParams } from 'next/navigation';

import { PromptList } from "./prompt-list";
import { PromptLab } from "./prompt-lab";
import { Button } from "../ui/button";
import GlobalAppLoader from "@/components/global-app-loader";

import { usePromptsList } from "@/hooks/usePromptsList";
import { usePromptDetails } from "@/hooks/usePromptDetails";

export function PromptLabContainer({ projectId: initialProjectId }: { projectId?: string }) {
  console.log('[PromptLabContainer] [Trace: Render] Component rendering.');
  const params = useParams();
  const projectId = initialProjectId || (params.id as string | undefined);

  // 1. Manage the selection state centrally
  const [selectedPromptId, setSelectedPromptId] = useState<string | null>(null);

  // 2. Consume usePromptsList hook for list operations, now including search and pagination
  const {
    prompts,
    loadingList,
    listError,
    createPrompt: createPromptInList,
    deletePrompt: deletePromptFromList,
    triggerPromptsListFetch,
    q,
    setQ,
    page,
    setPage,
    pageSize,
    setPageSize,
    totalPages,
    totalPromptsCount,
  } = usePromptsList(projectId, selectedPromptId);

  // 3. Consume usePromptDetails hook for detail operations
  const {
    selectedPromptDetails,
    loadingDetails,
    detailsError,
    refetchPromptDetails,
  } = usePromptDetails(selectedPromptId, projectId);

  // 4. Centralized select/deselect logic
  const selectPrompt = useCallback((id: string | null) => {
    console.log('[PromptLabContainer] [Trace: Select] selectPrompt called with ID:', id);
    setSelectedPromptId(id);
    // When deselecting, ensure the list is refreshed or re-fetched if needed
    if (id === null) {
      triggerPromptsListFetch(true); // Force a network-only refetch of the list
    }
  }, [triggerPromptsListFetch]);

  // Handle create prompt action
  const handleCreateNewPrompt = useCallback(async () => {
    console.log('[PromptLabContainer] [Trace: HandleCreate] handleCreateNewPrompt: Initiating prompt creation.');
    try {
      const newPrompt = await createPromptInList(); // Use the create from the list hook
      if (newPrompt) {
        console.log('[PromptLabContainer] [Trace: HandleCreate] New prompt created:', newPrompt.id);
        selectPrompt(newPrompt.id); // Select the newly created prompt
      }
    } catch (err) {
      console.error("[PromptLabContainer] [Error: Create] Failed to create new prompt:", err);
    }
  }, [createPromptInList, selectPrompt]);

  // Handle delete prompt action
  const handleDeletePrompt = useCallback(async (id: string) => {
    console.log('[PromptLabContainer] [Trace: HandleDelete] handleDeletePrompt: Initiating deletion for ID:', id);
    await deletePromptFromList(id); // Use the delete from the list hook
    if (selectedPromptId === id) {
      console.log('[PromptLabContainer] [Trace: HandleDelete] Deselecting deleted prompt.');
      selectPrompt(null); // Deselect if the deleted prompt was selected
    }
  }, [deletePromptFromList, selectedPromptId, selectPrompt]);

  // Handle "Back to List" action
  const handleBack = () => {
    console.log('[PromptLabContainer] [Trace: HandleBack] handleBack: Deselecting prompt.');
    selectPrompt(null); // Deselect the prompt. This will trigger a list refetch via its useCallback.
  };

  // Determine overall loading and error states
  const isLoading = loadingList || loadingDetails;
  const error = listError || detailsError;

  // Determine message for global loader
  let loaderMessage = "Loading..."; // Default message
  if (selectedPromptId) {
    loaderMessage = "Loading prompt details...";
  } else {
    loaderMessage = "Loading prompt list...";
  }

  // --- Global Loader Conditional Rendering ---
  if (isLoading && prompts.length === 0 && !listError && !detailsError) { // Only show global loader if no prompts in list yet and no error
    console.log(`[PromptLabContainer] [Trace: Render] Rendering GLOBAL LOADER. Message: "${loaderMessage}".`);
    return <GlobalAppLoader message={loaderMessage} />;
  }

  // --- Error Handling (after global loading completes) ---
  if (error) {
    console.log('[PromptLabContainer] [Trace: Render] Rendering ERROR STATE. Error:', error);
    return (
      <div className="grid h-full place-items-center p-6 text-sm text-red-500">
        Error loading data: {error}
        <Button onClick={() => {
          console.log('[PromptLabContainer] [Trace: RetryButton] Retry button clicked.');
          if (selectedPromptId) {
            refetchPromptDetails(); // Retry details fetch if a prompt is selected
          } else {
            triggerPromptsListFetch(true); // Retry list fetch if no prompt is selected
          }
        }} className="mt-4">Retry</Button>
      </div>
    );
  }

  // --- Main UI Rendering (after global loading and error checks) ---
  if (selectedPromptId && selectedPromptDetails) {
    console.log(`[PromptLabContainer] [Trace: Render] Rendering PromptLab component with prompt ID: ${selectedPromptId}.`);
    return (
      <PromptLab
        prompt={selectedPromptDetails} // Pass the full details object
        onBack={handleBack}
        projectId={projectId}
      />
    );
  }

  // Default view: Prompt List (when no prompt is selected and not loading/error)
  console.log('[PromptLabContainer] [Trace: Render] Rendering PromptList component. Prompts count:', prompts.length);
  return (
    <PromptList
      prompts={prompts}
      onSelectPrompt={selectPrompt}
      onCreatePrompt={handleCreateNewPrompt}
      onDeletePrompt={handleDeletePrompt}
      isLoading={loadingList}
      isError={!!listError}
      // Search and Pagination Props
      q={q}
      setQ={setQ}
      page={page}
      setPage={setPage}
      pageSize={pageSize}
      setPageSize={setPageSize}
      totalPages={totalPages}
      totalPromptsCount={totalPromptsCount}
    />
  );
}
```

### `components/prompt-lab/PromptList.tsx`

```tsx
"use client"

import { useState } from "react"
import PromptCard from "./prompt-card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Plus, Loader2, ArrowLeft, ArrowRight } from "lucide-react"
import { Prompt } from "@/components/prompt-lab/store"
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog"

interface PromptListProps {
  prompts: Prompt[]
  onSelectPrompt: (id: string) => void
  onCreatePrompt: () => Promise<any>
  onDeletePrompt: (id: string) => void
  isLoading?: boolean
  isError?: boolean
  // Search and Pagination props
  q: string
  setQ: (q: string) => void
  page: number
  setPage: (page: number) => void
  pageSize: number
  setPageSize: (size: number) => void
  totalPages: number
  totalPromptsCount: number
}

export function PromptList({
  prompts,
  onSelectPrompt,
  onCreatePrompt,
  onDeletePrompt,
  isLoading,
  isError,
  q,
  setQ,
  page,
  setPage,
  pageSize,
  setPageSize,
  totalPages,
  totalPromptsCount,
}: PromptListProps) {
  const [promptToDelete, setPromptToDelete] = useState<Prompt | null>(null)

  const handleDeleteClick = (prompt: Prompt) => {
    setPromptToDelete(prompt)
  }

  const handleConfirmDelete = async () => {
    if (promptToDelete) {
      await onDeletePrompt(promptToDelete.id)
      setPromptToDelete(null)
    }
  }

  const startItem = totalPromptsCount > 0 ? (page - 1) * pageSize + 1 : 0;
  const endItem = Math.min(page * pageSize, totalPromptsCount);


  if (isError) {
    return (
      <div className="grid h-full place-items-center text-red-500">
        <p>Failed to load prompts.</p>
      </div>
    )
  }

  return (
    <>
      <div className="flex h-full flex-col p-4">
        <div className="saas-card flex flex-1 flex-col overflow-hidden p-4">
          {/* Controls */}
          <div className="mb-4 shrink-0 border-b pb-4">
            <div className="grid grid-cols-1 gap-3 md:grid-cols-[1fr_auto] md:items-center">
              <Input
                value={q}
                onChange={e => setQ(e.target.value)}
                className="h-9 sm:w-[280px]"
                placeholder="Search prompts..."
              />
              <div className="flex items-center justify-start gap-2 md:justify-end">
                <Button className="h-9 btn-primary" onClick={onCreatePrompt}>
                  <Plus className="mr-1 h-4 w-4" />
                  New Prompt
                </Button>
              </div>
            </div>
          </div>

          {/* Content */}
          <div className="relative flex-1 overflow-y-auto">
            {isLoading && (
              <div className="absolute inset-0 z-10 grid place-items-center bg-white/50 dark:bg-slate-900/50">
                <Loader2 className="h-8 w-8 animate-spin text-primary" />
              </div>
            )}
            {totalPromptsCount === 0 && !isLoading ? (
              <div className="flex h-full items-center justify-center rounded-md border border-dashed text-center text-sm text-slate-500">
                <div>
                  <p>No prompts found.</p>
                  <p className="mt-1">Click “New Prompt” to create one.</p>
                </div>
              </div>
            ) : (
              <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
                {prompts.map(prompt => (
                  <PromptCard
                    key={prompt.id}
                    prompt={prompt}
                    onClick={() => onSelectPrompt(prompt.id)}
                    onDelete={() => handleDeleteClick(prompt)}
                  />
                ))}
              </div>
            )}
          </div>

          {/* Footer: Pagination */}
          <div className="mt-4 shrink-0 border-t pt-4">
            <div className="flex flex-wrap items-center justify-between gap-3">
              <div className="text-sm text-slate-600">
                Showing {startItem}–{endItem} of {totalPromptsCount}
              </div>
              <div className="flex items-center gap-2">
                <span className="text-xs text-slate-500">Rows per page</span>
                <Select value={String(pageSize)} onValueChange={v => setPageSize(Number.parseInt(v))}>
                  <SelectTrigger className="h-8 w-[90px]">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="6">6</SelectItem>
                    <SelectItem value="9">9</SelectItem>
                    <SelectItem value="12">12</SelectItem>
                    <SelectItem value="24">24</SelectItem>
                  </SelectContent>
                </Select>
                <Button
                  variant="outline"
                  className="h-8 bg-transparent"
                  onClick={() => setPage(Math.max(1, page - 1))}
                  disabled={page <= 1}
                  title="Previous"
                >
                  <ArrowLeft className="h-4 w-4" />
                </Button>
                <div className="min-w-[80px] text-center text-sm">
                  Page {page} / {totalPages}
                </div>
                <Button
                  variant="outline"
                  className="h-8 bg-transparent"
                  onClick={() => setPage(Math.min(totalPages, page + 1))}
                  disabled={page >= totalPages}
                  title="Next"
                >
                  <ArrowRight className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Confirmation Modal */}
      <AlertDialog open={!!promptToDelete} onOpenChange={open => !open && setPromptToDelete(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This will permanently delete the prompt
              <span className="font-semibold"> "{promptToDelete?.title}"</span> and all its versions. This action cannot
              be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleConfirmDelete} className="bg-red-600 hover:bg-red-700">
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  )
}
```

### `hooks/usePromptsList.ts`

```ts
'use client';

import { useState, useEffect, useCallback, useMemo } from "react";
import { useLazyQuery, useMutation, useQuery } from "@apollo/client";
import { useDebounce } from "use-debounce";

import { GET_PROJECT_PROMPTS_QUERY } from "@/graphql/queries/promptRelatedQueries";
import {
  CREATE_PROMPT_MUTATION,
  DELETE_PROMPT_MUTATION,
} from "@/graphql/mutations/promptRelatedMutations";
import { Prompt, Block, PromptVariable } from '@/components/prompt-lab/store';

function cuid(prefix: string = ''): string {
  const chars = '01234789abcdefghijklmnopqrstuvwxyz';
  let result = prefix + 'c';
  for (let i = 0; i < 24; i++) {
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
}

interface UsePromptsListHook {
  prompts: Prompt[];
  loadingList: boolean;
  listError: string | null;
  createPrompt: () => Promise<Prompt | undefined>;
  deletePrompt: (id: string) => void;
  triggerPromptsListFetch: (forceRefetch?: boolean) => void;
  // Search and Pagination
  q: string;
  setQ: (q: string) => void;
  page: number;
  setPage: (page: number) => void;
  pageSize: number;
  setPageSize: (size: number) => void;
  totalPages: number;
  totalPromptsCount: number;
}

const ITEMS_PER_PAGE = 9;

export function usePromptsList(projectId: string | undefined, selectedId: string | null): UsePromptsListHook {
  const [prompts, setPrompts] = useState<Prompt[]>([]);
  const [localListError, setLocalListError] = useState<string | null>(null);

  // Search and Pagination State
  const [q, setQ] = useState('');
  const [debouncedQ] = useDebounce(q, 300); // Debounce search input
  const [page, setPage] = useState(1);
  const [pageSize, setPageSize] = useState(ITEMS_PER_PAGE);
  const [totalPromptsCount, setTotalPromptsCount] = useState(0);

  const {
    data: promptsListData,
    loading: apolloListLoading,
    error: apolloListError,
    refetch: apolloRefetchPromptsList,
  } = useQuery(GET_PROJECT_PROMPTS_QUERY, {
    variables: {
      projectId,
      skip: (page - 1) * pageSize,
      take: pageSize,
      q: debouncedQ,
    },
    skip: !projectId || selectedId !== null, // Skip query if no project or if a prompt is selected
    fetchPolicy: "network-only",
    onCompleted: (data) => {
      console.log('[usePromptsList] [Trace: QueryListComplete] GET_PROJECT_PROMPTS_QUERY onCompleted. Data length:', data?.getProjectPrompts.prompts.length, 'prompts. Total Count:', data?.getProjectPrompts.totalCount);
      setLocalListError(null);
      const mappedPrompts: Prompt[] = data.getProjectPrompts.prompts.map(
        (p: any) => ({
          id: p.id,
          title: p.title,
          description: p.description,
          tags: p.tags,
          isPublic: p.isPublic,
          createdAt: p.createdAt,
          updatedAt: p.updatedAt,
          model: p.model || 'gpt-4o',
          projectId: p.projectId,
          content: [],
          context: '',
          variables: [],
          versions: [],
        })
      );
      setPrompts(mappedPrompts); // Replace prompts with the current page's data
      setTotalPromptsCount(data.getProjectPrompts.totalCount);
      console.log('[usePromptsList] [Trace: SetPromptsList] Updating prompts state from list. New count:', mappedPrompts.length);
    },
    onError: (err) => {
      console.error("[usePromptsList] [Error: QueryList] Error fetching project prompts list:", err);
      setLocalListError("Failed to load prompts list.");
    },
  });

  // Handlers that reset page number when search or page size changes
  const handleSetQ = (newQ: string) => {
    setPage(1);
    setQ(newQ);
  };

  const handleSetPageSize = (newPageSize: number) => {
    setPage(1);
    setPageSize(newPageSize);
  };

  const triggerPromptsListFetch = useCallback((forceRefetch: boolean = false) => {
    if (projectId && forceRefetch) {
      console.log('[usePromptsList] [Trace: TriggerFetch] Explicitly triggering GET_PROJECT_PROMPTS_QUERY refetch.');
      setLocalListError(null);
      setPage(1); // Reset to page 1 on a manual full refresh
      apolloRefetchPromptsList();
    }
  }, [projectId, apolloRefetchPromptsList]);


  const totalPages = useMemo(() => {
    return Math.max(1, Math.ceil(totalPromptsCount / pageSize));
  }, [totalPromptsCount, pageSize]);


  const [createPromptMutation] = useMutation(CREATE_PROMPT_MUTATION, {
    onCompleted: (data) => {
      if (data?.createPrompt) {
        console.log('[usePromptsList] [Trace: MutationCreateComplete] CREATE_PROMPT_MUTATION onCompleted. New prompt ID:', data.createPrompt.id);
        // Do not select here, let container handle it.
        // Refetch the list to ensure pagination and sorting are correct.
        apolloRefetchPromptsList();
      }
    },
    onError: (err) => {
      console.error("[usePromptsList] [Error: MutationCreate] Mutation Error: Create Prompt", err);
      setLocalListError("Failed to create prompt.");
    },
  });

  const [deletePromptMutation] = useMutation(DELETE_PROMPT_MUTATION, {
    onCompleted: (data) => {
      if (data?.deletePrompt.id) {
        console.log('[usePromptsList] [Trace: MutationDeleteComplete] DELETE_PROMPT_MUTATION onCompleted. Deleted prompt ID:', data.deletePrompt.id);
        // If the deleted item was the last on the page, go back one page.
        if (prompts.length === 1 && page > 1) {
          setPage(p => p - 1);
        } else {
          apolloRefetchPromptsList();
        }
      }
    },
    onError: (err) => {
      console.error("[usePromptsList] [Error: MutationDelete] Mutation Error: Delete Prompt", err);
      setLocalListError("Failed to delete prompt.");
      apolloRefetchPromptsList();
    },
  });

  const createPrompt = useCallback(
    async (): Promise<Prompt | undefined> => {
      setLocalListError(null);
      console.log('[usePromptsList] [Trace: Create] createPrompt: Initiating creation for projectId:', projectId);
      try {
        const defaultPromptInput = {
          title: 'Untitled Prompt',
          content: [],
          context: '',
          description: '',
          category: '',
          tags: [],
          isPublic: false,
          model: 'gpt-4o',
          projectId: projectId,
          variables: [],
        };

        const { data } = await createPromptMutation({
          variables: { input: defaultPromptInput },
        });

        if (data?.createPrompt) {
          const newPrompt: Prompt = {
            id: data.createPrompt.id,
            title: data.createPrompt.title,
            content: (data.createPrompt.content && Array.isArray(data.createPrompt.content) ? data.createPrompt.content : []) as Block[],
            context: data.createPrompt.context,
            description: data.createPrompt.description,
            tags: data.createPrompt.tags,
            isPublic: data.createPrompt.isPublic,
            createdAt: data.createPrompt.createdAt,
            updatedAt: data.createPrompt.updatedAt,
            model: data.createPrompt.model,
            projectId: data.createPrompt.projectId,
            variables: data.createPrompt.variables.map((v: PromptVariable) => ({ ...v, id: v.id || cuid('db-var-') })),
            versions: data.createPrompt.versions.map((v: any) => ({
              ...v,
              id: v.id || cuid('db-ver-'),
              content: (v.content && Array.isArray(v.content) ? v.content : []) as Block[],
              context: v.context || '',
              variables: v.variables || [],
            })),
          };
          return newPrompt;
        }
      } catch (err: any) {
        console.error("[usePromptsList] [Error: CreateGraphQL] Error creating prompt via GraphQL:", err);
        setLocalListError("Failed to create prompt.");
      }
      return undefined;
    },
    [projectId, createPromptMutation]
  );

  const deletePrompt = useCallback(
    (id: string) => {
      setLocalListError(null);
      console.log('[usePromptsList] [Trace: Delete] deletePrompt: Initiating deletion for prompt ID:', id);
      deletePromptMutation({ variables: { id } }).catch((err) => {
        console.error("[usePromptsList] [Error: DeleteGraphQL] Error deleting prompt via GraphQL:", err);
        setLocalListError("Failed to delete prompt.");
        apolloRefetchPromptsList();
      });
    },
    [deletePromptMutation, apolloRefetchPromptsList]
  );

  return {
    prompts,
    loadingList: apolloListLoading,
    listError: localListError || apolloListError?.message || null,
    createPrompt,
    deletePrompt,
    triggerPromptsListFetch,
    q,
    setQ: handleSetQ,
    page,
    setPage,
    pageSize,
    setPageSize: handleSetPageSize,
    totalPages,
    totalPromptsCount,
  };
}
```

### `graphql/queries/promptRelatedQueries.ts`

```ts
import { gql } from 'graphql-tag';

// --- Prompt Queries ---

export const GET_PROJECT_PROMPTS_QUERY = gql`
  query GetProjectPrompts($projectId: ID, $skip: Int, $take: Int, $q: String) { # ADDED: $q
    getProjectPrompts(projectId: $projectId, skip: $skip, take: $take, q: $q) { # ADDED: q
      prompts {
        id
        title
        description
        tags
        updatedAt
        isPublic
        projectId
        model
      }
      totalCount
    }
  }
`;

export const GET_PROMPT_DETAILS_QUERY = gql`
  query GetPromptDetails($id: ID!) {
    getPromptDetails(id: $id) {
      id
      title
      description
      category
      tags
      isPublic
      createdAt
      updatedAt
      model
      projectId
      user {
        id
        firstName
        lastName
      }
      variables {
        id
        name
        placeholder
        description
        type
        defaultValue
        source
      }
      versions {
        id
        createdAt
        notes
        description
      }
    }
  }
`;

// NEW: Query to get specific version's content, context, and variables
export const GET_PROMPT_VERSION_CONTENT_QUERY = gql`
  query GetPromptVersionContent($promptId: ID!, $versionId: ID!) {
    getPromptVersionContent(promptId: $promptId, versionId: $versionId) {
      id # The version ID
      content {
        id
        type
        value
        varId
        placeholder
        name
      }
      context
      variables {
        id
        name
        placeholder
        description
        type
        defaultValue
        source
      }
    }
  }
`;

// --- Variable Resolver Query ---
export const RESOLVE_PROMPT_VARIABLE_QUERY = gql`
  query ResolvePromptVariable($projectId: ID, $variableSource: JSON!, $promptVariableId: ID) {
    resolvePromptVariable(
      projectId: $projectId
      variableSource: $variableSource
      promptVariableId: $promptVariableId
    )
  }
`;
```

### `graphql/resolvers/promptResolver.ts`

```ts
import { GraphQLResolveInfo } from 'graphql';
import { prisma } from "@/lib/prisma";
import { type Prompt, type PromptVariable, type Version, PromptVariableType, PromptVariableSource } from '@/components/prompt-lab/store';

interface GraphQLContext {
  prisma: typeof prisma;
  user?: { id: string; email: string; role: string };
}

function generateUniqueId(): string {
  return `svr_${Math.random().toString(36).slice(2)}${Date.now()}`;
}

function buildPrismaWhereClause(
  sourceFilter: PromptVariableSource['filter'] | undefined,
  projectId: string,
  currentUserId: string | undefined,
  entityType: PromptVariableSource['entityType']
): any {
  const where: any = {};

  if (entityType !== 'USER' && entityType !== 'DATE_FUNCTION') {
    where.projectId = projectId;
  } else if (entityType === 'USER') {
    where.id = currentUserId;
  }

  if (sourceFilter && sourceFilter.field && sourceFilter.operator) {
    let value = sourceFilter.value;

    if (sourceFilter.specialValue === 'CURRENT_USER_ID') {
      value = currentUserId;
    } else if (sourceFilter.specialValue === 'CURRENT_PROJECT_ID') {
      value = projectId;
    } else if (sourceFilter.specialValue === 'ACTIVE_SPRINT' && entityType === 'SPRINT') {
        where.status = 'ACTIVE';
        return where;
    }

    if (['status', 'priority', 'role'].includes(sourceFilter.field) && typeof value === 'string') {
        value = value.toUpperCase();
    }


    switch (sourceFilter.operator) {
      case 'EQ':
        if (value !== undefined) where[sourceFilter.field] = value;
        break;
      case 'NEQ':
        if (value !== undefined) where[sourceFilter.field] = { not: value };
        break;
      case 'GT':
        if (value !== undefined) where[sourceFilter.field] = { gt: value };
        break;
      case 'LT':
        if (value !== undefined) where[sourceFilter.field] = { lt: value };
        break;
      case 'GTE':
        if (value !== undefined) where[sourceFilter.field] = { gte: value };
        break;
      case 'LTE':
        if (value !== undefined) where[sourceFilter.field] = { lte: value };
        break;
      case 'CONTAINS':
        if (typeof value === 'string') where[sourceFilter.field] = { contains: value, mode: 'insensitive' };
        break;
      case 'STARTS_WITH':
        if (typeof value === 'string') where[sourceFilter.field] = { startsWith: value, mode: 'insensitive' };
        break;
      case 'ENDS_WITH':
        if (typeof value === 'string') where[sourceFilter.field] = { endsWith: value, mode: 'insensitive' };
        break;
      case 'IN_LIST':
        if (Array.isArray(value)) where[sourceFilter.field] = { in: value };
        break;
      default:
        break;
    }
  }

  return where;
}

function extractFieldValue(record: any, fieldPath: string): any {
  if (!record || !fieldPath) return undefined;
  return fieldPath.split('.').reduce((obj, key) => (obj && typeof obj === 'object' ? obj[key] : undefined), record);
}

async function applyAggregation(
  records: any[],
  source: PromptVariableSource,
  context: GraphQLContext
): Promise<string> {
  const { aggregation, aggregationField, format } = source;

  if (records.length === 0) return 'No data found';

  switch (aggregation) {
    case 'COUNT':
      return String(records.length);
    case 'SUM':
    case 'AVERAGE': {
      if (!aggregationField) return 'N/A (Aggregation field not specified)';
      const values = records.map(r => Number(extractFieldValue(r, aggregationField))).filter(v => !isNaN(v));
      if (values.length === 0) return 'N/A (No numeric data to aggregate)';
      const sum = values.reduce((acc, val) => acc + val, 0);
      return aggregation === 'SUM' ? String(sum) : String(sum / values.length);
    }
    case 'LIST_FIELD_VALUES': {
      if (!aggregationField) return 'N/A (Aggregation field not specified)';
      const values = records.map(r => extractFieldValue(r, aggregationField)).filter(Boolean);
      if (values.length === 0) return 'No data found';
      switch (format) {
        case 'BULLET_POINTS': return values.map(v => `• ${v}`).join('\n');
        case 'COMMA_SEPARATED': return values.join(', ');
        case 'PLAIN_TEXT': return values.join('\n');
        case 'JSON_ARRAY': return JSON.stringify(values);
        default: return values.join('\n');
      }
    }
    case 'LAST_UPDATED_FIELD_VALUE':
    case 'FIRST_CREATED_FIELD_VALUE': {
      if (!aggregationField) return 'N/A (Aggregation field not specified)';
      const record = aggregation === 'LAST_UPDATED_FIELD_VALUE' ? records[0] : records[records.length - 1];
      const value = extractFieldValue(record, aggregationField);
      return value !== undefined ? String(value) : 'N/A';
    }
    default:
      return 'N/A (Unsupported aggregation)';
  }
}

const promptResolvers = {
  Query: {
    getProjectPrompts: async (
      _parent: any,
      { projectId, skip = 0, take = 10, q }: { projectId?: string, skip?: number, take?: number, q?: string }, // ADDED: q
      context: GraphQLContext
    ): Promise<{ prompts: Prompt[], totalCount: number }> => {
      let finalWhereClause: any = {};
      if (projectId) {
        finalWhereClause = { projectId };
      } else {
        finalWhereClause = {
          AND: [
            { projectId: null },
            { userId: context.user?.id || '' }
          ]
        };
      }

      // ADDED: Handle search query 'q'
      if (q && q.trim() !== '') {
        finalWhereClause.title = {
          contains: q,
          mode: 'insensitive',
        };
      }

      const [prompts, totalCount] = await prisma.$transaction([
        prisma.prompt.findMany({
          where: finalWhereClause,
          orderBy: { updatedAt: 'desc' },
          skip,
          take,
          select: {
            id: true,
            title: true,
            description: true,
            tags: true,
            isPublic: true,
            createdAt: true,
            updatedAt: true,
            model: true,
            projectId: true,
          },
        }),
        prisma.prompt.count({ where: finalWhereClause }),
      ]);

      const mappedPrompts = prompts.map(p => ({
        ...p,
        content: [],
        context: '',
        variables: [],
        versions: [],
      })) as unknown as Prompt[];

      return { prompts: mappedPrompts, totalCount };
    },

    getPromptDetails: async (
      _parent: any,
      { id }: { id: string },
      context: GraphQLContext
    ): Promise<Prompt> => {
      const prompt = await prisma.prompt.findUnique({
        where: { id },
        include: {
          user: {
            select: { id: true, firstName: true, lastName: true },
          },
          project: {
            select: { id: true, name: true, workspaceId: true },
          },
        },
      });
      if (prompt) {
        prompt.content = prompt.content || [];
        prompt.context = prompt.context || '';
        prompt.variables = prompt.variables || [];
        prompt.versions = (prompt.versions as Version[] || []).map(v => ({
          id: v.id,
          createdAt: v.createdAt,
          notes: v.notes,
          description: v.description || '',
          content: v.content || [],
          context: v.context || '',
          variables: v.variables || [],
        }));
      }
      return prompt as unknown as Prompt;
    },

    getPromptVersionContent: async (
      _parent: any,
      { promptId, versionId }: { promptId: string; versionId: string },
      context: GraphQLContext
    ): Promise<Version> => {
      const prompt = await prisma.prompt.findUnique({
        where: { id: promptId },
        select: { versions: true },
      });

      if (!prompt) {
        throw new Error("Prompt not found.");
      }

      const versions = (prompt.versions as Version[]) || [];
      const version = versions.find((v) => v.id === versionId);

      if (!version) {
        throw new Error("Version not found within this prompt.");
      }
      return {
        id: version.id,
        content: version.content || [],
        context: version.context || '',
        variables: version.variables || [],
        createdAt: version.createdAt,
        notes: version.notes,
        description: version.description || '',
      } as Version;
    },


    resolvePromptVariable: async (
      _parent: any,
      { projectId, variableSource }: { projectId?: string; variableSource: any; promptVariableId?: string },
      context: GraphQLContext
    ): Promise<string> => {
      const source = variableSource as PromptVariableSource;
      const currentUserId = context.user?.id;

      if (source.entityType === 'DATE_FUNCTION' && source.field === 'today') {
        return new Date().toISOString().split('T')[0];
      }

      if (!projectId && source.entityType !== 'USER') {
        return 'N/A (Project context required for this dynamic data)';
      }

      if (source.entityType === 'USER') {
        const userWhere = buildPrismaWhereClause(source.filter, projectId || '', currentUserId, source.entityType);
        const currentUser = await prisma.user.findUnique({ where: userWhere });
        if (!currentUser) return 'N/A (Current user data not found)';
        return extractFieldValue(currentUser, source.field || '') || 'N/A';
      }

      const project = await prisma.project.findUnique({
        where: { id: projectId },
        include: {
            workspace: true,
            members: {
                include: { user: true }
            }
        }
      });
      if (!project) return 'N/A (Project not found)';


      let prismaModel: any;
      let include: any;
      let orderBy: any;

      switch (source.entityType) {
        case 'PROJECT': {
          if (!source.field) return 'N/A (Project field not specified)';
          return extractFieldValue(project, source.field) || 'N/A';
        }
        case 'WORKSPACE': {
          if (!project.workspace) return 'N/A (Workspace not found)';
          if (!source.field) return 'N/A (Workspace field not specified)';
          return extractFieldValue(project.workspace, source.field) || 'N/A';
        }
        case 'TASK': {
          prismaModel = prisma.task;
          const where = buildPrismaWhereClause(source.filter, projectId!, currentUserId, source.entityType);
          include = { assignee: true, creator: true };
          orderBy = { updatedAt: 'desc' };

          if (source.aggregation) {
            const records = await prismaModel.findMany({ where, include, orderBy });
            return await applyAggregation(records, source, context);
          } else {
            const record = await prismaModel.findFirst({ where, include, orderBy });
            if (!record) return 'N/A (Task not found)';
            return extractFieldValue(record, source.field || '') || 'N/A';
          }
        }
        case 'SPRINT': {
          prismaModel = prisma.sprint;
          const where = buildPrismaWhereClause(source.filter, projectId!, currentUserId, source.entityType);
          orderBy = { startDate: 'desc' };

          if (source.aggregation) {
            const records = await prismaModel.findMany({ where, orderBy });
            return await applyAggregation(records, source, context);
          } else {
            const record = await prismaModel.findFirst({ where, orderBy });
            if (!record) return 'N/A (Sprint not found)';
            return extractFieldValue(record, source.field || '') || 'N/A';
          }
        }
        case 'DOCUMENT': {
          prismaModel = prisma.document;
          const where = buildPrismaWhereClause(source.filter, projectId!, currentUserId, source.entityType);
          orderBy = { updatedAt: 'desc' };

          if (source.aggregation) {
            const records = await prismaModel.findMany({ where, orderBy });
            return await applyAggregation(records, source, context);
          } else {
            const record = await prismaModel.findFirst({ where, orderBy });
            if (!record) return 'N/A (Document not found)';
            if (source.field === 'content' && typeof record.content === 'object') {
                return JSON.stringify(record.content);
            }
            return extractFieldValue(record, source.field || '') || 'N/A';
          }
        }
        case 'MEMBER': {
            prismaModel = prisma.projectMember;
            const where = buildPrismaWhereClause(source.filter, projectId!, currentUserId, source.entityType);
            include = { user: true };
            orderBy = { joinedAt: 'asc' };

            if (source.aggregation === 'LIST_FIELD_VALUES' && source.aggregationField === 'user.fullName') {
                const projectMembers = await prismaModel.findMany({ where, include, orderBy });
                const fullNames = projectMembers
                    .map((pm: any) => `${pm.user.firstName || ''} ${pm.user.lastName || ''}`.trim())
                    .filter(Boolean);
                if (fullNames.length === 0) return 'No members found';
                return applyAggregation(fullNames.map(name => ({ name })), { ...source, aggregationField: 'name' }, context);
            }

            if (source.aggregation) {
                const records = await prismaModel.findMany({ where, include, orderBy });
                return await applyAggregation(records, source, context);
            } else {
                const record = await prismaModel.findFirst({ where, include, orderBy });
                if (!record) return 'N/A (Member not found)';
                return extractFieldValue(record, source.field || '') || 'N/A';
            }
        }
        default:
          return 'N/A (Unsupported entity type)';
      }
    },
  },

  Mutation: {
    createPrompt: async (
      _parent: any,
      { input }: { input: {
        projectId?: string;
        title: string;
        content?: any;
        context?: string;
        description?: string;
        category?: string;
        tags?: string[];
        isPublic?: boolean;
        model?: string;
        variables?: PromptVariable[];
        versions?: Version[];
      }},
      context: GraphQLContext
    ): Promise<Prompt> => {
      const newPromptData = {
        title: input.title,
        content: input.content || [],
        context: input.context || '',
        description: input.description,
        category: input.category,
        tags: input.tags || [],
        isPublic: input.isPublic || false,
        model: input.model || 'gpt-4o',
        userId: context.user?.id || 'anonymous',
        projectId: input.projectId,
        variables: (input.variables || []).map(v => ({...v, id: v.id || generateUniqueId()})),
        versions: (input.versions || []).map(v => ({...v, id: v.id || generateUniqueId()})),
      };

      const newPrompt = await prisma.prompt.create({
        data: newPromptData as any,
      });

      newPrompt.content = newPrompt.content || [];
      newPrompt.context = newPrompt.context || '';
      newPrompt.variables = newPrompt.variables || [];
      newPrompt.versions = (newPrompt.versions as Version[] || []).map(v => ({
        id: v.id,
        createdAt: v.createdAt,
        notes: v.notes,
        description: v.description || '',
        content: v.content || [],
        context: v.context || '',
        variables: v.variables || [],
      }));

      return newPrompt as unknown as Prompt;
    },

    updatePrompt: async (
      _parent: any,
      { input }: { input: {
        id: string;
        title?: string;
        content?: any;
        context?: string;
        description?: string;
        category?: string;
        tags?: string[];
        isPublic?: boolean;
        model?: string;
        variables?: PromptVariable[];
      }},
      context: GraphQLContext
    ): Promise<Prompt> => {
      const existingPrompt = await prisma.prompt.findUnique({
        where: { id: input.id },
      });

      if (!existingPrompt) {
        throw new Error("Prompt not found.");
      }

      const updateData: any = { updatedAt: new Date() };
      if (input.title !== undefined) updateData.title = input.title;
      if (input.content !== undefined) updateData.content = input.content;
      if (input.context !== undefined) updateData.context = input.context;
      if (input.description !== undefined) updateData.description = input.description;
      if (input.category !== undefined) updateData.category = input.category;
      if (input.tags !== undefined) updateData.tags = input.tags;
      if (input.isPublic !== undefined) updateData.isPublic = input.isPublic;
      if (input.model !== undefined) updateData.model = input.model;
      if (input.variables !== undefined) {
        updateData.variables = input.variables.map(v => ({ ...v, id: v.id || generateUniqueId() }));
      }

      const updatedPrompt = await prisma.prompt.update({
        where: { id: input.id },
        data: updateData,
      });

      updatedPrompt.content = updatedPrompt.content || [];
      updatedPrompt.context = updatedPrompt.context || '';
      updatedPrompt.variables = updatedPrompt.variables || [];
      updatedPrompt.versions = (updatedPrompt.versions as Version[] || []).map(v => ({
        id: v.id,
        createdAt: v.createdAt,
        notes: v.notes,
        description: v.description || '',
        content: v.content || [],
        context: v.context || '',
        variables: v.variables || [],
      }));

      return updatedPrompt as unknown as Prompt;
    },

    deletePrompt: async (
      _parent: any,
      { id }: { id: string },
      context: GraphQLContext
    ): Promise<Prompt> => {
      const existingPrompt = await prisma.prompt.findUnique({
        where: { id },
      });

      if (!existingPrompt) {
        throw new Error("Prompt not found.");
      }

      const deletedPrompt = await prisma.prompt.delete({
        where: { id },
      });

      deletedPrompt.content = deletedPrompt.content || [];
      deletedPrompt.context = deletedPrompt.context || '';
      deletedPrompt.variables = deletedPrompt.variables || [];
      deletedPrompt.versions = (deletedPrompt.versions as Version[] || []).map(v => ({
        id: v.id,
        createdAt: v.createdAt,
        notes: v.notes,
        description: v.description || '',
        content: v.content || [],
        context: v.context || '',
        variables: v.variables || [],
      }));

      return deletedPrompt as unknown as Prompt;
    },

    snapshotPrompt: async (
      _parent: any,
      { input }: { input: { promptId: string; notes?: string } },
      context: GraphQLContext
    ): Promise<Prompt> => {
      const prompt = await prisma.prompt.findUnique({
        where: { id: input.promptId },
      });

      if (!prompt) {
        throw new Error("Prompt not found.");
      }

      const currentContent = prompt.content as any || [];
      const currentContext = prompt.context as string || '';
      const currentVariables = (prompt.variables as PromptVariable[]) || [];

      const newVersion: Version = {
        id: generateUniqueId(),
        content: currentContent,
        context: currentContext,
        variables: currentVariables.map(v => ({ ...v, id: v.id || generateUniqueId() })),
        createdAt: new Date().toISOString(),
        notes: input.notes || `Version saved on ${new Date().toLocaleString()}`,
        description: "",
      };

      const updatedVersions = [newVersion, ...(prompt.versions as Version[] || [])];

      const updatedPrompt = await prisma.prompt.update({
        where: { id: input.promptId },
        data: {
          versions: updatedVersions,
          updatedAt: new Date(),
        },
      });

      updatedPrompt.content = updatedPrompt.content || [];
      updatedPrompt.context = updatedPrompt.context || '';
      updatedPrompt.variables = updatedPrompt.variables || [];
      updatedPrompt.versions = (updatedPrompt.versions as Version[] || []).map(v => ({
        id: v.id,
        createdAt: v.createdAt,
        notes: v.notes,
        description: v.description || '',
        content: v.content || [],
        context: v.context || '',
        variables: v.variables || [],
      }));

      return updatedPrompt as unknown as Prompt;
    },

    restorePromptVersion: async (
      _parent: any,
      { input }: { input: { promptId: string; versionId: string } },
      context: GraphQLContext
    ): Promise<Prompt> => {
      const prompt = await prisma.prompt.findUnique({
        where: { id: input.promptId },
      });

      if (!prompt) {
        throw new Error("Prompt not found.");
      }

      const versions = (prompt.versions as Version[]) || [];
      const versionToRestore = versions.find((v) => v.id === input.versionId);

      if (!versionToRestore) {
        throw new Error("Version not found.");
      }

      const updatedPrompt = await prisma.prompt.update({
        where: { id: input.promptId },
        data: {
          content: versionToRestore.content,
          context: versionToRestore.context,
          variables: versionToRestore.variables.map(v => ({ ...v, id: v.id || generateUniqueId() })),
          updatedAt: new Date(),
        },
      });

      updatedPrompt.content = updatedPrompt.content || [];
      updatedPrompt.context = updatedPrompt.context || '';
      updatedPrompt.variables = updatedPrompt.variables || [];
      updatedPrompt.versions = (updatedPrompt.versions as Version[] || []).map(v => ({
        id: v.id,
        createdAt: v.createdAt,
        notes: v.notes,
        description: v.description || '',
        content: v.content || [],
        context: v.context || '',
        variables: v.variables || [],
      }));

      return updatedPrompt as unknown as Prompt;
    },

    updateVersionDescription: async (
      _parent: any,
      { input }: { input: { promptId: string; versionId: string; description: string } },
      context: GraphQLContext
    ): Promise<Prompt> => {
      const prompt = await prisma.prompt.findUnique({
        where: { id: input.promptId },
      });

      if (!prompt) {
        throw new Error("Prompt not found.");
      }

      let versions = (prompt.versions as Version[]) || [];
      const versionIndex = versions.findIndex((v) => v.id === input.versionId);

      if (versionIndex === -1) {
        throw new Error("Version not found.");
      }

      const updatedVersions = [...versions];
      updatedVersions[versionIndex] = {
        ...updatedVersions[versionIndex],
        description: input.description,
      };

      const updatedPrompt = await prisma.prompt.update({
        where: { id: input.promptId },
        data: {
          versions: updatedVersions,
          updatedAt: new Date(),
        },
      });

      updatedPrompt.content = updatedPrompt.content || [];
      updatedPrompt.context = updatedPrompt.context || '';
      updatedPrompt.variables = updatedPrompt.variables || [];
      updatedPrompt.versions = updatedVersions.map(v => ({
        id: v.id,
        createdAt: v.createdAt,
        notes: v.notes,
        description: v.description || '',
        content: v.content || [],
        context: v.context || '',
        variables: v.variables || [],
      }));

      return updatedPrompt as unknown as Prompt;
    },

  },

  Project: {
    totalTaskCount: async (parent: any, _args: any, context: GraphQLContext) => {
      if (!parent.id) return 0;
      return prisma.task.count({ where: { projectId: parent.id } });
    },
    completedTaskCount: async (parent: any, _args: any, context: GraphQLContext) => {
      if (!parent.id) return 0;
      return prisma.task.count({ where: { projectId: parent.id, status: 'DONE' } });
    },
  },

  User: {
    fullName: (parent: any) => `${parent.firstName || ''} ${parent.lastName || ''}`.trim(),
  },
};

export default promptResolvers;
```
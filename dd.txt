I will show u the following files and I want u to adjust the variable creation of the project related data . to be related to the project data itself from the bacl end not only placeholders . I will show u the files and tell me in bullet points what will u do . once we fix the plan update me the files .


'''
// components/prompt-lab/variable-discovery-builder.tsx
'use client'

import React, { useState, useEffect, useMemo, useCallback } from 'react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Command, CommandInput, CommandItem, CommandList, CommandEmpty, CommandGroup } from "@/components/ui/command";
import { Check, ChevronsUpDown, ArrowLeft, Lightbulb, Keyboard, Database, ListChecks, Calendar, FileText, Users, Briefcase, Loader2 } from 'lucide-react';
import { cn } from '@/lib/utils';
import { PromptVariable, PromptVariableType, PromptVariableSource } from './store';
import { useDebounce } from 'use-debounce';
import { toast } from 'sonner';
// Import Apollo Client hooks and queries
import { useLazyQuery } from '@apollo/client';
import { RESOLVE_PROMPT_VARIABLE_QUERY } from '@/graphql/queries/promptRelatedQueries';


// Utility to generate a clean placeholder from a name
function generatePlaceholder(name: string): string {
  if (!name) return '';
  const cleaned = name.toLowerCase().replace(/\s/g, '_').replace(/[^a-z0-9_]/g, '');
  return `{{${cleaned}}}`;
}

interface VariableDiscoveryBuilderProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onCreate: (variable: Omit<PromptVariable, 'id'>) => void;
  projectId?: string; // Keep projectId for context
}

// Helper component for visually distinct cards
const SelectionCard: React.FC<{
  icon: React.ElementType;
  title: string;
  description: string;
  onClick: () => void;
  disabled?: boolean;
}> = ({ icon: Icon, title, description, onClick, disabled }) => (
  <button
    onClick={onClick}
    disabled={disabled}
    className={cn(
      "flex flex-col items-center justify-center p-6 rounded-lg border-2 border-dashed transition-all text-center h-40",
      "hover:border-primary hover:bg-muted/50 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2",
      disabled ? "opacity-50 cursor-not-allowed bg-gray-100" : "bg-card"
    )}
  >
    <Icon className="h-10 w-10 text-primary mb-3" />
    <h3 className="text-lg font-semibold mb-1">{title}</h3>
    <p className="text-sm text-muted-foreground">{description}</p>
  </button>
);


export function VariableDiscoveryBuilder({
  open,
  onOpenChange,
  onCreate,
  projectId,
}: VariableDiscoveryBuilderProps) {
  const [currentStep, setCurrentStep] = useState<'choose_type' | 'explore_data' | 'manual_config'>(
    'choose_type'
  );
  const [searchTerm, setSearchTerm] = useState('');
  const [debouncedSearchTerm] = useDebounce(searchTerm, 300);

  // State for the variable being built (Configuration Panel)
  const [tempVariableName, setTempVariableName] = useState('');
  const [tempVariablePlaceholder, setTempVariablePlaceholder] = useState('');
  const [tempVariableDescription, setTempVariableDescription] = useState('');
  const [tempVariableType, setTempVariableType] = useState<PromptVariableType | null>(null);
  const [tempVariableDefaultValue, setTempVariableDefaultValue] = useState('');
  const [tempVariableSource, setTempVariableSource] = useState<PromptVariableSource | null>(null);

  // State for the Data Explorer
  const [selectedCategoryInExplorer, setSelectedCategoryInExplorer] = useState<string | null>(null);
  const [selectedFieldInExplorer, setSelectedFieldInExplorer] = useState<string | null>(null);

  // NEW: Use useLazyQuery directly in VariableDiscoveryBuilder
  const [fetchPreview, { data: previewData, loading: isLoadingPreview, error: previewErrorObj }] = useLazyQuery(RESOLVE_PROMPT_VARIABLE_QUERY);
  const [debouncedTempVariableSource] = useDebounce(tempVariableSource, 500);
  
  const livePreviewValue = previewData?.resolvePromptVariable;
  const previewError = previewErrorObj ? previewErrorObj.message : null;

  // Effect to trigger the preview fetch when debounced source changes
  useEffect(() => {
    if (debouncedTempVariableSource && projectId) {
      fetchPreview({
        variables: {
          projectId,
          variableSource: debouncedTempVariableSource,
          promptVariableId: undefined, // Not applicable for builder preview
        },
      });
    }
  }, [debouncedTempVariableSource, projectId, fetchPreview]);


  // --- Data for Suggestions & Explorer ---
  const dataCategories = useMemo(() => [
    { value: 'project', label: 'Project', icon: Briefcase },
    { value: 'tasks', label: 'Tasks', icon: ListChecks },
    { value: 'sprints', label: 'Sprints', icon: Calendar },
    { value: 'documents', label: 'Documents', icon: FileText },
    { value: 'members', label: 'Members', icon: Users },
    { value: 'workspace', label: 'Workspace', icon: Database },
    { value: 'user', label: 'Me (Current User)', icon: Users },
  ], []);

  const getFieldsForCategory = useCallback((category: string | null) => {
    if (!category) return [];
    switch (category) {
      case 'project': return [
        { value: 'name', label: 'Project Name', type: PromptVariableType.STRING, description: 'The name of the current project.', source: { type: 'PROJECT_FIELD', field: 'name' } },
        { value: 'description', label: 'Project Description', type: PromptVariableType.RICH_TEXT, description: 'The detailed description of the current project.', source: { type: 'PROJECT_FIELD', field: 'description' } },
        { value: 'status', label: 'Project Status', type: PromptVariableType.STRING, description: 'The current status of the project (e.g., ACTIVE, PLANNING).', source: { type: 'PROJECT_FIELD', field: 'status' } },
        { value: 'totalTaskCount', label: 'Total Tasks Count', type: PromptVariableType.NUMBER, description: 'The total number of tasks in the project.', source: { type: 'PROJECT_FIELD', field: 'totalTaskCount', aggregation: 'COUNT' } },
        { value: 'completedTaskCount', label: 'Completed Tasks Count', type: PromptVariableType.NUMBER, description: 'The number of tasks in the project that are marked as DONE.', source: { type: 'PROJECT_FIELD', field: 'completedTaskCount', aggregation: 'COUNT', filter: { status: 'DONE' } } },
      ];
      case 'tasks': return [
        { value: 'all_titles_list', label: 'All Tasks Titles List', type: PromptVariableType.LIST_OF_STRINGS, description: 'A bulleted list of all task titles in the project.', source: { type: 'TASKS_AGGREGATION', aggregation: 'LIST_TITLES', format: 'BULLET_POINTS' } },
        { value: 'my_tasks_titles_list', label: 'My Tasks Titles List', type: PromptVariableType.LIST_OF_STRINGS, description: 'A bulleted list of task titles assigned to the current user.', source: { type: 'TASKS_AGGREGATION', filter: { assigneeId: 'current_user' }, aggregation: 'LIST_TITLES', format: 'BULLET_POINTS' } },
        { value: 'completed_count', label: 'Completed Tasks Count', type: PromptVariableType.NUMBER, description: 'The total count of completed tasks in the project.', source: { type: 'TASKS_AGGREGATION', filter: { status: 'DONE' }, aggregation: 'COUNT' } },
        { value: 'task_title_by_id', label: 'Specific Task: Title (by ID)', type: PromptVariableType.STRING, description: 'The title of a specific task (requires a task ID to be provided in the filter).', source: { type: 'SINGLE_TASK_FIELD', field: 'title', entityId: 'prompt_for_task_id' } },
      ];
      case 'sprints': return [
        { value: 'current_name', label: 'Current Sprint Name', type: PromptVariableType.STRING, description: 'The name of the currently active sprint.', source: { type: 'SPRINT_FIELD', entityId: 'current_sprint', field: 'name' } },
        { value: 'current_endDate', label: 'Current Sprint End Date', type: PromptVariableType.DATE, description: 'The end date of the currently active sprint.', source: { type: 'SPRINT_FIELD', entityId: 'current_sprint', field: 'endDate' } },
        { value: 'upcoming_names_list', label: 'Upcoming Sprints Names List', type: PromptVariableType.LIST_OF_STRINGS, description: 'A bulleted list of names of all upcoming (planning) sprints.', source: { type: 'SPRINT_AGGREGATION', filter: { status: 'PLANNING' }, aggregation: 'LIST_NAMES', format: 'BULLET_POINTS' } },
      ];
      case 'documents': return [
        { value: 'latest_title', label: 'Latest Document Title', type: PromptVariableType.STRING, description: 'The title of the most recently updated document.', source: { type: 'DOCUMENT_FIELD', entityId: 'latest', field: 'title' } },
        { value: 'latest_content', label: 'Latest Document Content', type: PromptVariableType.RICH_TEXT, description: 'The full rich-text content of the most recently updated document.', source: { type: 'DOCUMENT_FIELD', entityId: 'latest', field: 'content' } },
        { value: 'all_titles_list', label: 'All Documents Titles List', type: PromptVariableType.LIST_OF_STRINGS, description: 'A bulleted list of titles of all documents in the project.', source: { type: 'DOCUMENT_AGGREGATION', aggregation: 'LIST_TITLES', format: 'BULLET_POINTS' } },
      ];
      case 'members': return [
        { value: 'all_names_list', label: 'All Project Members Names List', type: PromptVariableType.LIST_OF_STRINGS, description: 'A comma-separated list of names of all members in the project.', source: { type: 'MEMBER_LIST', aggregation: 'LIST_NAMES', format: 'COMMA_SEPARATED' } },
        { value: 'admin_names_list', label: 'Admin Members Names List', type: PromptVariableType.LIST_OF_STRINGS, description: 'A comma-separated list of names of project administrators.', source: { type: 'MEMBER_LIST', filter: { role: 'ADMIN' }, aggregation: 'LIST_NAMES', format: 'COMMA_SEPARATED' } },
      ];
      case 'workspace': return [
        { value: 'name', label: 'Workspace Name', type: PromptVariableType.STRING, description: 'The name of the workspace this project belongs to.', source: { type: 'WORKSPACE_FIELD', field: 'name' } },
        { value: 'industry', label: 'Workspace Industry', type: PromptVariableType.STRING, description: 'The industry defined for the workspace.', source: { type: 'WORKSPACE_FIELD', field: 'industry' } },
      ];
      case 'user': return [
        { value: 'firstName', label: 'My First Name', type: PromptVariableType.STRING, description: 'The first name of the current user.', source: { type: 'USER_FIELD', field: 'firstName' } },
        { value: 'email', label: 'My Email', type: PromptVariableType.STRING, description: 'The email address of the current user.', source: { type: 'USER_FIELD', field: 'email' } },
      ];
      case 'date_function': return [
        { value: 'today', label: 'Today\'s Date', type: PromptVariableType.DATE, description: 'The current date.', source: { type: 'DATE_FUNCTION', field: 'today' }, defaultValue: new Date().toISOString().split('T')[0] },
      ];
      default: return [];
    }
  }, []);

  const generalSuggestions = useMemo(() => [
    { name: 'Project Name', placeholder: generatePlaceholder('Project Name'), type: PromptVariableType.STRING, description: 'The name of the current project.', source: { type: 'PROJECT_FIELD', field: 'name' } },
    { name: 'My Email', placeholder: generatePlaceholder('My Email'), type: PromptVariableType.STRING, description: 'The email address of the current user.', source: { type: 'USER_FIELD', field: 'email' } },
    { name: 'Today\'s Date', placeholder: generatePlaceholder('Today\'s Date'), type: PromptVariableType.DATE, description: 'The current date.', source: { type: 'DATE_FUNCTION', field: 'today' }, defaultValue: new Date().toISOString().split('T')[0] },
    { name: 'Total Tasks Count', placeholder: generatePlaceholder('Total Tasks Count'), type: PromptVariableType.NUMBER, description: 'The total number of tasks in the project.', source: { type: 'PROJECT_FIELD', field: 'totalTaskCount', aggregation: 'COUNT' } },
    { name: 'All Task Titles List', placeholder: generatePlaceholder('All Task Titles List'), type: PromptVariableType.LIST_OF_STRINGS, description: 'A bulleted list of all task titles in the project.', source: { type: 'TASKS_AGGREGATION', aggregation: 'LIST_TITLES', format: 'BULLET_POINTS' } },
  ], []);

  // Filtered suggestions based on search term
  const filteredSuggestions = useMemo(() => {
    if (!debouncedSearchTerm) return generalSuggestions;
    const lowerSearch = debouncedSearchTerm.toLowerCase();

    const allSearchable = [
      ...generalSuggestions,
      ...dataCategories.flatMap(cat =>
        getFieldsForCategory(cat.value).map(field => ({
          name: `${cat.label}: ${field.label}`,
          placeholder: generatePlaceholder(`${cat.value}_${field.value}`),
          type: field.type,
          description: field.description,
          source: field.source,
          defaultValue: field.defaultValue,
        }))
      ),
      ...getFieldsForCategory('date_function').map(field => ({
          name: `Date: ${field.label}`,
          placeholder: generatePlaceholder(`Date_${field.label}`),
          type: field.type,
          description: field.description,
          source: field.source,
          defaultValue: field.defaultValue,
      })),
    ];

    const uniqueSuggestionsMap = new Map<string, typeof allSearchable[0]>();
    allSearchable.forEach(s => {
        const sourceKey = s.source ? `${s.source.type}-${s.source.field || ''}-${s.source.aggregation || ''}` : 'manual';
        const key = `${s.type}-${sourceKey}`;
        if (!uniqueSuggestionsMap.has(key)) {
            uniqueSuggestionsMap.set(key, s);
        }
    });

    return Array.from(uniqueSuggestionsMap.values()).filter(s =>
      s.name.toLowerCase().includes(lowerSearch) ||
      s.placeholder.toLowerCase().includes(lowerSearch) ||
      s.description?.toLowerCase().includes(lowerSearch)
    );
  }, [debouncedSearchTerm, generalSuggestions, dataCategories, getFieldsForCategory]);


  // --- Reset state when dialog opens or closes ---
  useEffect(() => {
    if (!open) {
      setCurrentStep('choose_type');
      setSearchTerm('');
      setTempVariableName('');
      setTempVariablePlaceholder('');
      setTempVariableDescription('');
      setTempVariableType(null);
      setTempVariableDefaultValue('');
      setTempVariableSource(null);
      setSelectedCategoryInExplorer(null);
      setSelectedFieldInExplorer(null);
    } else {
      if (!projectId) {
        setCurrentStep('manual_config');
        setTempVariableSource(null);
        setTempVariableType(PromptVariableType.STRING);
      } else {
        setCurrentStep('choose_type');
      }
    }
  }, [open, projectId]);

  // --- Update tempVariablePlaceholder when tempVariableName changes (for manual) ---
  useEffect(() => {
    if (currentStep === 'manual_config' && tempVariableName && !tempVariableSource) {
      setTempVariablePlaceholder(generatePlaceholder(tempVariableName));
    }
  }, [tempVariableName, currentStep, tempVariableSource]);


  // --- Update temp variable state when explorer selections change ---
  useEffect(() => {
    if (currentStep === 'explore_data' && selectedCategoryInExplorer && selectedFieldInExplorer) {
      const categoryFields = getFieldsForCategory(selectedCategoryInExplorer);
      const matchedField = categoryFields.find(f => f.value === selectedFieldInExplorer);

      if (matchedField) {
        setTempVariableName(matchedField.label);
        setTempVariablePlaceholder(generatePlaceholder(`${selectedCategoryInExplorer}_${matchedField.value}`));
        setTempVariableType(matchedField.type);
        setTempVariableSource(matchedField.source || null);
        setTempVariableDescription(matchedField.description || '');
        setTempVariableDefaultValue(matchedField.defaultValue || '');
      } else {
        setTempVariableName(`Custom ${selectedCategoryInExplorer} Field: ${selectedFieldInExplorer}`);
        setTempVariablePlaceholder(generatePlaceholder(`${selectedCategoryInExplorer}_${selectedFieldInExplorer}`));
        setTempVariableType(PromptVariableType.STRING);
        setTempVariableSource({ type: (selectedCategoryInExplorer.toUpperCase() + '_FIELD') as PromptVariableSource['type'], field: selectedFieldInExplorer });
        setTempVariableDescription('');
        setTempVariableDefaultValue('');
      }
    } else if (currentStep === 'explore_data' && !selectedFieldInExplorer) {
      setTempVariableName('');
      setTempVariablePlaceholder('');
      setTempVariableType(null);
      setTempVariableSource(null);
      setTempVariableDescription('');
      setTempVariableDefaultValue('');
    }
  }, [selectedCategoryInExplorer, selectedFieldInExplorer, getFieldsForCategory, currentStep]);


  const handleCreateVariable = () => {
    if (!tempVariableName || !tempVariablePlaceholder || !tempVariableType) {
      toast.error('Validation Error', {
        description: 'Variable Name, Placeholder, and Type are required.',
      });
      return;
    }

    onCreate({
      name: tempVariableName,
      placeholder: tempVariablePlaceholder,
      defaultValue: tempVariableDefaultValue,
      description: tempVariableDescription,
      type: tempVariableType,
      source: tempVariableSource,
    });
    onOpenChange(false);
  };

  const isFormValid = useMemo(() => {
    return !!tempVariableName && !!tempVariablePlaceholder && !!tempVariableType;
  }, [tempVariableName, tempVariablePlaceholder, tempVariableType]);


  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-4xl h-[90vh] flex flex-col bg-white">
        <DialogHeader className="p-0 border-b">
          <DialogTitle className="text-2xl">Variable Discovery & Builder</DialogTitle>
        </DialogHeader>

        <div className="flex-1 overflow-hidden p-2 grid grid-cols-2 gap-6">
          {/* Left Column: Discovery & Selection */}
          <div className="flex flex-col space-y-4 border-r pr-6 overflow-y-auto">
            {!projectId && currentStep !== 'manual_config' ? (
              <div className="text-center py-12 text-gray-500">
                <p className="text-lg font-semibold mb-2">No Project Selected</p>
                <p className="mb-4">Dynamic Project Data Variables require an active project context.</p>
                <Button onClick={() => { setCurrentStep('manual_config'); setTempVariableSource(null); setTempVariableType(PromptVariableType.STRING); }}>Create Manual Variable Instead</Button>
              </div>
            ) : (
              <>
                {currentStep === 'choose_type' && (
                  <div className="space-y-4">
                    <h3 className="text-lg font-semibold text-gray-800 mb-1">What kind of variable do you want?</h3>
                    <div className="grid grid-cols-1 gap-4">
                      <SelectionCard
                        icon={Database}
                        title="Dynamic Project Data"
                        description="Automatically pull live data from your projects, tasks, sprints, and more."
                        onClick={() => setCurrentStep('explore_data')}
                        disabled={!projectId}
                      />
                      <SelectionCard
                        icon={Keyboard}
                        title="Manual Input Variable"
                        description="Define a variable whose value you will manually enter or update."
                        onClick={() => { setCurrentStep('manual_config'); setTempVariableSource(null); setTempVariableType(PromptVariableType.STRING); }}
                      />
                    </div>
                  </div>
                )}

                {currentStep === 'explore_data' && (
                  <div className="flex flex-col h-full">
                    <Button variant="ghost" onClick={() => {
                      setCurrentStep('choose_type');
                      setSelectedCategoryInExplorer(null);
                      setSelectedFieldInExplorer(null);
                      setSearchTerm('');
                      setTempVariableSource(null);
                    }} className="self-start -ml-2 mb-4">
                      <ArrowLeft className="h-4 w-4 mr-2" /> Back to Types
                    </Button>
                    <h3 className="text-lg font-semibold text-gray-800 mb-4">Select Data from Your Project</h3>
                    <Input
                      placeholder="Search project data, e.g., 'task title', 'project manager', 'latest doc'..."
                      value={searchTerm}
                      onChange={(e) => setSearchTerm(e.target.value)}
                      className="mb-4"
                    />
                    <Command className="rounded-lg border shadow-sm flex-1">
                      <CommandList className="flex-1 overflow-y-auto">
                        <CommandEmpty>No results found for "{searchTerm}".</CommandEmpty>
                        {/* Suggestions Group */}
                        {filteredSuggestions.length > 0 && searchTerm !== '' && (
                          <CommandGroup heading="Search Results">
                            {filteredSuggestions.map((s, i) => (
                              <CommandItem
                                key={`search-sugg-${s.placeholder + i}`}
                                onSelect={() => {
                                  setTempVariableName(s.name);
                                  setTempVariablePlaceholder(s.placeholder);
                                  setTempVariableType(s.type);
                                  setTempVariableSource(s.source || null);
                                  setTempVariableDescription(s.description || '');
                                  setTempVariableDefaultValue(s.defaultValue || '');
                                  const categoryValue = s.source?.type?.toLowerCase().replace('_field', '').replace('_aggregation', '').replace('_list', '').replace('_function', '') || null;
                                  setSelectedCategoryInExplorer(categoryValue);
                                  setSelectedFieldInExplorer(s.source?.field || null);
                                  setSearchTerm('');
                                }}
                                className="cursor-pointer flex justify-between items-center"
                              >
                                <div>
                                  <div className="font-medium">{s.name}</div>
                                  <div className="text-xs text-muted-foreground">{s.description}</div>
                                </div>
                                <Badge variant="secondary" className="ml-2">Data</Badge>
                              </CommandItem>
                            ))}
                          </CommandGroup>
                        )}

                        {/* Browse by Category & Fields (only if no search term) */}
                        {searchTerm === '' && (
                          <>
                            <CommandGroup heading="Browse by Category">
                              {dataCategories.map((cat) => {
                                const Icon = cat.icon;
                                return (
                                  <CommandItem
                                    key={cat.value}
                                    onSelect={() => {
                                      setSelectedCategoryInExplorer(cat.value);
                                      setSelectedFieldInExplorer(null);
                                    }}
                                    className={cn(
                                      "cursor-pointer flex items-center",
                                      selectedCategoryInExplorer === cat.value && "bg-accent text-accent-foreground"
                                    )}
                                  >
                                    <Icon className="mr-2 h-4 w-4" />
                                    {cat.label}
                                  </CommandItem>
                                );
                              })}
                                <CommandItem
                                    key="date_function"
                                    onSelect={() => {
                                      setSelectedCategoryInExplorer('date_function');
                                      setSelectedFieldInExplorer(null);
                                    }}
                                    className={cn(
                                      "cursor-pointer flex items-center",
                                      selectedCategoryInExplorer === 'date_function' && "bg-accent text-accent-foreground"
                                    )}
                                  >
                                    <Calendar className="mr-2 h-4 w-4" />
                                    Date Functions
                                </CommandItem>
                            </CommandGroup>

                            {selectedCategoryInExplorer && (
                              <CommandGroup heading={`${dataCategories.find(c => c.value === selectedCategoryInExplorer)?.label || 'Selected'} Fields`}>
                                {getFieldsForCategory(selectedCategoryInExplorer).map((fieldOption) => (
                                  <CommandItem
                                    key={fieldOption.value}
                                    onSelect={() => {
                                      setSelectedFieldInExplorer(fieldOption.value);
                                    }}
                                    className={cn(
                                      "cursor-pointer",
                                      selectedFieldInExplorer === fieldOption.value && "bg-accent text-accent-foreground"
                                    )}
                                  >
                                    <Check className={cn("mr-2 h-4 w-4", selectedFieldInExplorer === fieldOption.value ? "opacity-100" : "opacity-0")} />
                                    {fieldOption.label}
                                    <span className="text-xs text-muted-foreground ml-auto">{fieldOption.type.replace(/_/g, ' ')}</span>
                                  </CommandItem>
                                ))}
                              </CommandGroup>
                            )}
                          </>
                        )}
                      </CommandList>
                    </Command>
                  </div>
                )}

                {currentStep === 'manual_config' && (
                  <div className="space-y-4">
                    <Button variant="ghost" onClick={() => setCurrentStep('choose_type')} className="self-start -ml-2 mb-4">
                      <ArrowLeft className="h-4 w-4 mr-2" /> Back to Types
                    </Button>
                    <h3 className="text-lg font-semibold text-gray-800 mb-4">Configure Manual Variable</h3>
                    <p className="text-sm text-muted-foreground mb-4">This variable's value will be set manually, or you can provide a default value.</p>
                  </div>
                )}
              </>
            )}
          </div>

          {/* Right Column: Configuration & Preview */}
          <div className="flex flex-col space-y-4 overflow-y-auto">
            <h3 className="text-xl font-semibold mb-2">Configure Your Variable</h3>
            <p className="text-sm text-muted-foreground">Finalize the details of your selected variable.</p>

            <div className="grid gap-4 flex-1 pr-2">
              <div className="grid gap-2">
                <label className="block text-sm font-medium">Variable Name <span className="text-red-500">*</span></label>
                <Input
                  value={tempVariableName}
                  onChange={(e) => setTempVariableName(e.target.value)}
                  placeholder="A descriptive name for your variable"
                  disabled={!!tempVariableSource && currentStep === 'explore_data'}
                />
                {tempVariableSource && currentStep === 'explore_data' && (
                  <p className="text-xs text-muted-foreground mt-1">Name is auto-generated for project data. Go back to change data selection.</p>
                )}
              </div>

              <div className="grid gap-2">
                <label className="block text-sm font-medium">Placeholder <span className="text-red-500">*</span></label>
                <Input
                  value={tempVariablePlaceholder}
                  readOnly={!!tempVariableSource || currentStep !== 'manual_config'}
                  className="font-mono text-sm"
                  placeholder="e.g., {{project_name}}"
                  onChange={(e) => {
                    if (currentStep === 'manual_config' && !tempVariableSource) {
                      setTempVariablePlaceholder(e.target.value);
                    }
                  }}
                />
                 {tempVariableSource && (
                  <p className="text-xs text-muted-foreground mt-1">Placeholder is generated automatically from data source.</p>
                )}
                 {currentStep === 'manual_config' && (
                  <p className="text-xs text-muted-foreground mt-1">Placeholder is generated from name, but can be customized. (e.g. {'{{' + generatePlaceholder(tempVariableName).slice(2, -2) + '}}'})</p>
                )}
              </div>

              <div className="grid gap-2">
                <label className="block text-sm font-medium">Type <span className="text-red-500">*</span></label>
                <Select value={tempVariableType || ''} onValueChange={(val) => setTempVariableType(val as PromptVariableType)} disabled={!!tempVariableSource}>
                  <SelectTrigger>
                    <SelectValue placeholder="Select variable type" />
                  </SelectTrigger>
                  <SelectContent>
                    {Object.values(PromptVariableType).map((t) => (
                      <SelectItem key={t} value={t}>{t.replace(/_/g, ' ')}</SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                 {tempVariableSource && (
                  <p className="text-xs text-muted-foreground mt-1">Type is inferred from data source.</p>
                )}
              </div>

              <div className="grid gap-2">
                <label className="block text-sm font-medium">Description</label>
                <Textarea
                  value={tempVariableDescription}
                  onChange={(e) => setTempVariableDescription(e.target.value)}
                  placeholder="Explain what this variable represents"
                  rows={3}
                />
              </div>

              <div className="grid gap-2">
                <label className="block text-sm font-medium">Default Value {tempVariableSource ? '(used if data is unavailable)' : ''}</label>
                <Input
                  value={tempVariableDefaultValue}
                  onChange={(e) => setTempVariableDefaultValue(e.target.value)}
                  placeholder="Optional default value"
                />
                 {tempVariableSource && (
                  <p className="text-xs text-muted-foreground mt-1">This value will be used if project data is unavailable, or for live preview purposes if data not mocked.</p>
                )}
              </div>

              {/* Live Preview Section */}
              <div className="mt-4 p-3 border rounded-md bg-gray-50 dark:bg-gray-800">
                <h4 className="font-semibold text-sm mb-2">Live Preview {tempVariableSource ? '(Project Data)' : ''}</h4>
                {isLoadingPreview ? (
                  <p className="text-sm text-gray-500 flex items-center"><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Fetching live data...</p>
                ) : previewError ? (
                  <p className="text-sm text-red-500">{previewError}</p>
                ) : (tempVariableSource && projectId) ? (
                  <pre className="text-sm font-mono whitespace-pre-wrap max-h-[100px] overflow-y-auto bg-white dark:bg-gray-900 p-2 rounded border border-gray-200 dark:border-gray-700">
                    {livePreviewValue || tempVariableDefaultValue || 'N/A (No value or default provided)'}
                  </pre>
                ) : !tempVariableSource && tempVariableDefaultValue ? (
                     <pre className="text-sm font-mono whitespace-pre-wrap max-h-[100px] overflow-y-auto bg-white dark:bg-gray-900 p-2 rounded border border-gray-200 dark:border-gray-700">
                        {tempVariableDefaultValue}
                    </pre>
                ) : (
                  <p className="text-sm text-muted-foreground mt-2">
                    { !tempVariableSource && "No dynamic data source selected. Preview not applicable for manual variables (value comes from default/user input)." }
                    { tempVariableSource && !projectId && "Cannot show live preview without a project ID." }
                    { !tempVariableSource && !tempVariableDefaultValue && "No dynamic data or default value to preview."}
                  </p>
                )}
              </div>
            </div>
          </div>
        </div>

        <DialogFooter className="p-2 border-t">
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button onClick={handleCreateVariable} disabled={!isFormValid}>
            Add Variable to Prompt
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
'''



'''
// components/prompt-lab/prompt-lab.tsx
'use client'

import React, { useEffect, useMemo, useRef, useState, useCallback } from "react"
import { PromptVariableType, type Prompt, type Version, type PromptVariable, type PromptVariableSource } from '@/components/prompt-lab/store';
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { Button } from "@/components/ui/button"
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs"
import { Copy, Plus, GitCommit, Text, Trash2, GripVertical, Loader2 } from "lucide-react"
import { DndProvider, useDrag, useDrop, useDragLayer } from 'react-dnd'
import { HTML5Backend } from 'react-dnd-html5-backend'
import { Tab } from "@headlessui/react"
import { VariableDiscoveryBuilder } from "./variable-discovery-builder"
import { usePromptLab } from "@/hooks/usePrompts";
import { toast } from 'sonner';
import { useDebounce } from 'use-debounce';


// Utility for deep comparison of arrays of objects (used in EditorPanel's useEffect)
function deepCompareBlocks(arr1: Block[], arr2: Block[]): boolean {
  if (arr1.length !== arr2.length) {
    console.log('[deepCompareBlocks] Different lengths: ', arr1.length, arr2.length);
    return false;
  }
  for (let i = 0; i < arr1.length; i++) {
    const b1 = arr1[i];
    const b2 = arr2[i];
    if (b1.type !== b2.type) {
      console.log(`[deepCompareBlocks] Block ${i}: Different types`, b1.type, b2.type);
      return false;
    }
    if (b1.type === 'text') {
      if (b1.value !== b2.value) {
        console.log(`[deepCompareBlocks] Block ${i} (text): Different values`, b1.value, b2.value);
        return false;
      }
    } else if (b1.type === 'variable') {
      if (b1.varId !== b2.varId || b1.placeholder !== b2.placeholder || b1.name !== b2.name) {
        console.log(`[deepCompareBlocks] Block ${i} (variable): Different identity`, {b1_varId: b1.varId, b1_ph: b1.placeholder, b1_name: b1.name}, {b2_varId: b2.varId, b2_ph: b2.placeholder, b2_name: b2.name});
        return false;
      }
    }
  }
  console.log('[deepCompareBlocks] Blocks are semantically identical.');
  return true;
}

const ItemTypes = { VARIABLE: 'variable', BLOCK: 'block' }

// Helper to merge multiple refs
function mergeRefs<T>(...refs: (React.Ref<T> | undefined)[]): React.RefCallback<T> {
  return (node: T) => {
    refs.forEach(ref => {
      if (!ref) return;
      if (typeof ref === 'function') ref(node);
      else if ('current' in ref) (ref as any).current = node;
    });
  };
}

// Helper to generate a client-side CUID for embedded JSON objects (variables, versions)
function cuid(prefix: string = ''): string { // Added prefix for debugging
  const chars = '0123456789abcdefghijklmnopqrstuvwxyz';
  let result = prefix + 'c';
  for (let i = 0; i < 24; i++) {
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
}

/* Utility to render prompt by substituting placeholder text */
async function renderPrompt(
  content: string,
  context: string,
  variables: PromptVariable[],
  variableValues: Record<string, string>,
  projectId?: string
): Promise<string> {
  let renderedContent = content;
  let renderedContext = context;

  for (const variable of variables) {
    let valueToSubstitute = variableValues[variable.placeholder] || variable.defaultValue || '';

    if (variable.source && (!variableValues[variable.placeholder] || variableValues[variable.placeholder] === 'N/A')) {
       valueToSubstitute = `[${variable.name} (dynamic)]`;
    }

    const highlightedValue = `[[${valueToSubstitute}]]`;
    const regex = new RegExp(variable.placeholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g');
    renderedContent = renderedContent.replace(regex, highlightedValue);
    renderedContext = renderedContext.replace(regex, highlightedValue);
  }

  const lines = [
    "System role:",
    "You are an expert assistant for this project.",
    "",
    "Context:",
    renderedContext || "(none)",
    "",
    "Prompt:",
    renderedContent || "(empty)",
  ];
  return lines.join("\n");
}

/* ---------- MAIN COMPONENT ---------- */
export function PromptLab({ prompt, onBack, projectId }: { prompt: Prompt; onBack: () => void; projectId?: string }) {
  // `usePromptLab` is not needed directly here in PromptLab for `currentSelectedPrompt` and `promptsLoading`
  // as the `prompt` prop is already guaranteed by PromptLabContainer.
  const { updatePrompt, snapshotPrompt, restorePromptVersion } = usePromptLab(projectId); 

  const [selectedVersionId, setSelectedVersionId] = useState<string | null>(null)
  const [rightTab, setRightTab] = useState<"editor" | "version-details" | "preview">("editor")
  const [leftTab, setLeftTab] = useState<"versions" | "variables">("variables")
  const [showVariableBuilder, setShowVariableBuilder] = useState(false);
  const [previewVariableValues, setPreviewVariableValues] = useState<Record<string, string>>({})
  const [renderedPreview, setRenderedPreview] = useState("");
  const [pendingNotes, setPendingNotes] = useState("");
  
  const [isSnapshotting, setIsSnapshotting] = useState(false);
  const [isRestoring, setIsRestoring] = useState(false);


  useEffect(() => {
    console.log('[PromptLab] Root useEffect: prompt prop changed. Prompt ID:', prompt.id, 'Title:', prompt.title, 'Content length:', prompt.content.length);
    if (prompt) {
      if (prompt.versions.length > 0) {
        if (!selectedVersionId || !prompt.versions.some((v) => v.id === selectedVersionId)) {
          console.log('[PromptLab] Selecting latest version:', prompt.versions[0].id);
          setSelectedVersionId(prompt.versions[0].id)
        }
      } else if (selectedVersionId) {
        console.log('[PromptLab] No versions, deselecting version.');
        setSelectedVersionId(null)
      }
      
      const initialPreviewValues: Record<string, string> = {};
      prompt.variables.forEach(v => {
        if (!v.source) {
          initialPreviewValues[v.placeholder] = v.defaultValue || '';
        } else {
          initialPreviewValues[v.placeholder] = `[${v.name} (dynamic)]`;
        }
      });
      console.log('[PromptLab] Updating previewVariableValues based on prompt.variables:', prompt.variables.length, 'variables found.');
      setPreviewVariableValues(initialPreviewValues);
    }
  }, [prompt, selectedVersionId]);


  useEffect(() => {
    if (prompt) {
      console.log('[PromptLab] Root useEffect: Generating preview based on prompt and previewVariableValues.');
      const generatePreview = async () => {
        const preview = await renderPrompt(prompt.content, prompt.context || '', prompt.variables, previewVariableValues, projectId);
        setRenderedPreview(preview);
      };
      generatePreview();
    }
  }, [prompt, previewVariableValues, projectId]);


  const selectedVersion = useMemo(() => prompt?.versions.find((v) => v.id === selectedVersionId) || null, [prompt, selectedVersionId])

  function copy(text: string) {
    navigator.clipboard.writeText(text).catch(() => {})
  }

  const handleUpdatePrompt = useCallback((patch: Partial<Prompt>) => {
    console.log('[PromptLab] handleUpdatePrompt called with patch:', patch);
    if (patch.variables) {
      patch.variables = patch.variables.map(v => ({...v, id: v.id || cuid('patch-var-')})) as PromptVariable[];
      console.log('[PromptLab] handleUpdatePrompt: Variables patched, new count:', patch.variables.length);
    }
    updatePrompt(prompt.id, patch);
  }, [prompt.id, updatePrompt]);

  const handleSnapshot = useCallback(async (notes?: string) => {
    setIsSnapshotting(true);
    console.log('[PromptLab] handleSnapshot: Attempting to snapshot prompt', prompt.id, 'with notes:', notes);
    try {
      await snapshotPrompt(prompt.id, notes);
      toast.success("Prompt version saved!");
      setPendingNotes('');
    } catch (error) {
      console.error(`Failed to snapshot prompt ${prompt.id}:`, error);
      toast.error("Failed to save version", { description: (error as any).message || 'An unknown error occurred.' });
    } finally {
      setIsSnapshotting(false);
      console.log('[PromptLab] handleSnapshot: Snapshot operation finished.');
    }
  }, [prompt.id, snapshotPrompt]);

  const handleRestoreVersion = useCallback(async (versionId: string) => {
    setIsRestoring(true);
    console.log('[PromptLab] handleRestoreVersion: Attempting to restore prompt', prompt.id, 'from version', versionId);
    try {
      await restorePromptVersion(prompt.id, versionId);
      toast.success("Prompt restored from version!");
    } catch (error) {
      console.error(`Failed to restore prompt ${prompt.id} from version ${versionId}:`, error);
      toast.error("Failed to restore version", { description: (error as any).message || 'An unknown error occurred.' });
    } finally {
      setIsRestoring(false);
      console.log('[PromptLab] handleRestoreVersion: Restore operation finished.');
    }
  }, [prompt.id, restorePromptVersion]);

  const handleCreateVariable = useCallback((newVariable: Omit<PromptVariable, 'id'>) => {
    console.log('[PromptLab] handleCreateVariable: Creating new variable:', newVariable.name);
    const variableWithId: PromptVariable = {
      ...newVariable,
      id: cuid('p-var-'),
    };
    const updatedVariables = [...prompt.variables, variableWithId];
    console.log('[PromptLab] handleCreateVariable: Calling handleUpdatePrompt with updated variables count:', updatedVariables.length);
    handleUpdatePrompt({ variables: updatedVariables });
    setShowVariableBuilder(false);
  }, [prompt.variables, handleUpdatePrompt]);

  const handleRemoveVariable = useCallback((variableId: string) => {
    console.log('[PromptLab] handleRemoveVariable: Removing variable with ID:', variableId);
    const updatedVariables = prompt.variables.filter(v => v.id !== variableId);
    console.log('[PromptLab] handleRemoveVariable: Calling handleUpdatePrompt with updated variables count:', updatedVariables.length);
    handleUpdatePrompt({ variables: updatedVariables });
  }, [prompt.variables, handleUpdatePrompt]);


  // Removed the internal loading and "Please select a prompt" checks.
  // PromptLabContainer ensures `prompt` prop is valid before rendering this component.
  // If `prompt` is passed, it's considered selected and either partially or fully loaded.

  return (
    <DndProvider backend={HTML5Backend}>
      <div className="page-scroller pt-0 p-1 pb-0 h-full min-h-0">
        <div className="h-[85vh] overflow-hidden">
          <div className="grid h-full min-h-0 grid-cols-1 gap-4 p-4 pb-0 md:grid-cols-[320px_1fr]">

            {/* Left side */}
            <div className="saas-card h-full min-h-0 flex flex-col">
              <Tab.Group
                selectedIndex={leftTab === "versions" ? 0 : 1}
                onChange={(index) => {
                    setLeftTab(index === 0 ? "versions" : "variables");
                    console.log('[PromptLab] Left Tab changed to:', index === 0 ? "Versions" : "Variables");
                }}
                className="flex-1 min-h-0 flex flex-col"
              >
                <div className="border-b flex flex-col pt-4 pb-2 px-3" style={{ borderColor: "var(--border)" }}>
                  <Button variant="ghost" onClick={onBack} className="mb-2 self-start text-sm px-2 -ml-2">Back to Prompt Library</Button>
                  <Tab.List className="flex h-11 bg-transparent">
                    <Tab className="px-3 py-2 ui-selected:border-b-2 ui-selected:font-semibold">Versions</Tab>
                    <Tab className="px-3 py-2 ui-selected:border-b-2 ui-selected:font-semibold">Variables</Tab>
                  </Tab.List>
                </div>

                <Tab.Panels className="flex-1 min-h-0 flex flex-col overflow-y-auto">
                  {/* Versions tab */}
                  <Tab.Panel className="flex-1 min-h-0 flex flex-col overflow-y-auto">
                    <div className="flex items-center gap-2 border-b p-3"
                     style={{ borderColor: "var(--border)", background: "var(--muted-bg)" }}
                     >
                      <h3 className="font-semibold">Versions</h3>
                      <Button className="ml-auto h-9 btn-primary" onClick={() => handleSnapshot(pendingNotes || 'New version')} disabled={isSnapshotting}>
                        {isSnapshotting ? <Loader2 className="mr-1 h-4 w-4 animate-spin" /> : <Plus className="mr-1 h-4 w-4" />} New
                      </Button>
                    </div>
                    <div className="flex-1 min-h-0 overflow-y-auto p-3">
                      {prompt.versions.length === 0 ? (
                        <div className="text-sm text-slate-500">No versions yet. Make changes and save a snapshot to create one.</div>
                      ) : (
                        <ul className="space-y-2">
                          {prompt.versions.map((v) => (
                            <li key={v.id} className="rounded-lg border p-3 hover:bg-slate-50 transition">
                              <div className="flex items-start gap-2">
                                <button className="flex-1 text-left" onClick={() => setSelectedVersionId(v.id)} title={v.notes}>
                                  <div className={`line-clamp-1 text-sm font-medium ${selectedVersionId === v.id ? 'font-bold' : ''}`}>{v.notes}</div>
                                  <div className="mt-1 text-xs text-slate-500">{new Date(v.createdAt).toLocaleString()}</div>
                                </button>
                                {selectedVersionId !== v.id && (
                                  <Button variant="ghost" size="sm" onClick={() => handleRestoreVersion(v.id)} className="h-7 px-2" disabled={isRestoring}>
                                     {isRestoring ? <Loader2 className="mr-1 h-4 w-4 animate-spin" /> : 'Restore'}
                                  </Button>
                                )}
                              </div>
                            </li>
                          ))}
                        </ul>
                      )}
                    </div>
                  </Tab.Panel>

                  {/* Variables tab */}
                  <Tab.Panel className="flex-1 min-h-0 flex flex-col overflow-y-auto">
                    <div className="flex flex-col gap-2 border-b p-3" style={{ borderColor: "var(--border)", background: "var(--muted-bg)" }}>
                      <h3 className="font-semibold">Variables</h3>
                      <Button className="w-full h-9 btn-primary" onClick={() => {
                        console.log('[PromptLab] Variables tab: Create New Variable button clicked.');
                        setShowVariableBuilder(true);
                      }}>
                        <Plus className="mr-1 h-4 w-4" /> Create New Variable
                      </Button>
                    </div>
                    <div className="flex-1 min-h-0 overflow-y-auto p-3">
                      {prompt.variables.length === 0 ? (
                        <div className="text-sm text-slate-500">No variables yet. Click "Create New Variable" to get started.</div>
                      ) : (
                        <ul className="space-y-2">
                          {prompt.variables.map((v) => (
                            <VariableItem key={v.id} variable={v} onRemove={handleRemoveVariable} />
                          ))}
                        </ul>
                      )}
                    </div>
                  </Tab.Panel>
                </Tab.Panels>
              </Tab.Group>
            </div>

            {/* Right side */}
            <div className="saas-card h-full min-h-0 flex flex-col overflow-hidden">
              <div className="flex-1 min-h-0 overflow-y-auto">
                <Tabs value={rightTab} onValueChange={(v) => {
                    setRightTab(v as any);
                    console.log('[PromptLab] Right Tab changed to:', v);
                }} className="flex h-full flex-col">
                  <div className="border-b" style={{ borderColor: "var(--border)" }}>
                    <TabsList className="h-11 bg-transparent">
                      <TabsTrigger value="editor">Editor</TabsTrigger>
                      <TabsTrigger value="version-details">Version Details</TabsTrigger>
                      <TabsTrigger value="preview">Preview</TabsTrigger>
                    </TabsList>
                  </div>

                  <div className="min-h-0 flex-1 overflow-y-auto">
                    <TabsContent value="editor" className="m-0 outline-none flex-1 overflow-y-auto">
                      <EditorPanel
                          prompt={prompt} // Pass the fully detailed prompt from usePromptLab
                          onUpdate={handleUpdatePrompt}
                          onSnapshot={handleSnapshot}
                          pendingNotes={pendingNotes}
                          setPendingNotes={setPendingNotes}
                          isSnapshotting={isSnapshotting}
                        />
                    </TabsContent>

                    {/* Version Details Panel */}
                    <TabsContent value="version-details" className="m-0 outline-none p-4 flex-1 overflow-y-auto">
                      <VersionsPanel
                        versions={prompt.versions || []}
                        selectedVersionId={selectedVersionId}
                        onSelectVersion={setSelectedVersionId}
                        onRestoreVersion={handleRestoreVersion}
                        isRestoring={isRestoring}
                      />
                    </TabsContent>

                    {/* Preview Section */}
                    <TabsContent value="preview" className="m-0 outline-none p-4 flex-1 overflow-y-auto">
                      <div className="mb-2 flex items-center justify-between">
                        <div className="text-sm font-medium">Preview</div>
                        <Button size="sm" onClick={() => copy(renderedPreview)} className="h-8 btn-primary">
                          <Copy className="mr-1 h-4 w-4" />
                          Copy
                        </Button>
                      </div>
                      <Textarea
                        readOnly
                        value={renderedPreview}
                        className="min-h-[300px] font-mono overflow-y-auto"
                        style={{ background: '#f8f8f8', color: '#333', borderColor: '#e0e0e0', lineHeight: '1.5' }}
                      />
                      <p className="text-xs text-muted-foreground mt-2">
                        Note: Text wrapped in `[[...]]` indicates a substituted variable.
                      </p>
                    </TabsContent>
                  </div>
                </Tabs>
              </div>
            </div>
          </div>
        </div>

        {/* NEW: Variable Discovery Builder */}
        <VariableDiscoveryBuilder
          open={showVariableBuilder}
          onOpenChange={setShowVariableBuilder}
          onCreate={handleCreateVariable}
          projectId={projectId}
        />
      </div>
      <CustomDragLayer />
    </DndProvider>
  )
}

/* ---------- Variable Item (Sidebar) ---------- */

function VariableItem({ variable, onRemove }: { variable: PromptVariable; onRemove: (id: string) => void }) {
  const [{ isDragging }, drag, preview] = useDrag(() => ({
    type: ItemTypes.VARIABLE,
    item: { id: variable.id, placeholder: variable.placeholder, name: variable.name },
    collect: (monitor) => {
      const dragging = monitor.isDragging();
      return { isDragging: dragging };
    },
  }), [variable]);

  useEffect(() => {
    if (preview) {
        preview(getEmptyImage(), { captureDraggingState: true });
    }
    const dragSourceElement = document.getElementById(variable.id + '-drag-source');
    if (dragSourceElement) {
        drag(dragSourceElement);
    }
  }, [drag, preview, variable.id, variable.name]);

  return (
    <div
      id={variable.id + '-drag-source'}
      className={`cursor-grab rounded px-2 py-1 mb-2 border ${
        isDragging ? 'opacity-0' : 'bg-gray-100'
      } flex items-center justify-between group`}
    >
      <div>
        <span className="font-semibold">{variable.name}</span>
        <span className="text-xs text-gray-500 ml-2">({variable.placeholder})</span>
      </div>
      <button
        onClick={() => onRemove(variable.id)}
        className="ml-2 p-1 rounded-full text-gray-400 hover:bg-gray-200 hover:text-red-600 transition-opacity opacity-0 group-hover:opacity-100"
        aria-label={`Remove variable ${variable.name}`}
      >
        <Trash2 className="h-3 w-3" />
      </button>
    </div>
  )
}


/* ---------- BLOCK-BASED EDITOR ---------- */

type Block =
  | { type: 'text'; id: string; value: string }
  | { type: 'variable'; id: string; varId: string; placeholder: string; name: string }

function parseContentToBlocks(content: string, variables: PromptVariable[], prevBlocks: Block[] = []): Block[] {
  console.log('[parseContentToBlocks] Starting parse. Content length:', content.length, 'Variables count:', variables.length, 'Prev blocks count:', prevBlocks.length);
  const sortedVariables = variables.length > 0
    ? variables.sort((a, b) => b.placeholder.length - a.placeholder.length)
    : [];
  const placeholders = sortedVariables.map(v => v.placeholder);

  let tempBlocks: Block[] = [];
  let currentText = '';
  let prevBlockMap = new Map<string, Block>();

  prevBlocks.forEach(block => {
    if (block.type === 'text') {
      prevBlockMap.set(`text-${block.value}`, block);
    } else {
      prevBlockMap.set(`variable-${block.varId}-${block.placeholder}`, block);
    }
  });


  if (placeholders.length > 0) {
    const escaped = placeholders.map(p => p.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|');
    const re = new RegExp(`(${escaped})`, 'g');
    const parts = content.split(re);

    parts.forEach((part) => {
      const matchedVar = sortedVariables.find(v => v.placeholder === part);
      if (matchedVar) {
        if (currentText !== '') {
          const textBlockKey = `text-${currentText}`;
          const existingTextBlock = prevBlockMap.get(textBlockKey);
          tempBlocks.push({ type: 'text', id: existingTextBlock?.id || cuid('t-'), value: currentText });
          currentText = '';
        }
        const varBlockKey = `variable-${matchedVar.id}-${matchedVar.placeholder}`;
        const existingVarBlock = prevBlockMap.get(varBlockKey);
        tempBlocks.push({ type: 'variable', id: existingVarBlock?.id || cuid('v-'), varId: matchedVar.id, placeholder: matchedVar.placeholder, name: matchedVar.name });
      } else {
        currentText += part;
      }
    });
  } else {
    currentText = content;
  }

  if (currentText !== '') {
    const textBlockKey = `text-${currentText}`;
    const existingTextBlock = prevBlockMap.get(textBlockKey);
    tempBlocks.push({ type: 'text', id: existingTextBlock?.id || cuid('t-'), value: currentText });
  }

  let finalBlocks: Block[] = [];
  tempBlocks.forEach((block, idx) => {
    if (block.type === 'text' && block.value === '') {
      if (
        (idx > 0 && tempBlocks[idx - 1].type === 'text' && tempBlocks[idx - 1].value === '') ||
        (idx < tempBlocks.length - 1 && tempBlocks[idx + 1].type === 'text' && tempBlocks[idx + 1].value === '')
      ) {
        if (!((idx === 0 || idx === tempBlocks.length - 1) && tempBlocks.length === 1)) {
            return;
        }
      }
    }
    finalBlocks.push(block);
  });
  
  if (finalBlocks.length === 0 || (finalBlocks.length === 1 && finalBlocks[0].type === 'variable' && finalBlocks[0].placeholder === '')) {
    console.log('[parseContentToBlocks] Fallback: Adding initial empty text block.');
    finalBlocks.push({ type: 'text', id: cuid('t-initial-empty-fallback'), value: '' });
  }
  
  if (finalBlocks.length > 1 && finalBlocks[0].type === 'text' && finalBlocks[0].value === '') {
    console.log('[parseContentToBlocks] Removing leading empty text block.');
    finalBlocks.shift();
  }
  if (finalBlocks.length > 1 && finalBlocks[finalBlocks.length - 1].type === 'text' && finalBlocks[finalBlocks.length - 1].value === '') {
    console.log('[parseContentToBlocks] Removing trailing empty text block.');
    finalBlocks.pop();
  }

  if (finalBlocks.length === 0) {
    console.log('[parseContentToBlocks] Final fallback: Returning single empty text block.');
    return [{ type: 'text', id: cuid('t-final-empty-fallback'), value: '' }];
  }
  console.log('[parseContentToBlocks] Parse finished. Final blocks count:', finalBlocks.length, 'Example ID:', finalBlocks[0]?.id);
  return finalBlocks;
}


function serializeBlocks(blocks: Block[]): string {
  const serialized = blocks
    .filter(b => !(b.type === 'text' && b.value === ''))
    .map(b => b.type === 'text' ? b.value : b.placeholder)
    .join('');
  
  return serialized;
}


/* ---------- EditorPanel: Enhanced Prompt Creation ---------- */
function EditorPanel({
  prompt,
  onUpdate,
  onSnapshot,
  pendingNotes,
  setPendingNotes,
  isSnapshotting,
}: {
  prompt: Prompt
  onUpdate: (patch: Partial<Prompt>) => void
  onSnapshot: (notes?: string) => void
  pendingNotes: string;
  setPendingNotes: (notes: string) => void;
  isSnapshotting: boolean;
}) {
  console.log(`[EditorPanel ${prompt.id}] Rendered with prompt ID: ${prompt.id}, Title: "${prompt.title}", Content length: ${prompt.content.length}`);

  const [blocks, setBlocks] = useState<Block[]>([]);
  const [localTitle, setLocalTitle] = useState('');
  const [localContext, setLocalContext] = useState('');
  const [localModel, setLocalModel] = useState('');

  // Primary useEffect to initialize/re-initialize all local states when prompt.id changes
  // or when the prompt object itself changes (e.g., from initial minimal to full details)
  useEffect(() => {
    console.log(`[EditorPanel ${prompt.id}] useEffect (prompt.id change): Initializing/Resetting all local states.`);
    // Initialize block state
    setBlocks(parseContentToBlocks(prompt.content || '', prompt.variables || []));
    // Initialize other local states
    setLocalTitle(prompt.title);
    setLocalContext(prompt.context);
    setLocalModel(prompt.model);
    setPendingNotes(''); // Reset pending notes for a new prompt
  }, [prompt.id]); // Only re-run when the prompt ID changes


  // Secondary useEffect for blocks state, specifically when content/variables change for the *current* prompt
  // This handles internal updates (e.g., after an optimistic update to variables, or fresh data from GET_PROMPT_DETAILS_QUERY)
  useEffect(() => {
    // Only proceed if prompt is fully loaded (content/variables are present) AND
    // the blocks state has already been initialized for this prompt.id
    if (!prompt.content && prompt.variables.length === 0 && blocks.length === 0) {
        console.log(`[EditorPanel ${prompt.id}] useEffect (content/variables change): Prompt is still minimal/loading, skipping blocks update.`);
        return;
    }

    console.log(`[EditorPanel ${prompt.id}] useEffect (content/variables change): Re-parsing blocks if content/variables differ.`);
    const newBlocks = parseContentToBlocks(prompt.content || '', prompt.variables || [], blocks);
    
    if (!deepCompareBlocks(blocks, newBlocks)) {
      console.log(`[EditorPanel ${prompt.id}] useEffect (content/variables change): Blocks are NOT semantically identical. Updating blocks state.`);
      setBlocks(newBlocks);
    } else {
      console.log(`[EditorPanel ${prompt.id}] useEffect (content/variables change): Blocks are semantically identical. No state update needed.`);
    }
  }, [prompt.content, prompt.variables, prompt.id]);

  const logBlocks = useCallback((message: string, currentBlocks: Block[]) => {
    const formattedBlocks = currentBlocks.map(b =>
      b.type === 'text' ? `[TEXT:"${b.value.substring(0, Math.min(b.value.length, 30))}..."] (id:${b.id})` : `[VAR:${b.name || b.placeholder} (varId: ${b.varId}, id:${b.id})]`
    ).join(' | ');
    console.log(`[EditorPanel ${prompt.id}] --- BLOCKS STATE UPDATE --- ${message}\nCURRENT BLOCKS: ${formattedBlocks}`);
  }, [prompt.id]);

  // Debounce the content update to the backend
  const serializedContent = useMemo(() => serializeBlocks(blocks), [blocks]);
  const [debouncedSerializedContent] = useDebounce(serializedContent, 500);

  useEffect(() => {
    console.log(`[EditorPanel ${prompt.id}] useEffect: debouncedSerializedContent changed.`);
    if (debouncedSerializedContent !== prompt.content) {
      console.log(`[EditorPanel ${prompt.id}] useEffect: Debounced serialized content differs from prop content. Calling onUpdate.`);
      onUpdate({ content: debouncedSerializedContent });
    } else {
      console.log(`[EditorPanel ${prompt.id}] useEffect: Debounced serialized content matches prop content.`);
    }
  }, [debouncedSerializedContent, onUpdate, prompt.content, prompt.id]);

  // Debounce for title, context, model updates
  const [debouncedLocalTitle] = useDebounce(localTitle, 300);
  const [debouncedLocalContext] = useDebounce(localContext, 300);
  const [debouncedLocalModel] = useDebounce(localModel, 300);

  useEffect(() => {
    if (debouncedLocalTitle !== prompt.title) {
      console.log(`[EditorPanel ${prompt.id}] useEffect: Debounced title "${debouncedLocalTitle}" differs from prop title "${prompt.title}". Calling onUpdate.`);
      onUpdate({ title: debouncedLocalTitle || "Untitled Prompt" });
    }
  }, [debouncedLocalTitle, prompt.title, onUpdate, prompt.id]);

  useEffect(() => {
    if (debouncedLocalContext !== prompt.context) {
      console.log(`[EditorPanel ${prompt.id}] useEffect: Debounced context "${debouncedLocalContext.substring(0, 50)}..." differs from prop context. Calling onUpdate.`);
      onUpdate({ context: debouncedLocalContext });
    }
  }, [debouncedLocalContext, prompt.context, onUpdate, prompt.id]);

  useEffect(() => {
    if (debouncedLocalModel !== prompt.model) {
      console.log(`[EditorPanel ${prompt.id}] useEffect: Debounced model "${debouncedLocalModel}" differs from prop model "${prompt.model}". Calling onUpdate.`);
      onUpdate({ model: debouncedLocalModel });
    }
  }, [debouncedLocalModel, prompt.model, onUpdate, prompt.id]);


  const insertVariableAt = useCallback((index: number, variable: { placeholder: string; id: string; name: string }) => {
    setBlocks(prev => {
      let copy = [...prev];
      const newVarBlock: Block = { type: 'variable', id: cuid('v-'), varId: variable.id, placeholder: variable.placeholder, name: variable.name };
      
      copy.splice(index, 0, newVarBlock);
      logBlocks(`After directly inserting variable "${variable.placeholder}" at index ${index}`, copy);
      return copy;
    });
  }, [logBlocks]);


  const insertTextAt = useCallback((index: number, text = '') => {
    setBlocks(prev => {
      let copy = [...prev];
      const newBlock: Block = { type: 'text', id: cuid('t-'), value: text }

      copy.splice(index, 0, newBlock)
      logBlocks(`After directly inserting text block at index ${index}`, copy);
      return copy
    })
  }, [logBlocks]);

  const updateTextBlock = useCallback((id: string, value: string) => {
    console.log(`[EditorPanel ${prompt.id}] updateTextBlock called for block ID: ${id}, new value: "${value}". Propagating to blocks state.`);
    setBlocks(prev => {
        let updated = prev.map(b => b.type === 'text' && b.id === id ? { ...b, value } : b);
        
        if (value === '' && prev.length > 1) {
             console.log(`[EditorPanel ${prompt.id}] updateTextBlock: Removing empty text block ${id} as there are other blocks.`);
             updated = updated.filter(b => !(b.type === 'text' && b.id === id && b.value === ''));
             if (updated.length === 0) {
                console.log('[EditorPanel] updateTextBlock: All blocks removed, adding empty fallback.');
                updated.push({ type: 'text', id: cuid('t-empty-fallback-after-update'), value: '' });
            }
        } else if (updated.length === 0) {
            console.log('[EditorPanel] updateTextBlock: All blocks removed, adding empty fallback (edge case).');
            updated.push({ type: 'text', id: cuid('t-empty-fallback-after-update'), value: '' });
        }


        logBlocks(`After updating text block ${id} to "${value.substring(0, Math.min(value.length, 30))}..."`, updated);
        return updated;
    });
  }, [logBlocks, prompt.id]);

  const removeBlock = useCallback((index: number) => {
    console.log(`[EditorPanel ${prompt.id}] removeBlock called for index: ${index}`);
    setBlocks(prev => {
      let copy = [...prev];
      if (index < 0 || index >= copy.length) {
          console.warn(`[EditorPanel ${prompt.id}] removeBlock: Invalid index ${index}.`);
          return prev;
      }

      const removedBlock = copy[index];
      copy.splice(index, 1); 
      console.log(`[EditorPanel ${prompt.id}] removeBlock: Removed block of type ${removedBlock.type} with ID ${removedBlock.id}.`);
      
      if (copy.length === 0) {
        console.log('[EditorPanel] removeBlock: No blocks left, adding empty fallback.');
        copy.push({ type: 'text', id: cuid('t-empty-after-remove'), value: '' });
      }

      logBlocks(`After removing block at index ${index}`, copy);
      return copy
    })
  }, [logBlocks, prompt.id]);

  const moveBlock = useCallback((from: number, to: number) => {
    console.log(`[EditorPanel ${prompt.id}] moveBlock called from index: ${from} to index: ${to}`);
    setBlocks(prev => {
      let copy = [...prev];
      if (from < 0 || from >= copy.length || to < 0 || to > copy.length) {
          console.warn(`[EditorPanel ${prompt.id}] moveBlock: Invalid indices from ${from} to ${to}.`);
          return prev;
      }

      const [item] = copy.splice(from, 1);
      copy.splice(to, 0, item);

      logBlocks(`After moving block from ${from} to ${to}`, copy);
      return copy;
    });
  }, [logBlocks, prompt.id]);

  const { isDragging: isDraggingSomething } = useDragLayer((monitor) => ({
    isDragging: monitor.isDragging(),
  }));

  const [{ isOverBlockContainer, canDropBlockContainer }, dropBlockContainer] = useDrop(() => ({
    accept: [ItemTypes.VARIABLE, ItemTypes.BLOCK],
    drop: (item: any, monitor) => {
      if (monitor.didDrop()) {
        console.log('[EditorPanel][Drop] Drop handled by a nested target, ignoring.');
        return;
      }
      console.log(`[EditorPanel ${prompt.id}][Drop] Item dropped into container.`, item);

      let targetIndex = blocks.length;
      if (blocks.length === 0) {
        targetIndex = 0;
      }

      if (monitor.getItemType() === ItemTypes.VARIABLE) {
        console.log(`[EditorPanel ${prompt.id}][Drop] Inserting variable at index ${targetIndex}.`);
        insertVariableAt(targetIndex, item);
      } else if (monitor.getItemType() === ItemTypes.BLOCK) {
        const dragIndex = item.index;
        const isNoRealMove = (dragIndex === targetIndex) ||
                             (dragIndex + 1 === targetIndex && dragIndex < targetIndex) ||
                             (dragIndex === targetIndex + 1 && targetIndex < dragIndex);

        if (isNoRealMove) {
          console.log('[EditorPanel][Drop] No real move detected, ignoring block drop.');
          return;
        }

        console.log(`[EditorPanel ${prompt.id}][Drop] Moving block from ${dragIndex} to ${targetIndex}.`);
        moveBlock(dragIndex, targetIndex);
        item.index = targetIndex;
      }
    },
    collect: (monitor) => {
        const isOver = monitor.isOver({ shallow: true });
        const canDrop = monitor.canDrop();
        return {
            isOverBlockContainer: isOver,
            canDropBlockContainer: canDrop,
        };
    },
  }), [blocks.length, insertVariableAt, moveBlock, isDraggingSomething, prompt.id]);


  return (
    <div className="flex h-full min-h-0 flex-col">
      <div className="saas-section-header rounded-t-lg">
        <div className="grid flex-1 grid-cols-1 gap-3 md:grid-cols-2">
          <Input
            value={localTitle}
            onChange={(e) => {
              console.log(`[EditorPanel ${prompt.id}] Title input changed (local state):`, e.target.value);
              setLocalTitle(e.target.value);
            }}
            className="h-10 text-sm font-medium"
            placeholder="Prompt title"
          />
          <select
            className="h-10 rounded-md border bg-background px-3 text-sm"
            value={localModel}
            onChange={(e) => {
              console.log(`[EditorPanel ${prompt.id}] Model select changed (local state):`, e.target.value);
              setLocalModel(e.target.value);
            }}
            title="Target model"
          >
            <option value="gpt-4o">OpenAI GPT-4o</option>
            <option value="gpt-4o-mini">OpenAI GPT-4o-mini</option>
            <option value="grok-3">xAI Grok-3</option>
            <option value="llama3.1-70b">Llama 3.1 70B</option>
            <option value="mixtral-8x7b">Mixtral 8x7B</option>
          </select>
        </div>
      </div>

      <div className="flex-1 overflow-auto p-4">
        <section className="rounded-lg border p-4 mb-4">
          <div className="mb-2 text-sm font-medium">Project context</div>
          <Textarea
            value={localContext}
            onChange={(e) => {
              console.log(`[EditorPanel ${prompt.id}] Context textarea changed (local state):`, e.target.value.substring(0, 50) + '...');
              setLocalContext(e.target.value);
            }}
            rows={6}
            className="overflow-y-auto"
            placeholder="Add domain, audience, constraints, style guides, and examples. Use {{variables}} if needed."
          />
        </section>

        <section className="rounded-lg border p-4 mb-4">
          <div className="mb-2 text-sm font-medium">Prompt content</div>
          <div
            ref={dropBlockContainer}
            className={`flex flex-col gap-2 min-h-[300px] border rounded p-3
                        ${isOverBlockContainer && canDropBlockContainer && isDraggingSomething ? 'bg-indigo-50 border-indigo-300' : 'bg-gray-50'}`}
          >
            {blocks.length === 0 && !isDraggingSomething ? (
                <div className="flex-1 text-center py-12 text-gray-400">
                    Drag variables or click "+ Add text" to start building your prompt.
                    <button
                      onClick={() => {
                        console.log(`[EditorPanel ${prompt.id}] Add text button clicked (empty state).`);
                        insertTextAt(0, '');
                      }}
                      className="mt-4 px-3 py-1 border rounded-md text-sm text-gray-700 bg-white hover:bg-gray-100 flex items-center justify-center mx-auto"
                    >
                      <Text className="mr-1 h-4 w-4" /> Add text
                    </button>
                </div>
            ) : (
                blocks.map((b, i) => (
                    <React.Fragment key={`block-fragment-${b.id}`}>
                        {i === 0 && (
                          <HoverAddTextBlock
                              key={`hover-insert-before-first`}
                              index={0}
                              insertTextAt={insertTextAt}
                          />
                        )}
                        <BlockRenderer
                            key={b.id}
                            block={b}
                            index={i}
                            allBlocks={blocks}
                            updateTextBlock={updateTextBlock}
                            removeBlock={removeBlock}
                            moveBlock={moveBlock}
                            insertVariableAt={insertVariableAt}
                            isDraggingSomething={isDraggingSomething}
                            insertTextAt={insertTextAt}
                        />
                        <HoverAddTextBlock
                            key={`hover-insert-after-${b.id}`}
                            index={i + 1}
                            insertTextAt={insertTextAt}
                        />
                    </React.Fragment>
                ))
            )}
            
            {blocks.length === 0 && isOverBlockContainer && canDropBlockContainer && isDraggingSomething && (
                <div className="flex-1 flex items-center justify-center border-2 border-dashed border-indigo-400 rounded-md bg-indigo-50 text-indigo-700 h-24">
                    Drop item here
                </div>
            )}
          </div>
        </section>

        <section className="flex items-center gap-2">
          <Input
            placeholder="Notes for this version"
            value={pendingNotes}
            onChange={(e) => setPendingNotes(e.target.value)}
            className="flex-1"
          />
          <Button
            onClick={() => {
              console.log(`[EditorPanel ${prompt.id}] Save button clicked.`);
              onSnapshot(pendingNotes || 'New version');
            }}
            className="btn-primary"
            disabled={isSnapshotting}
          >
            {isSnapshotting ? <Loader2 className="mr-1 h-4 w-4 animate-spin" /> : <GitCommit className="mr-1 h-4 w-4" />}
            Save
          </Button>
        </section>
      </div>
    </div>
  )
}


/* ---------- Block Renderer: Puzzle-style variable/text blocks ---------- */
function BlockRenderer({
  block,
  index,
  allBlocks,
  updateTextBlock,
  removeBlock,
  moveBlock,
  insertVariableAt,
  isDraggingSomething,
  insertTextAt,
}: {
  block: Block
  index: number
  allBlocks: Block[];
  updateTextBlock: (id: string, value: string) => void
  removeBlock: (index: number) => void
  moveBlock: (from: number, to: number) => void
  insertVariableAt: (index: number, variable: { placeholder: string; id: string; name: string }) => void
  isDraggingSomething: boolean;
  insertTextAt: (index: number, text?: string) => void;
}) {
  const contentEditableRef = useRef<HTMLDivElement | null>(null);
  const wrapperRef = useRef<HTMLDivElement | null>(null);

  console.log(`[BlockRenderer ${block.id}] Rendered with block.value: "${block.type === 'text' ? block.value : 'N/A'}"`);


  useEffect(() => {
    if (block.type === 'text') {
      console.log(`[BlockRenderer ${block.id}] useEffect: block.value changed to "${block.value}".`);
      if (contentEditableRef.current && contentEditableRef.current.innerText !== block.value && document.activeElement !== contentEditableRef.current) {
        console.log(`[BlockRenderer ${block.id}] useEffect: DOM innerText differs from block.value and not active. Setting innerText to "${block.value}".`);
        contentEditableRef.current.innerText = block.value;
      } else if (contentEditableRef.current && document.activeElement === contentEditableRef.current) {
        console.log(`[BlockRenderer ${block.id}] useEffect: Component is active, avoiding DOM update to prevent disrupting user input.`);
      }
    }
  }, [block.type, block.value]);


  const [{ isDragging, canDrag }, dragRef, preview] = useDrag(() => ({
    type: ItemTypes.BLOCK,
    item: {
      id: block.id,
      index,
      type: block.type,
      value: block.type === 'text' ? block.value : block.placeholder,
      name: block.type === 'variable' ? block.name : undefined,
      varId: block.type === 'variable' ? block.varId : undefined,
      originalBlock: block,
    },
    canDrag: (monitor) => {
      const result = true;
      return result;
    },
    collect: (m) => {
        const dragging = m.isDragging();
        const currentCanDrag = m.canDrag();
        return { isDragging: dragging, canDrag: currentCanDrag };
    },
  }), [block.id, index, block.type, block.value, block.placeholder, block.name, block.varId]);

  const connectDragSource = useCallback((node: HTMLElement | null) => {
    dragRef(node);
  }, [dragRef]);

  useEffect(() => {
    preview(getEmptyImage(), { captureDraggingState: true });
  }, [preview]);


  const [localDropTargetPosition, setLocalDropTargetPosition] = useState<'before' | 'after' | null>(null);

  const [{ isOver, canDrop }, dropRef] = useDrop(() => ({
    accept: [ItemTypes.VARIABLE, ItemTypes.BLOCK],
    hover(item: { id?: string; index?: number; placeholder?: string }, monitor) {
      if (!wrapperRef.current) {
        return;
      }
      if (!monitor.isOver({ shallow: true })) {
        if (localDropTargetPosition !== null) {
            setLocalDropTargetPosition(null);
        }
        return;
      }

      const hoverBoundingRect = wrapperRef.current.getBoundingClientRect();
      const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
      const clientOffset = monitor.getClientOffset();
      if (!clientOffset) {
        return;
      }
      const hoverClientY = clientOffset.y - hoverBoundingRect.top;

      let newDropPosition: 'before' | 'after' | null = null;
      const draggingItemType = monitor.getItemType();

      if (draggingItemType === ItemTypes.BLOCK && (item as { id: string }).id === block.id) {
        if (localDropTargetPosition !== null) {
            setLocalDropTargetPosition(null);
        }
        return;
      }

      if (draggingItemType === ItemTypes.BLOCK || draggingItemType === ItemTypes.VARIABLE) {
        newDropPosition = hoverClientY < hoverMiddleY ? 'before' : 'after';
      }

      if (localDropTargetPosition !== newDropPosition) {
        setLocalDropTargetPosition(newDropPosition);
      }
    },
    drop(item: any, monitor) {
      const dragItemType = monitor.getItemType();
      
      setLocalDropTargetPosition(null);

      if (monitor.didDrop()) {
        return;
      }

      let targetIndex = localDropTargetPosition === 'after' ? index + 1 : index;

      if (dragItemType === ItemTypes.VARIABLE) {
          console.log(`[BlockRenderer ${block.id}][Drop] Inserting variable at index ${targetIndex}.`);
          insertVariableAt(targetIndex, item);
      } else if (dragItemType === ItemTypes.BLOCK) {
        const dragIndex = item.index;

        const isNoRealMove = (dragIndex === targetIndex) ||
                             (dragIndex + 1 === targetIndex && targetIndex === index + 1) ||
                             (dragIndex === targetIndex + 1 && targetIndex === index);

        if (isNoRealMove) {
          console.log(`[BlockRenderer ${block.id}][Drop] No real move detected, ignoring block drop.`);
          return;
        }

        console.log(`[BlockRenderer ${block.id}][Drop] Moving block from ${dragIndex} to ${targetIndex}.`);
        moveBlock(dragIndex, targetIndex);
        item.index = targetIndex;
      }
    },
    collect: (monitor) => {
        const isOverVal = monitor.isOver({ shallow: true });
        const canDropVal = monitor.canDrop();
        return {
            isOver: isOverVal,
            canDrop: canDropVal,
        };
    },
  }), [index, insertVariableAt, moveBlock, localDropTargetPosition, block.id, allBlocks.length]);

  const blockRootRef = mergeRefs(wrapperRef, dropRef); 

  const showPlaceholderAbove = isOver && canDrop && localDropTargetPosition === 'before' && isDraggingSomething;
  const showPlaceholderBelow = isOver && canDrop && localDropTargetPosition === 'after' && isDraggingSomething;

  const commonClasses = `relative w-full rounded-md shadow-sm transition-all duration-100 ease-in-out`;

  if (block.type === 'variable') {
    return (
      <div
        ref={blockRootRef}
        className={`${commonClasses} ${isDragging ? 'opacity-50' : ''} flex items-center gap-2 pr-2 group`}
      >
        {showPlaceholderAbove && <div className="absolute -top-1.5 left-0 right-0 h-1 bg-blue-500 rounded-sm z-10" />}
        
        <div
          ref={connectDragSource}
          className="cursor-grab shrink-0 flex items-center justify-center w-10 h-10 bg-blue-100 border border-blue-200 rounded-md text-blue-600 shadow-md transition-opacity duration-100 opacity-100 group-hover:opacity-100"
        >
          <GripVertical className="h-6 w-6" />
        </div>

        <div
          className={`flex-1 flex items-center justify-between p-2 bg-blue-50 border border-blue-200 rounded-md `}
        >
          <div className="text-sm font-medium">{block.name || block.placeholder}</div>
        </div>
        {showPlaceholderBelow && <div className="absolute -bottom-1.5 left-0 right-0 h-1 bg-blue-500 rounded-sm z-10" />}
      </div>
    )
  } else {
    const onKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        console.log(`[BlockRenderer ${block.id}] onKeyDown: Enter pressed, preventing default.`);
        e.preventDefault();
        return;
      }
      if (e.key === 'Backspace' && contentEditableRef.current?.innerText === '' && window.getSelection()?.anchorOffset === 0) {
          e.preventDefault();
          console.log(`[BlockRenderer ${block.id}] onKeyDown: Backspace on empty block, attempting to remove.`);
          if (allBlocks.length === 1 && allBlocks[0].id === block.id) {
              console.log(`[BlockRenderer ${block.id}] onKeyDown: Only block left, clearing content.`);
              updateTextBlock(block.id, ''); 
          } else {
              removeBlock(index);
          }
      }
    }

    const onInput = (e: React.FormEvent<HTMLDivElement>) => {
      const newText = e.currentTarget.innerText;
      console.log(`[BlockRenderer ${block.id}] onInput: Current innerText: "${newText}". Calling updateTextBlock.`);
      updateTextBlock(block.id, newText);
    }

    const onBlur = () => {
      const text = contentEditableRef.current?.innerText ?? ''
      console.log(`[BlockRenderer ${block.id}] onBlur: Final text: "${text}". Block.value: "${block.value}".`);
      if (text === '' && allBlocks.length > 1) {
          console.log(`[BlockRenderer ${block.id}] onBlur: Empty text block and not the only block, removing.`);
          removeBlock(index);
      }
    }

    return (
      <div
        ref={blockRootRef}
        className={`${commonClasses} ${isDragging ? 'opacity-50' : ''} flex items-center gap-2 pr-2 group`}
      >
        {showPlaceholderAbove && <div className="absolute -top-1.5 left-0 right-0 h-1 bg-blue-500 rounded-sm z-10" />}
        <div
          className={`relative flex-1 p-2 bg-white border border-gray-300 rounded-md flex items-center group`}
        >
            <div
              ref={connectDragSource}
              className="cursor-grab shrink-0 flex items-center justify-center w-10 h-10 -ml-3 mr-2 text-gray-700 bg-gray-100 border border-gray-300 rounded-md shadow-md transition-opacity duration-100 opacity-100 group-hover:opacity-100"
              style={{ position: 'relative', left: '0', top: '0', transform: 'none' }}
            >
              <GripVertical className="h-6 w-6" />
            </div>
            <div
                contentEditable
                suppressContentEditableWarning
                onKeyDown={onKeyDown}
                onInput={onInput}
                onBlur={onBlur}
                className="flex-1 min-h-[40px] text-sm outline-none w-full whitespace-pre-wrap py-2"
                style={{ wordBreak: 'break-word' }}
                ref={contentEditableRef}
            >
            </div>
            {(allBlocks.length > 1) || (block.type === 'text' && block.value !== '') ? (
                <button
                    onClick={() => {
                        console.log(`[BlockRenderer ${block.id}] Remove button clicked.`);
                        removeBlock(index);
                    }}
                    className="ml-2 p-1 rounded-full text-gray-400 hover:bg-gray-200 hover:text-red-600 transition-opacity"
                    aria-label={`Remove text block`}
                >
                    <Trash2 className="h-4 w-4" />
                </button>
            ) : null}
        </div>
        {showPlaceholderBelow && <div className="absolute -bottom-1.5 left-0 right-0 h-1 bg-blue-500 rounded-sm z-10" />}
      </div>
    )
  }
}

const getEmptyImage = () => {
    if (typeof window === 'undefined') return new Image();
    const img = new Image();
    img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
    return img;
};


// NEW: HoverAddTextBlock component for interstitial "Add text" buttons
function HoverAddTextBlock({
  index,
  insertTextAt,
}: {
  index: number;
  insertTextAt: (index: number, text?: string) => void;
}) {
  const [isHovering, setIsHovering] = useState(false);

  return (
    <div
      key={`hover-add-text-${index}`}
      className="relative h-6 w-full flex justify-center items-center py-1 transition-all duration-100 ease-in-out group"
      onMouseEnter={() => setIsHovering(true)}
      onMouseLeave={() => setIsHovering(false)}
    >
      <div className={`absolute top-0 w-full h-full bg-transparent transition-all duration-100 ease-in-out
                      ${isHovering ? 'bg-gray-100/50' : 'bg-transparent'}`}></div>

      {isHovering && (
        <Button
          variant="ghost"
          size="sm"
          onClick={(e) => {
            e.stopPropagation();
            console.log(`[HoverAddTextBlock] Add text button clicked at index ${index}.`);
            insertTextAt(index);
            setIsHovering(false);
          }}
          className="relative z-10 h-6 px-2 py-1 text-xs bg-gray-200 text-gray-700 hover:bg-gray-300 focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 transition-all duration-100 ease-in-out transform scale-90 group-hover:scale-100"
        >
          <Text className="mr-1 h-3 w-3" /> Add text
        </Button>
      )}
    </div>
  );
}


function CustomDragLayer() {
  const {
    itemType,
    isDragging,
    item,
    currentOffset,
  } = useDragLayer((monitor) => ({
    item: monitor.getItem(),
    itemType: monitor.getItemType(),
    currentOffset: monitor.getClientOffset(),
    isDragging: monitor.isDragging(),
  }));


  if (!isDragging || !currentOffset || !item) {
    return null;
  }

  const layerStyles: React.CSSProperties = {
    position: 'fixed',
    pointerEvents: 'none',
    zIndex: 9999,
    left: 0,
    top: 0,
    transform: `translate(${currentOffset.x}px, ${currentOffset.y}px)`,
  };

  const renderItem = () => {
    switch (itemType) {
      case ItemTypes.VARIABLE:
        const variableItem = item as { id: string; placeholder: string; name?: string };
        return (
          <div className="bg-blue-200 border border-blue-400 rounded-md px-3 py-1 shadow-md opacity-90">
            <span className="font-semibold">{variableItem.name || variableItem.placeholder}</span>
            <span className="text-xs text-blue-700 ml-2">(Drag Variable)</span>
          </div>
        );
      case ItemTypes.BLOCK:
        const blockItem = item as { originalBlock: Block };
        const blockToRender = blockItem.originalBlock;

        if (blockToRender.type === 'variable') {
          return (
            <div className="flex items-center justify-between p-2 bg-blue-50 border border-blue-200 rounded-md shadow-md opacity-90">
              <div className="text-sm font-medium">{blockToRender.name || blockToRender.placeholder}</div>
            </div>
          );
        } else { // Text block
          return (
            <div className="relative p-2 bg-white border border-gray-300 rounded-md flex items-center shadow-md opacity-90">
              <div
                  className="flex-1 min-h-[40px] text-sm w-full whitespace-pre-wrap"
                  style={{ minWidth: '100px', maxWidth: '300px' }}
              >
                  {blockToRender.value.substring(0, Math.min(blockToRender.value.length, 100)) + (blockToRender.value.length > 100 ? '...' : '')}
              </div>
            </div>
          );
        }
      case '__NATIVE_HTML__':
        return (
            <div className="bg-red-200 border border-red-400 rounded-md px-3 py-1 shadow-md opacity-90">
                <span className="font-semibold text-red-800">Dragging HTML Element</span>
                <span className="text-xs text-red-700 ml-2">(Native Drag)</span>
            </div>
        );
      default:
        return null;
    }
  };

  return (
    <div style={layerStyles}>
      {renderItem()}
    </div>
  );
}


/* ---------- VersionsPanel ---------- */

function VersionsPanel({
  versions,
  selectedVersionId,
  onSelectVersion,
  onRestoreVersion,
  isRestoring,
}: {
  versions: Version[]
  selectedVersionId: string | null
  onSelectVersion: (id: string) => void
  onRestoreVersion: (versionId: string) => void
  isRestoring: boolean;
}) {
  const selectedVersion = versions.find(v => v.id === selectedVersionId);

  useEffect(() => {
    console.log('[VersionsPanel] useEffect: versions or selectedVersionId changed.');
    if (!selectedVersionId && versions.length > 0) {
      console.log('[VersionsPanel] No version selected, defaulting to latest.');
      onSelectVersion(versions[0].id);
    }
  }, [selectedVersionId, versions, onSelectVersion]);

  if (!selectedVersion) {
    console.log('[VersionsPanel] No selected version to display.');
    return (
      <div className="grid h-full place-items-center text-sm text-slate-500">
        No version selected.
      </div>
    );
  }

  console.log('[VersionsPanel] Displaying selected version:', selectedVersion.id, selectedVersion.notes);
  return (
    <div className="flex h-full min-h-0 flex-col p-4">
        <h3 className="font-semibold text-lg mb-2">{selectedVersion?.notes || 'No Notes'}</h3>
        <p className="text-sm text-gray-500 mb-4">Last Edited: {new Date(selectedVersion?.createdAt || '').toLocaleString()}</p>

        <div className="mb-4">
            <label className="block text-sm font-medium mb-1">Version Content</label>
            <Textarea
                readOnly
                value={selectedVersion?.content || ''}
                rows={10}
                className="font-mono overflow-y-auto bg-gray-50 dark:bg-gray-800"
                placeholder="No content available for this version."
            />
        </div>
        <div className="mb-4">
            <label className="block text-sm font-medium mb-1">Version Context</label>
            <Textarea
                readOnly
                value={selectedVersion?.context || ''}
                rows={5}
                className="font-mono overflow-y-auto bg-gray-50 dark:bg-gray-800"
                placeholder="No context available for this version."
            />
        </div>

        <div className="mb-4">
            <label className="block text-sm font-medium mb-1">Variables in this Version</label>
            {selectedVersion?.variables && selectedVersion.variables.length > 0 ? (
                <ul className="space-y-1">
                    {selectedVersion.variables.map(v => (
                        <li key={v.id} className="text-sm bg-gray-100 dark:bg-gray-700 p-2 rounded flex items-center justify-between">
                            <span className="font-semibold">{v.name}</span>
                            <span className="text-xs text-gray-600 dark:text-gray-400">({v.placeholder})</span>
                        </li>
                    ))}
                </ul>
            ) : (
                <p className="text-sm text-gray-500">No variables for this version.</p>
            )}
        </div>
    </div>
  )
}
'''



'''
// hooks/usePrompts.ts
'use client';

import { useState, useEffect, useCallback, useMemo } from "react";
import { useQuery, useMutation, useLazyQuery } from "@apollo/client"; // Import useLazyQuery
import { useParams } from "next/navigation";

import {
  GET_PROJECT_PROMPTS_QUERY,
  GET_PROMPT_DETAILS_QUERY,
  RESOLVE_PROMPT_VARIABLE_QUERY, // Keep this query document
  } from "@/graphql/queries/promptRelatedQueries";
import {
  CREATE_PROMPT_MUTATION,
  UPDATE_PROMPT_MUTATION,
  DELETE_PROMPT_MUTATION,
  SNAPSHOT_PROMPT_MUTATION,
  RESTORE_PROMPT_VERSION_MUTATION,
 } from "@/graphql/mutations/promptRelatedMutations";
import { Prompt, PromptVariable, Version, PromptVariableType, PromptVariableSource } from '@/components/prompt-lab/store';

// Helper to generate a client-side CUID for embedded JSON objects (variables, versions)
function cuid(prefix: string = ''): string { // Added prefix for debugging
  const chars = '0123456789abcdefghijklmnopqrstuvwxyz';
  let result = prefix + 'c';
  for (let i = 0; i < 24; i++) {
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
}

interface UsePromptLabHook {
  prompts: Prompt[];
  selectedPrompt: Prompt | null;
  loading: boolean;
  error: string | null;
  createPrompt: () => Promise<Prompt | undefined>;
  updatePrompt: (
    id: string,
    updates: Partial<Omit<Prompt, 'id' | 'createdAt' | 'updatedAt' | 'user' | 'project' | 'versions'>>
  ) => void;
  deletePrompt: (id: string) => void;
  snapshotPrompt: (promptId: string, notes?: string) => void;
  restorePromptVersion: (promptId: string, versionId: string) => void;
  selectPrompt: (id: string | null) => void;
  refetchPromptsList: () => Promise<any>;
  projectId: string | undefined;
}

export function usePromptLab(initialProjectId?: string): UsePromptLabHook {
  const params = useParams();
  const projectId = initialProjectId || (params.id as string | undefined);

  const [prompts, setPrompts] = useState<Prompt[]>([]);
  const [selectedId, setSelectedId] = useState<string | null>(null);
  const [localLoading, setLocalLoading] = useState(true);
  const [localError, setLocalError] = useState<string | null>(null);

  const selectPrompt = useCallback((id: string | null) => {
    console.log('[usePromptLab] selectPrompt called with ID:', id);
    setSelectedId(id);
  }, []);

  const {
    data: promptsListData,
    loading: listLoading,
    error: listError,
    refetch: refetchPromptsList,
  } = useQuery(GET_PROJECT_PROMPTS_QUERY, {
    variables: { projectId },
    skip: !projectId,
    fetchPolicy: "cache-and-network",
    onCompleted: (data) => {
      console.log('[usePromptLab] GET_PROJECT_PROMPTS_QUERY onCompleted. Data:', data?.getProjectPrompts.length, 'prompts.');
      setLocalError(null);
      const mappedPrompts: Prompt[] = data.getProjectPrompts.map(
        (p: any) => ({
          id: p.id,
          title: p.title,
          description: p.description,
          tags: p.tags,
          isPublic: p.isPublic,
          createdAt: p.createdAt,
          updatedAt: p.updatedAt,
          model: p.model || 'gpt-4o',
          content: '',
          context: '',
          projectId: p.projectId,
          variables: [],
          versions: [],
        })
      );

      setPrompts((prevPrompts) => {
        const prevPromptsMap = new Map(prevPrompts.map(p => [p.id, p]));
        const mergedPrompts = mappedPrompts.map(newPrompt => {
          const prevPrompt = prevPromptsMap.get(newPrompt.id);
          if (prevPrompt) {
            return {
              ...newPrompt,
              content: prevPrompt.content,
              context: prevPrompt.context,
              variables: prevPrompt.variables,
              versions: prevPrompt.versions,
            };
          }
          return newPrompt;
        });

        const updatedPromptIds = new Set(mappedPrompts.map(p => p.id));
        const filteredPrevPrompts = prevPrompts.filter(prevPrompt => updatedPromptIds.has(prevPrompt.id));

        const finalPrompts = Array.from(new Set([...filteredPrevPrompts, ...mergedPrompts].map(p => p.id)))
          .map(id => mergedPrompts.find(p => p.id === id) || filteredPrevPrompts.find(p => p.id === id)) as Prompt[];

        console.log('[usePromptLab] setPrompts (list): Updating prompts state. New count:', finalPrompts.length);
        return finalPrompts.sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
      });
    },
    onError: (err) => {
      console.error("[usePromptLab] Error fetching project prompts list:", err);
      setLocalError("Failed to load prompts list.");
    },
  });

  const { data: promptDetailsData, loading: detailsLoading } = useQuery(
    GET_PROMPT_DETAILS_QUERY,
    {
      variables: { id: selectedId },
      skip: !selectedId,
      fetchPolicy: "network-only",
      onCompleted: (data) => {
        if (data?.getPromptDetails) {
          console.log('[usePromptLab] GET_PROMPT_DETAILS_QUERY onCompleted. Details for ID:', data.getPromptDetails.id);
          setLocalError(null);
          setPrompts((prevPrompts) =>
            prevPrompts.map((p) =>
              p.id === data.getPromptDetails.id
                ? {
                    ...p,
                    title: data.getPromptDetails.title,
                    content: data.getPromptDetails.content,
                    context: data.getPromptDetails.context,
                    description: data.getPromptDetails.description,
                    category: data.getPromptDetails.category,
                    tags: data.getPromptDetails.tags,
                    isPublic: data.getPromptDetails.isPublic,
                    createdAt: data.getPromptDetails.createdAt,
                    updatedAt: data.getPromptDetails.updatedAt,
                    model: data.getPromptDetails.model,
                    projectId: data.getPromptDetails.projectId,
                    variables: data.getPromptDetails.variables.map((v: PromptVariable) => ({ ...v, id: v.id || cuid('db-var-') })), // Ensure unique client-side IDs
                    versions: data.getPromptDetails.versions.map((v: Version) => ({ ...v, id: v.id || cuid('db-ver-') })), // Ensure unique client-side IDs
                  }
                : p
            )
          );
        }
      },
      onError: (err) => {
        console.error("[usePromptLab] Error fetching prompt details:", err);
        setLocalError("Failed to load prompt details.");
        setSelectedId(null);
      },
    }
  );

  const [createPromptMutation] = useMutation(CREATE_PROMPT_MUTATION, {
    update(cache, { data: { createPrompt } }) {
      if (!createPrompt) return;
      console.log('[usePromptLab] CREATE_PROMPT_MUTATION update cache for new prompt:', createPrompt.id);

      const existingPromptsQuery = cache.readQuery<{
        getProjectPrompts: Prompt[];
      }>({
        query: GET_PROJECT_PROMPTS_QUERY,
        variables: { projectId },
      });

      if (existingPromptsQuery) {
        cache.writeQuery({
          query: GET_PROJECT_PROMPTS_QUERY,
          variables: { projectId },
          data: {
            getProjectPrompts: [
              {
                id: createPrompt.id,
                title: createPrompt.title,
                description: createPrompt.description,
                tags: createPrompt.tags,
                isPublic: createPrompt.isPublic,
                createdAt: createPrompt.createdAt,
                updatedAt: createPrompt.updatedAt,
                model: createPrompt.model,
                projectId: createPrompt.projectId,
                content: '',
                context: '',
                variables: [],
                versions: [],
                __typename: "Prompt",
              },
              ...existingPromptsQuery.getProjectPrompts,
            ].sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()),
          },
        });
      }
    },
    onCompleted: (data) => {
      if (data?.createPrompt) {
        console.log('[usePromptLab] CREATE_PROMPT_MUTATION onCompleted. New prompt ID:', data.createPrompt.id);
        const newPrompt: Prompt = {
          id: data.createPrompt.id,
          title: data.createPrompt.title,
          content: data.createPrompt.content,
          context: data.createPrompt.context,
          description: data.createPrompt.description,
          tags: data.createPrompt.tags,
          isPublic: data.createPrompt.isPublic,
          createdAt: data.createPrompt.createdAt,
          updatedAt: data.createPrompt.updatedAt,
          model: data.createPrompt.model,
          projectId: data.createPrompt.projectId,
          variables: data.createPrompt.variables.map((v: PromptVariable) => ({ ...v, id: v.id || cuid('db-var-') })),
          versions: data.createPrompt.versions.map((v: Version) => ({ ...v, id: v.id || cuid('db-ver-') })),
        };
        setPrompts((prevPrompts) => [newPrompt, ...prevPrompts].sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()));
        selectPrompt(newPrompt.id);
      }
    },
    onError: (err) => {
      console.error("[usePromptLab] Mutation Error: Create Prompt", err);
      setLocalError("Failed to create prompt.");
    },
  });

  const [updatePromptMutation] = useMutation(UPDATE_PROMPT_MUTATION, {
    onCompleted: (data) => {
      if (data?.updatePrompt) {
        console.log('[usePromptLab] UPDATE_PROMPT_MUTATION onCompleted. Updated prompt ID:', data.updatePrompt.id, 'Title:', data.updatePrompt.title);
        // This onCompleted fires AFTER the server response.
        // We already have an optimistic update.
        // The `selectPrompt(selectedId)` call here was likely causing the revert/stuck feeling.
        // Apollo Client's cache normalization should automatically update the GET_PROMPT_DETAILS_QUERY
        // if its fields are part of the UPDATE_PROMPT_MUTATION response.

        // So, we only manually update prompts list fields if needed,
        // but the main content/context/variables should be picked up by the selectedPrompt's useEffect
        // reacting to the cache update for GET_PROMPT_DETAILS_QUERY.
        setPrompts((prevPrompts) =>
          prevPrompts.map((p) =>
            p.id === data.updatePrompt.id
              ? {
                  ...p,
                  title: data.updatePrompt.title,
                  description: data.updatePrompt.description,
                  tags: data.updatePrompt.tags,
                  isPublic: data.updatePrompt.isPublic,
                  model: data.updatePrompt.model,
                  updatedAt: data.updatePrompt.updatedAt,
                  // Do NOT update content, context, variables here.
                  // Let the GET_PROMPT_DETAILS_QUERY (triggered by selectPrompt) or Apollo cache handle it.
                  // Only update list-view relevant fields.
                  content: p.content, // Preserve previous content
                  context: p.context, // Preserve previous context
                  variables: p.variables, // Preserve previous variables
                }
              : p
          ).sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime())
        );
        // IMPORTANT: Removed selectPrompt(selectedId) here. This was causing a network-only re-fetch
        // which could overwrite optimistic updates with older server data, leading to the "stuck" effect.
        // Apollo's cache should handle the updates automatically.
      }
    },
    onError: (err) => {
      console.error("[usePromptLab] Mutation Error: Update Prompt", err);
      setLocalError("Failed to update prompt.");
      // On error, revert to server state by refetching details or list
      if (selectedId) selectPrompt(selectedId); // Re-fetch details to revert editor content to last known good server state
      else refetchPromptsList(); // If no prompt selected, just refetch list
    },
  });

  const [deletePromptMutation] = useMutation(DELETE_PROMPT_MUTATION, {
    update(cache, { data: { deletePrompt } }) {
      if (!deletePrompt) return;
      console.log('[usePromptLab] DELETE_PROMPT_MUTATION update cache for deleted prompt:', deletePrompt.id);

      const existingPrompts = cache.readQuery<{
        getProjectPrompts: Prompt[];
      }>({
        query: GET_PROJECT_PROMPTS_QUERY,
        variables: { projectId },
      });

      if (existingPrompts) {
        cache.writeQuery({
          query: GET_PROJECT_PROMPTS_QUERY,
          variables: { projectId },
          data: {
            getProjectPrompts: existingPrompts.getProjectPrompts.filter(
              (p) => p.id !== deletePrompt.id
            ),
          },
        });
      }
    },
    onCompleted: (data) => {
      if (data?.deletePrompt.id) {
        console.log('[usePromptLab] DELETE_PROMPT_MUTATION onCompleted. Deleted prompt ID:', data.deletePrompt.id);
        setPrompts((prevPrompts) => prevPrompts.filter((p) => p.id !== data.deletePrompt.id));
        if (selectedId === data.deletePrompt.id) {
          setSelectedId(null);
        }
      }
    },
    onError: (err) => {
      console.error("[usePromptLab] Mutation Error: Delete Prompt", err);
      setLocalError("Failed to delete prompt.");
      refetchPromptsList();
    },
  });

  const [snapshotPromptMutation] = useMutation(SNAPSHOT_PROMPT_MUTATION, {
    onCompleted: (data) => {
      if (data?.snapshotPrompt) {
        console.log('[usePromptLab] SNAPSHOT_PROMPT_MUTATION onCompleted. Prompt ID:', data.snapshotPrompt.id);
        setPrompts((prevPrompts) =>
          prevPrompts.map((p) =>
            p.id === data.snapshotPrompt.id
              ? {
                  ...p,
                  versions: data.snapshotPrompt.versions.map((v: Version) => ({ ...v, id: v.id || cuid('db-ver-') })),
                  updatedAt: data.snapshotPrompt.updatedAt,
                }
              : p
          ).sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime())
        );
        // This is a case where we *do* want to re-fetch details, as versions list is new.
        if (selectedId === data.snapshotPrompt.id) {
          console.log('[usePromptLab] SNAPSHOT_PROMPT_MUTATION: Re-selecting prompt to update versions list.');
          selectPrompt(selectedId);
        }
      }
    },
    onError: (err) => {
      console.error("[usePromptLab] Mutation Error: Snapshot Prompt", err);
      setLocalError("Failed to save version.");
      if (selectedId) selectPrompt(selectedId);
    },
  });

  const [restorePromptVersionMutation] = useMutation(RESTORE_PROMPT_VERSION_MUTATION, {
    onCompleted: (data) => {
      if (data?.restorePromptVersion) {
        console.log('[usePromptLab] RESTORE_PROMPT_VERSION_MUTATION onCompleted. Prompt ID:', data.restorePromptVersion.id);
        setPrompts((prevPrompts) =>
          prevPrompts.map((p) =>
            p.id === data.restorePromptVersion.id
              ? {
                  ...p,
                  content: data.restorePromptVersion.content,
                  context: data.restorePromptVersion.context,
                  variables: data.restorePromptVersion.variables.map((v: PromptVariable) => ({ ...v, id: v.id || cuid('db-var-') })),
                  updatedAt: data.restorePromptVersion.updatedAt,
                }
              : p
          )
        );
        // This is a case where we *do* want to re-fetch details, as content/context/variables change.
        if (selectedId === data.restorePromptVersion.id) {
            console.log('[usePromptLab] RESTORE_PROMPT_VERSION_MUTATION: Re-selecting prompt to update editor content.');
            selectPrompt(selectedId);
        }
      }
    },
    onError: (err) => {
      console.error("[usePromptLab] Mutation Error: Restore Prompt Version", err);
      setLocalError("Failed to restore version.");
      if (selectedId) selectPrompt(selectedId);
    },
  });


  useEffect(() => {
    console.log('[usePromptLab] Root useEffect: Updating localLoading state. listLoading:', listLoading, 'detailsLoading:', detailsLoading, 'projectId:', projectId);
    setLocalLoading(listLoading || detailsLoading || !projectId);
  }, [listLoading, detailsLoading, projectId]);

  useEffect(() => {
    if (listError) {
      console.error('[usePromptLab] Root useEffect: listError detected:', listError.message);
      setLocalError(listError.message);
    }
  }, [listError]);


  const createPrompt = useCallback(
    async (): Promise<Prompt | undefined> => {
      setLocalError(null);
      console.log('[usePromptLab] createPrompt: Initiating creation for projectId:', projectId);
      try {
        const defaultPrompt: Omit<Prompt, 'id' | 'createdAt' | 'updatedAt' | 'user' | 'project' | 'versions'> = {
          title: 'Untitled Prompt',
          content: '',
          context: '',
          description: '',
          category: '',
          tags: [],
          isPublic: false,
          model: 'gpt-4o',
          projectId: projectId,
          variables: [],
        };

        const { data } = await createPromptMutation({
          variables: {
            input: defaultPrompt,
          },
        });

        if (data?.createPrompt) {
          return {
            id: data.createPrompt.id,
            title: data.createPrompt.title,
            content: data.createPrompt.content,
            context: data.createPrompt.context,
            description: data.createPrompt.description,
            tags: data.createPrompt.tags,
            isPublic: data.createPrompt.isPublic,
            createdAt: data.createPrompt.createdAt,
            updatedAt: data.createPrompt.updatedAt,
            model: data.createPrompt.model,
            projectId: data.createPrompt.projectId,
            variables: data.createPrompt.variables.map((v: PromptVariable) => ({ ...v, id: v.id || cuid('db-var-') })),
            versions: data.createPrompt.versions.map((v: Version) => ({ ...v, id: v.id || cuid('db-ver-') })),
          };
        }
      } catch (err: any) {
        console.error("[usePromptLab] Error creating prompt via GraphQL:", err);
        setLocalError("Failed to create prompt.");
      }
      return undefined;
    },
    [projectId, createPromptMutation]
  );

  const updatePrompt = useCallback(
    (
      id: string,
      updates: Partial<Omit<Prompt, 'id' | 'createdAt' | 'updatedAt' | 'user' | 'project' | 'versions'>>
    ) => {
      setLocalError(null);
      console.log('[usePromptLab] updatePrompt: Optimistically updating prompt ID:', id, 'with:', updates);

      setPrompts((prev) => {
        const updatedPrompts = prev.map((p) =>
          p.id === id
            ? {
                ...p,
                ...updates,
                updatedAt: new Date().toISOString(),
                // Ensure variables are deeply updated if present in patch, preserving client-side IDs
                variables: updates.variables ? updates.variables.map((v: Partial<PromptVariable>) => ({...v, id: v.id || cuid('patch-var-')})) as PromptVariable[] : p.variables,
              }
            : p
        );
        // Ensure the array reference changes even if the content is "deeply equal" but the object itself is not
        const sorted = [...updatedPrompts].sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
        console.log('[usePromptLab] updatePrompt: Prompts state optimistically updated. Selected prompt title:', sorted.find(p => p.id === id)?.title);
        return sorted;
      });

      updatePromptMutation({
        variables: {
          input: {
            id,
            title: updates.title,
            content: updates.content,
            context: updates.context,
            description: updates.description,
            category: updates.category,
            tags: updates.tags,
            isPublic: updates.isPublic,
            model: updates.model,
            variables: updates.variables,
          },
        },
      }).catch((err) => {
        console.error("[usePromptLab] Error updating prompt via GraphQL:", err);
        setLocalError("Failed to update prompt.");
        if (selectedId) selectPrompt(selectedId);
        else refetchPromptsList();
      });
    },
    [updatePromptMutation, selectedId, selectPrompt]
  );

  const deletePrompt = useCallback(
    (id: string) => {
      setLocalError(null);
      console.log('[usePromptLab] deletePrompt: Optimistically deleting prompt ID:', id);
      setPrompts((prev) => prev.filter((p) => p.id !== id));
      if (selectedId === id) {
        console.log('[usePromptLab] deletePrompt: Deselecting deleted prompt.');
        setSelectedId(null);
      }

      deletePromptMutation({
        variables: { id },
      }).catch((err) => {
        console.error("[usePromptLab] Error deleting prompt via GraphQL:", err);
        setLocalError("Failed to delete prompt.");
        refetchPromptsList();
      });
    },
    [selectedId, deletePromptMutation, refetchPromptsList]
  );

  const snapshotPrompt = useCallback(
    (promptId: string, notes?: string) => {
      setLocalError(null);
      console.log('[usePromptLab] snapshotPrompt: Initiating snapshot for prompt ID:', promptId);
      snapshotPromptMutation({
        variables: {
          input: { promptId, notes: notes || `Version saved at ${new Date().toLocaleString()}` },
        },
      }).catch((err) => {
        console.error("[usePromptLab] Error creating prompt snapshot via GraphQL:", err);
        setLocalError("Failed to save prompt version.");
        if (selectedId) selectPrompt(selectedId);
      });
    },
    [snapshotPromptMutation, selectedId, selectPrompt]
  );

  const restorePromptVersion = useCallback(
    (promptId: string, versionId: string) => {
      setLocalError(null);
      console.log('[usePromptLab] restorePromptVersion: Initiating restore for prompt ID:', promptId, 'version ID:', versionId);
      restorePromptVersionMutation({
        variables: {
          input: { promptId, versionId },
        },
      }).catch((err) => {
        console.error("[usePromptLab] Error restoring prompt version via GraphQL:", err);
        setLocalError("Failed to restore prompt version.");
        if (selectedId) selectPrompt(selectedId);
      });
    },
    [restorePromptVersionMutation, selectedId, selectPrompt]
  );

  const selectedPrompt = useMemo(
    () => {
      const foundPrompt = prompts.find((p) => p.id === selectedId) || null;
      console.log('[usePromptLab] selectedPrompt useMemo re-evaluated. Found:', !!foundPrompt, 'ID:', foundPrompt?.id, 'Title:', foundPrompt?.title);
      return foundPrompt;
    },
    [prompts, selectedId]
  );

  console.log('[usePromptLab] Rendered. Prompts count:', prompts.length, 'Selected ID:', selectedId);
  return {
    prompts,
    selectedPrompt,
    loading: localLoading,
    error: localError,
    createPrompt,
    updatePrompt,
    deletePrompt,
    snapshotPrompt,
    restorePromptVersion,
    selectPrompt,
    refetchPromptsList,
    projectId,
  };
}
'''



'''
graphql/mutations/promptRelatedMutations.ts
import { gql } from 'graphql-tag'; // Or your equivalent for GQL mutations

// --- Prompt Mutations ---

export const CREATE_PROMPT_MUTATION = gql`
  mutation CreatePrompt($input: CreatePromptInput!) {
    createPrompt(input: $input) {
      id
      title
      content
      context
      description
      tags
      isPublic
      createdAt
      updatedAt
      model
      projectId
      variables {
        id
        name
        placeholder
        type
        defaultValue
        source
      }
      versions {
        id
        createdAt
        notes
      }
    }
  }
`;

export const UPDATE_PROMPT_MUTATION = gql`
  mutation UpdatePrompt($input: UpdatePromptInput!) {
    updatePrompt(input: $input) {
      id
      title
      content
      context
      description
      tags
      isPublic
      updatedAt
      model
      variables { # Return updated variables
        id
        name
        placeholder
        type
        defaultValue
        source
      }
    }
  }
`;

export const DELETE_PROMPT_MUTATION = gql`
  mutation DeletePrompt($id: ID!) {
    deletePrompt(id: $id) {
      id
    }
  }
`;

export const SNAPSHOT_PROMPT_MUTATION = gql`
  mutation SnapshotPrompt($input: SnapshotPromptInput!) {
    snapshotPrompt(input: $input) {
      id
      versions { # Return all versions to update UI
        id
        content
        context
        variables {
          id
          name
          placeholder
          type
          defaultValue
          source
        }
        createdAt
        notes
      }
    }
  }
`;

export const RESTORE_PROMPT_VERSION_MUTATION = gql`
  mutation RestorePromptVersion($input: RestorePromptVersionInput!) {
    restorePromptVersion(input: $input) {
      id
      content
      context
      variables { # Return updated content and variables
        id
        name
        placeholder
        type
        defaultValue
        source
      }
    }
  }
`;

'''


'''
graphql/queries/promptRelatedQueries.ts
// lib/graphql/queries.ts
 
import { gql } from 'graphql-tag'; // Or your equivalent for GQL queries
 
// --- Prompt Queries ---

export const GET_PROJECT_PROMPTS_QUERY = gql`
  query GetProjectPrompts($projectId: ID) {
    getProjectPrompts(projectId: $projectId) {
      id
      title
      description
      tags
      updatedAt
      isPublic
      projectId # Now valid after schema update
      # We don't need content, context, variables, versions for the list view
    }
  }
`;

export const GET_PROMPT_DETAILS_QUERY = gql`
  query GetPromptDetails($id: ID!) {
    getPromptDetails(id: $id) {
      id
      title
      content
      context
      description
      category
      tags
      isPublic
      createdAt
      updatedAt
      model
      projectId
      user { # Include user for personal prompts
        id
        firstName
        lastName
      }
      variables {
        id
        name
        placeholder
        description
        type
        defaultValue
        source
      }
      versions {
        id
        content
        context
        variables {
          id
          name
          placeholder
          description
          type
          defaultValue
          source
        }
        createdAt
        notes
      }
    }
  }
`;

// --- Variable Resolver Query ---
export const RESOLVE_PROMPT_VARIABLE_QUERY = gql`
  query ResolvePromptVariable($projectId: ID, $variableSource: JSON!, $promptVariableId: ID) {
    resolvePromptVariable(projectId: $projectId, variableSource: $variableSource, promptVariableId: $promptVariableId)
  }
`;
'''



'''
graphql/resolvers/promptResolver.ts

import { GraphQLResolveInfo } from 'graphql';
import { prisma } from "@/lib/prisma";
import { type Prompt, type PromptVariable, type Version, PromptVariableType } from '@/components/prompt-lab/types';

interface GraphQLContext {
  prisma: typeof prisma;
  user?: { id: string; email: string; role: string }; // User might still be provided, but not checked
}

// Utility to generate a unique ID, mimicking client-side cuid for consistency
function generateUniqueId(): string {
  // In a real backend, you'd rely on database-generated IDs or a more robust UUID/CUID library
  return `svr_${Math.random().toString(36).slice(2)}${Date.now()}`;
}

const promptResolvers = {
  Query: {
    getProjectPrompts: async (
      _parent: any,
      { projectId }: { projectId?: string },
      context: GraphQLContext // Context might still have user, but we won't check it
    ): Promise<Prompt[]> => {
      // All user and project access checks removed.

      let finalWhereClause: any = {};
      if (projectId) {
          // If projectId is provided, filter by project.
          finalWhereClause = {
              projectId: projectId,
          };
      } else {
          // If no projectId, fetch all prompts that are not linked to a project (personal ones)
          // For simplicity, we'll try to get them for the logged-in user if available, otherwise just no-project prompts.
          // Note: If `user` is undefined here, it might fetch prompts with `userId: undefined` if that's possible.
          // Assuming `user` from context is always present for 'personal' logic, even if not strictly enforced.
          finalWhereClause = {
              // projectId: null, // Only fetch prompts without a project
              // Assuming you still want personal prompts if no projectId, this will fetch all `projectId: null`
              // If you want all prompts if no projectId (even project ones), remove projectId: null
              // For full "no checks", we'd simply return ALL prompts if projectId is not provided.
              // Let's go with "all prompts matching projectId, or all personal prompts for the user if no projectId".
              // This is closest to original intent without specific auth.
              AND: [
                { projectId: null },
                { userId: context.user?.id || '' } // Fallback to empty string if user not available, meaning no match for userId
              ]
          };
      }

      const prompts = await prisma.prompt.findMany({
        where: finalWhereClause,
        orderBy: { updatedAt: 'desc' },
        select: {
          id: true,
          title: true,
          description: true,
          tags: true,
          isPublic: true,
          createdAt: true,
          updatedAt: true,
          model: true,
          projectId: true,
          // Content, context, variables, versions are not returned in list query for performance
        },
      });

      return prompts as unknown as Prompt[];
    },

    getPromptDetails: async (
      _parent: any,
      { id }: { id: string },
      context: GraphQLContext
    ): Promise<Prompt> => {
      // All user and project access checks removed.

      const prompt = await prisma.prompt.findUnique({
        where: { id },
        include: {
          user: {
            select: { id: true, firstName: true, lastName: true },
          },
          project: {
            select: { id: true, name: true, workspaceId: true },
          },
        },
      });

      // No prompt existence check. If not found, it will return null.
      // GraphQL's non-nullable types might cause an error if `Prompt` is non-nullable.
      // Assuming 'Prompt' is nullable in schema for now.
      // If it's non-nullable, `if (!prompt) throw new Error("Prompt not found.");` would be needed.
      return prompt as unknown as Prompt;
    },

    resolvePromptVariable: async (
      _parent: any,
      { projectId, variableSource, promptVariableId }: { projectId?: string; variableSource: any; promptVariableId?: string },
      context: GraphQLContext
    ): Promise<string> => {
      // All user and project access checks removed.

      if (variableSource.type === 'USER_FIELD') {
        const currentUser = await prisma.user.findUnique({ where: { id: context.user?.id || '' } }); // Use context.user without checking if it exists
        if (!currentUser) return 'N/A'; // Still return N/A if user doesn't exist in DB
        switch (variableSource.field) {
          case 'firstName': return currentUser.firstName || 'N/A';
          case 'email': return currentUser.email || 'N/A';
          default: return 'N/A';
        }
      }

      if (variableSource.type === 'DATE_FUNCTION' && variableSource.field === 'today') {
        return new Date().toISOString().split('T')[0];
      }

      if (!projectId) {
        return 'N/A (Project context required for dynamic data)';
      }

      const project = await prisma.project.findUnique({
        where: { id: projectId },
        include: {
            workspace: true,
        }
      });
      if (!project) return 'N/A (Project not found)'; // Still need this to prevent access to undefined project properties


      switch (variableSource.type) {
        case 'PROJECT_FIELD': {
          switch (variableSource.field) {
            case 'name': return project.name;
            case 'description': return project.description || 'N/A';
            case 'status': return project.status;
            case 'totalTaskCount': {
              const count = await prisma.task.count({ where: { projectId } });
              return String(count);
            }
            case 'completedTaskCount': {
              const count = await prisma.task.count({ where: { projectId, status: 'DONE' } });
              return String(count);
            }
            default: return 'N/A';
          }
        }
        case 'TASKS_AGGREGATION': {
          const where: any = { projectId };
          if (variableSource.filter?.assigneeId === 'current_user') {
            where.assigneeId = context.user?.id; // Use context.user without checking if it exists
          }
          if (variableSource.filter?.status) {
            where.status = variableSource.filter.status;
          }

          if (variableSource.aggregation === 'LIST_TITLES') {
            const tasks = await prisma.task.findMany({
              where,
              select: { title: true },
              orderBy: { createdAt: 'asc' },
            });
            const titles = tasks.map(t => t.title).filter(Boolean);
            if (titles.length === 0) return 'No tasks found';
            return variableSource.format === 'BULLET_POINTS' ? titles.map(t => ` ${t}`).join('\n') : titles.join(', ');
          }
          if (variableSource.aggregation === 'COUNT') {
            const count = await prisma.task.count({ where });
            return String(count);
          }
          return 'N/A';
        }
        case 'SINGLE_TASK_FIELD': {
          let taskWhere: any = { projectId };
          if (variableSource.entityId === 'prompt_for_task_id') {
              const anyTask = await prisma.task.findFirst({ where: { projectId }, orderBy: { createdAt: 'desc' } });
              if (anyTask) taskWhere.id = anyTask.id;
              else return 'N/A (No tasks in project)';
          } else if (variableSource.entityId) {
              taskWhere.id = variableSource.entityId;
          } else {
              return 'N/A (Specific task ID or "prompt_for_task_id" expected)';
          }

          const task = await prisma.task.findUnique({
            where: taskWhere,
          });

          if (!task) return 'N/A (Task not found)';

          switch (variableSource.field) {
            case 'title': return task.title;
            case 'description': return task.description || 'N/A';
            default: return 'N/A';
          }
        }
        case 'SPRINT_FIELD':
        case 'SPRINT_AGGREGATION': {
            let sprintWhere: any = { projectId };
            if (variableSource.entityId === 'current_sprint') {
                sprintWhere.status = 'ACTIVE';
            } else if (variableSource.filter?.status) {
                sprintWhere.status = variableSource.filter.status;
            }

            if (variableSource.aggregation === 'LIST_NAMES') {
                const sprints = await prisma.sprint.findMany({
                    where: sprintWhere,
                    select: { name: true },
                    orderBy: { startDate: 'asc' },
                });
                const names = sprints.map(s => s.name).filter(Boolean);
                if (names.length === 0) return 'No sprints found';
                return variableSource.format === 'BULLET_POINTS' ? names.map(n => ` ${n}`).join('\n') : names.join(', ');
            } else { // Single field for SPRINT_FIELD
                const sprint = await prisma.sprint.findFirst({
                    where: sprintWhere,
                    orderBy: { startDate: 'desc' },
                });
                if (!sprint) return 'N/A (Sprint not found)';
                switch (variableSource.field) {
                    case 'name': return sprint.name;
                    case 'endDate': return sprint.endDate.toISOString().split('T')[0];
                    default: return 'N/A';
                }
            }
        }
        case 'DOCUMENT_FIELD':
        case 'DOCUMENT_AGGREGATION': {
            let documentWhere: any = { projectId };

            if (variableSource.aggregation === 'LIST_TITLES') {
                const documents = await prisma.document.findMany({
                    where: documentWhere,
                    select: { title: true },
                    orderBy: { updatedAt: 'desc' },
                });
                const titles = documents.map(d => d.title).filter(Boolean);
                if (titles.length === 0) return 'No documents found';
                return variableSource.format === 'BULLET_POINTS' ? titles.map(t => ` ${t}`).join('\n') : titles.join(', ');
            } else { // Single field for DOCUMENT_FIELD
                const document = await prisma.document.findFirst({
                    where: documentWhere,
                    orderBy: { updatedAt: 'desc' },
                });
                if (!document) return 'N/A (Document not found)';
                switch (variableSource.field) {
                    case 'title': return document.title;
                    case 'content': return JSON.stringify(document.content) || 'N/A';
                    default: return 'N/A';
                }
            }
        }
        case 'MEMBER_LIST': {
            const projectMembers = await prisma.projectMember.findMany({
                where: { projectId, ...variableSource.filter },
                include: { user: { select: { firstName: true, lastName: true } } },
                orderBy: { joinedAt: 'asc' },
            });
            const names = projectMembers.map(pm => `${pm.user.firstName || ''} ${pm.user.lastName || ''}`.trim()).filter(Boolean);
            if (names.length === 0) return 'No members found';
            return variableSource.format === 'COMMA_SEPARATED' ? names.join(', ') : names.map(n => ` ${n}`).join('\n');
        }
        case 'WORKSPACE_FIELD': {
            if (!project.workspace) return 'N/A (Workspace not found for this project)';
            switch (variableSource.field) {
                case 'name': return project.workspace.name;
                case 'industry': return project.workspace.industry || 'N/A';
                case 'teamSize': return project.workspace.teamSize || 'N/A';
                default: return 'N/A';
            }
        }
        default: return 'N/A (Unknown variable source type)';
      }
    },
  },

  Mutation: {
    createPrompt: async (
      _parent: any,
      { input }: { input: {
        projectId?: string;
        title: string;
        content?: string;
        context?: string;
        description?: string;
        category?: string;
        tags?: string[];
        isPublic?: boolean;
        model?: string;
        variables?: PromptVariable[];
        versions?: Version[];
      }},
      context: GraphQLContext
    ): Promise<Prompt> => {
      // All user and project access checks removed.

      // Basic input validation remains for data integrity
      if (!input.title) {
        throw new Error("Prompt title is required.");
      }

      const newPromptData = {
        title: input.title,
        content: input.content || '',
        context: input.context || '',
        description: input.description,
        category: input.category,
        tags: input.tags || [],
        isPublic: input.isPublic || false,
        model: input.model || 'gpt-4o',
        userId: context.user?.id || 'anonymous', // Assign to current user if available, otherwise 'anonymous' (or handle as desired)
        projectId: input.projectId,
        variables: (input.variables || []).map(v => ({...v, id: v.id || generateUniqueId()})),
        versions: (input.versions || []).map(v => ({...v, id: v.id || generateUniqueId()})),
      };

      const newPrompt = await prisma.prompt.create({
        data: newPromptData,
      });

      return newPrompt as unknown as Prompt;
    },

    updatePrompt: async (
      _parent: any,
      { input }: { input: {
        id: string;
        title?: string;
        content?: string;
        context?: string;
        description?: string;
        category?: string;
        tags?: string[];
        isPublic?: boolean;
        model?: string;
        variables?: PromptVariable[];
      }},
      context: GraphQLContext
    ): Promise<Prompt> => {
      // All user and project access checks removed.

      const existingPrompt = await prisma.prompt.findUnique({
        where: { id: input.id },
      });

      if (!existingPrompt) {
        throw new Error("Prompt not found."); // Keep this for data integrity, as we can't update a non-existent prompt.
      }

      const updateData: any = { updatedAt: new Date() };
      if (input.title !== undefined) updateData.title = input.title;
      if (input.content !== undefined) updateData.content = input.content;
      if (input.context !== undefined) updateData.context = input.context;
      if (input.description !== undefined) updateData.description = input.description;
      if (input.category !== undefined) updateData.category = input.category;
      if (input.tags !== undefined) updateData.tags = input.tags;
      if (input.isPublic !== undefined) updateData.isPublic = input.isPublic;
      if (input.model !== undefined) updateData.model = input.model;
      if (input.variables !== undefined) {
        updateData.variables = input.variables.map(v => ({ ...v, id: v.id || generateUniqueId() }));
      }

      const updatedPrompt = await prisma.prompt.update({
        where: { id: input.id },
        data: updateData,
      });

      return updatedPrompt as unknown as Prompt;
    },

    deletePrompt: async (
      _parent: any,
      { id }: { id: string },
      context: GraphQLContext
    ): Promise<Prompt> => {
      // All user and project access checks removed.

      const existingPrompt = await prisma.prompt.findUnique({
        where: { id },
      });

      if (!existingPrompt) {
        throw new Error("Prompt not found."); // Keep for data integrity.
      }

      const deletedPrompt = await prisma.prompt.delete({
        where: { id },
      });

      return deletedPrompt as unknown as Prompt;
    },

    snapshotPrompt: async (
      _parent: any,
      { input }: { input: { promptId: string; notes?: string } },
      context: GraphQLContext
    ): Promise<Prompt> => {
      // All user and project access checks removed.

      const prompt = await prisma.prompt.findUnique({
        where: { id: input.promptId },
      });

      if (!prompt) {
        throw new Error("Prompt not found."); // Keep for data integrity.
      }

      const currentContent = prompt.content as string || '';
      const currentContext = prompt.context as string || '';
      const currentVariables = (prompt.variables as PromptVariable[]) || [];

      const newVersion: Version = {
        id: generateUniqueId(),
        content: currentContent,
        context: currentContext,
        variables: currentVariables.map(v => ({ ...v, id: v.id || generateUniqueId() })),
        createdAt: new Date().toISOString(),
        notes: input.notes || `Version saved on ${new Date().toLocaleString()}`,
      };

      const updatedVersions = [newVersion, ...(prompt.versions as Version[] || [])];

      const updatedPrompt = await prisma.prompt.update({
        where: { id: input.promptId },
        data: {
          versions: updatedVersions,
          updatedAt: new Date(),
        },
      });

      return updatedPrompt as unknown as Prompt;
    },

    restorePromptVersion: async (
      _parent: any,
      { input }: { input: { promptId: string; versionId: string } },
      context: GraphQLContext
    ): Promise<Prompt> => {
      // All user and project access checks removed.

      const prompt = await prisma.prompt.findUnique({
        where: { id: input.promptId },
      });

      if (!prompt) {
        throw new Error("Prompt not found."); // Keep for data integrity.
      }

      const versions = (prompt.versions as Version[]) || [];
      const versionToRestore = versions.find((v) => v.id === input.versionId);

      if (!versionToRestore) {
        throw new Error("Version not found."); // Keep for data integrity.
      }

      const updatedPrompt = await prisma.prompt.update({
        where: { id: input.promptId },
        data: {
          content: versionToRestore.content,
          context: versionToRestore.context,
          variables: versionToRestore.variables.map(v => ({ ...v, id: v.id || generateUniqueId() })),
          updatedAt: new Date(),
        },
      });

      return updatedPrompt as unknown as Prompt;
    },
  },
};

export default promptResolvers;
'''




'''
prisma/schema.prisma
// ---------------- Generator & Datasource ----------------
generator client {
provider = "prisma-client-js"
}

datasource db {
provider = "postgresql"
url      = env("DATABASE_URL")
}

// ---------------- Enums ----------------
enum UserRole {
ADMIN
MEMBER
}

enum WorkspaceRole {
OWNER
ADMIN
MEMBER
GUEST
}

enum ProjectRole {
OWNER
ADMIN
MEMBER
VIEWER
}

enum ProjectStatus {
PLANNING
ACTIVE
ON_HOLD
COMPLETED
ARCHIVED
CANCELLED
}

enum TaskStatus {
TODO
DONE
}

enum Priority {
LOW
MEDIUM
HIGH
}

enum SprintStatus { // NEW: Add SprintStatus enum to Prisma
PLANNING
ACTIVE
COMPLETED
}

enum DependencyType {
FINISH_TO_START
START_TO_START
FINISH_TO_FINISH
START_TO_FINISH
}

enum Plan {
FREE
PRO
ENTERPRISE
}

enum SubscriptionStatus {
ACTIVE
CANCELLED
PAST_DUE
UNPAID
}

enum ActivityType {
TASK_CREATED
TASK_UPDATED
TASK_COMPLETED
TASK_ASSIGNED
PROJECT_CREATED
PROJECT_UPDATED
DOCUMENT_CREATED
DOCUMENT_UPDATED
WIREFRAME_CREATED
WIREFRAME_UPDATED
COMMENT_ADDED
MEMBER_ADDED
MEMBER_REMOVED
}

// ---------------- Core Models ----------------

model User {
id          String   @id @default(cuid())
email       String   @unique
password    String?  // Added password field, made nullable for existing users or social logins
firstName   String?
lastName    String?
avatar      String?
firebaseUid String?  @unique
role        UserRole @default(MEMBER)
createdAt   DateTime @default(now())
updatedAt   DateTime @updatedAt

// Workspace relationships
workspaceMembers WorkspaceMember[]
ownedWorkspaces  Workspace[]       @relation("WorkspaceOwner")

// Project relationships
projectMembers ProjectMember[]
assignedTasks  Task[]          @relation("TaskAssignee")
createdTasks   Task[]          @relation("TaskCreator")

// Personal items
personalTasks      Task[]      @relation("UserPersonalTasks")
personalDocuments  Document[]  @relation("UserPersonalDocuments")
personalWireframes Wireframe[] @relation("UserPersonalWireframes")
personalPrompts    Prompt[]    @relation("UserPersonalPrompts")
personalSections   PersonalSection[] // Added for personal sections

// Activity & collaboration
activities Activity[]
comments   Comment[]
mentions   Mention[]

@@map("users")
}

model Workspace {
id          String   @id @default(cuid())
name        String
slug        String   @unique
description String?
avatar      String?
plan        Plan     @default(FREE)
createdAt   DateTime @default(now())
updatedAt   DateTime @updatedAt
ownerId     String
owner       User     @relation("WorkspaceOwner", fields: [ownerId], references: [id], onDelete: Cascade)
// New fields for Workspace
industry    String?
teamSize    String?
workFields  String[] // List of strings for work fields

members     WorkspaceMember[]
projects    Project[]
subscription Subscription?
settings     WorkspaceSettings?
// New: personal tasks can also be associated with a workspace (for context)
personalTasks Task[] @relation("WorkspacePersonalTasks")

@@map("workspaces")
}

model WorkspaceMember {
id          String        @id @default(cuid())
role        WorkspaceRole @default(MEMBER)
joinedAt    DateTime      @default(now())
workspaceId String
userId      String
workspace   Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)

@@unique([workspaceId, userId])
@@map("workspace_members")
}

model WorkspaceSettings {
id                    String    @id @default(cuid())
allowGuestAccess      Boolean   @default(false)
timeZone              String    @default("UTC")
workspaceId           String    @unique
workspace             Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

@@map("workspace_settings")
}

model Project {
id          String        @id @default(cuid())
name        String
description String?
color       String        @default("#4ECDC4")
status      ProjectStatus @default(PLANNING)
startDate   DateTime?
endDate     DateTime?
createdAt   DateTime      @default(now())
updatedAt   DateTime      @updatedAt
workspaceId String
workspace   Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

members   ProjectMember[]
tasks     Task[]      @relation("ProjectTasks")
documents Document[]  @relation("ProjectDocuments")
wireframes Wireframe[] @relation("ProjectWireframes")
prompts    Prompt[]   @relation("ProjectPrompts")
activities Activity[]
// New: Sprints and Sections for the project
sprints   Sprint[]
sections  Section[]

// Computed fields (via queries)
// taskCount Int? @default(0)
// doneTaskCount Int? @default(0)

@@map("projects")
}

model ProjectMember {
id        String      @id @default(cuid())
role      ProjectRole @default(MEMBER)
joinedAt  DateTime    @default(now())
projectId String
userId    String
project   Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)

@@unique([projectId, userId])
@@map("project_members")
}

// New model: Sprint for a project
model Sprint {
id          String     @id @default(cuid())
name        String
description String?
startDate   DateTime
endDate     DateTime
isCompleted Boolean    @default(false)
status      SprintStatus @default(PLANNING) // NEW: Add status field
createdAt   DateTime   @default(now())
updatedAt   DateTime   @updatedAt
projectId   String
project     Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)

tasks Task[] // Tasks belonging to this sprint
milestones Milestone[]

@@map("sprints")
}

model Milestone {
id          String   @id @default(cuid())
name        String
description String?
dueDate     DateTime
isCompleted Boolean  @default(false)
createdAt   DateTime @default(now())
updatedAt   DateTime @updatedAt

sprintId    String
sprint      Sprint   @relation(fields: [sprintId], references: [id], onDelete: Cascade)

@@map("milestones")
}

// New model: Section for a project
model Section {
id          String   @id @default(cuid())
name        String
order       Int      @default(0) // To define the order of sections (e.g., TODO, IN_PROGRESS)
createdAt   DateTime @default(now())
updatedAt   DateTime @updatedAt
projectId   String
project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

tasks Task[] // Tasks belonging to this section

@@map("sections")
}

// New model: PersonalSection for a user's personal tasks
model PersonalSection {
id        String   @id @default(cuid())
name      String
order     Int      @default(0)
createdAt DateTime @default(now())
updatedAt DateTime @updatedAt
userId    String
user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

tasks Task[] // Personal tasks belonging to this section

@@unique([userId, name]) // Personal section names must be unique for a user
@@map("personal_sections")
}

model Task {
id                   String           @id @default(cuid())
title                String
description          String?
status               TaskStatus       @default(TODO) // Keep TaskStatus, but actual section dictates visibility
priority             Priority         @default(MEDIUM)
dueDate              DateTime?
startDate            DateTime?
endDate              DateTime?
createdAt            DateTime         @default(now())
updatedAt            DateTime         @updatedAt
completed            Boolean         @default(false) // New field: indicates if the task is completed

// New fields for points and completion percentage
points               Int?             // Optional field for points, e.g., for Scrum stories or epics
completionPercentage Float?           // Optional field for tracking progress, 0.0 to 100.0

// Relationships for project tasks
projectId            String?
sprintId             String?          // New: for project tasks, nullable
sectionId            String?          // New: for project tasks, nullable
project              Project?         @relation("ProjectTasks", fields: [projectId], references: [id], onDelete: Cascade)
sprint               Sprint?          @relation(fields: [sprintId], references: [id], onDelete: SetNull) // If sprint is deleted, tasks remain but lose sprint
section              Section?         @relation(fields: [sectionId], references: [id], onDelete: SetNull) // If section is deleted, tasks remain but lose section

// Relationships for personal tasks
personalUserId       String?          // Original userId renamed for clarity for personal tasks
personalWorkspaceId  String?          // New: Workspace for personal tasks
personalSectionId    String?          // New: for personal tasks, nullable
personalUser         User?            @relation("UserPersonalTasks", fields: [personalUserId], references: [id], onDelete: Cascade)
personalWorkspace    Workspace?       @relation("WorkspacePersonalTasks", fields: [personalWorkspaceId], references: [id], onDelete: SetNull) // Link personal task to workspace
personalSection      PersonalSection? @relation(fields: [personalSectionId], references: [id], onDelete: SetNull) // Link personal task to personal section

// Common relationships (assignee, creator, subtasks, dependencies)
assigneeId           String?
creatorId            String
assignee             User?            @relation("TaskAssignee", fields: [assigneeId], references: [id])
creator              User             @relation("TaskCreator", fields: [creatorId], references: [id])

// Subtasks
parentId             String?
parent               Task?            @relation("TaskSubtasks", fields: [parentId], references: [id])
subtasks             Task[]           @relation("TaskSubtasks")

// Dependencies
dependencies         TaskDependency[] @relation("DependentTask")
dependents           TaskDependency[] @relation("PrecedingTask")

// Collaboration
comments             Comment[]
activities           Activity[]
labels               TaskLabel[]

// Ensure either it's a project task OR a personal task, but not both or neither
// This cannot be enforced directly in Prisma schema, but will be enforced via application logic
// @check((projectId != null AND personalUserId IS NULL) OR (projectId IS NULL AND personalUserId != null))

@@map("tasks")
}

model Label {
id          String      @id @default(cuid())
name        String
color       String
workspaceId String
tasks       TaskLabel[]

@@unique([name, workspaceId])
@@map("labels")
}

model TaskLabel {
taskId  String
labelId String
task    Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)
label   Label  @relation(fields: [labelId], references: [id], onDelete: Cascade)

@@id([taskId, labelId])
@@map("task_labels")
}

model Document {
id        String       @id @default(cuid())
title     String
content     Json?    // Make sure this is 'Json?' for optional content (e.g., for PDFs)
dataUrl     String?  // Keep this for PDFs
createdAt DateTime     @default(now())
updatedAt DateTime     @updatedAt

projectId String?
userId    String?

project      Project? @relation("ProjectDocuments", fields: [projectId], references: [id], onDelete: Cascade)
personalUser User?    @relation("UserPersonalDocuments", fields: [userId], references: [id], onDelete: Cascade)

comments   Comment[]
activities Activity[]

@@map("documents")
}

model Wireframe {
id        String   @id @default(cuid())
title     String
data      Json
thumbnail String?
createdAt DateTime @default(now())
updatedAt DateTime @updatedAt

projectId String?
userId    String?

project      Project? @relation("ProjectWireframes", fields: [projectId], references: [id], onDelete: Cascade)
personalUser User?    @relation("UserPersonalWireframes", fields: [userId], references: [id], onDelete: Cascade)

comments   Comment[]
activities Activity[]

@@map("wireframes")
}

model Comment {
id        String   @id @default(cuid())
content   String
createdAt DateTime @default(now())
updatedAt DateTime @updatedAt
authorId  String
author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

// Polymorphic
taskId      String?
documentId  String?
wireframeId String?
promptId    String?
task        Task?      @relation(fields: [taskId], references: [id], onDelete: Cascade)
document    Document?  @relation(fields: [documentId], references: [id], onDelete: Cascade)
wireframe   Wireframe? @relation(fields: [wireframeId], references: [id], onDelete: Cascade)
prompt      Prompt?    @relation(fields: [promptId], references: [id], onDelete: Cascade)

mentions Mention[]

@@map("comments")
}

model Mention {
id        String  @id @default(cuid())
commentId String
userId    String
comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)

@@unique([commentId, userId])
@@map("mentions")
}

model Activity {
id        String       @id @default(cuid())
type      ActivityType
data      Json
createdAt DateTime     @default(now())
userId    String
user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)

// Polymorphic
projectId   String?
taskId      String?
documentId  String?
wireframeId String?
promptId    String?
project     Project?   @relation(fields: [projectId], references: [id], onDelete: Cascade)
task        Task?      @relation(fields: [taskId], references: [id], onDelete: Cascade)
document    Document?  @relation(fields: [documentId], references: [id], onDelete: Cascade)
wireframe   Wireframe? @relation(fields: [wireframeId], references: [id], onDelete: Cascade)
prompt      Prompt?    @relation(fields: [promptId], references: [id], onDelete: Cascade)

@@map("activities")
}

model Subscription {
id                   String             @id @default(cuid())
plan                 Plan
status               SubscriptionStatus
currentPeriodEnd     DateTime
cancelAtPeriodEnd    Boolean            @default(false)
stripeCustomerId     String?
stripeSubscriptionId String?
createdAt            DateTime           @default(now())
updatedAt            DateTime           @updatedAt
workspaceId          String             @unique
workspace            Workspace          @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

@@map("subscriptions")
}

model Prompt {
id          String   @id @default(cuid())
title       String
content     String
context     String   @default("") // Added context field
description String?
category    String?
tags        String[]
isPublic    Boolean  @default(false)
createdAt   DateTime @default(now())
updatedAt   DateTime @updatedAt
model       String?  @default("gpt-4o") // Added model field, assuming it's a string with a default
variables   Json     @default("[]") // Added variables field as Json
versions    Json     @default("[]") // Added versions field as Json

projectId String?
userId    String?
project   Project? @relation("ProjectPrompts", fields: [projectId], references: [id], onDelete: Cascade)
user      User?    @relation("UserPersonalPrompts", fields: [userId], references: [id], onDelete: Cascade)

comments   Comment[]
activities Activity[]

@@map("prompts")
}

model TaskDependency {
id              String         @id @default(cuid())
precedingTaskId String
dependentTaskId String
type            DependencyType @default(FINISH_TO_START)
lag             Int            @default(0)

precedingTask Task @relation("PrecedingTask", fields: [precedingTaskId], references: [id], onDelete: Cascade)
dependentTask Task @relation("DependentTask", fields: [dependentTaskId], references: [id], onDelete: Cascade)

@@unique([precedingTaskId, dependentTaskId])
@@map("task_dependencies")
}
'''

'''
graphql/schema/schema.graphql

----------------------------------
Enums
----------------------------------

enum TaskStatusGQL { # Your TaskStatus enum from Prisma
TODO
DONE
}

enum PriorityGQL { # Your Priority enum from Prisma
LOW
MEDIUM
HIGH
}

enum SprintStatus { # New enum for Sprint status
PLANNING
ACTIVE
COMPLETED
}

enum UserRole {
ADMIN
MEMBER
}

enum WorkspaceRole {
OWNER
ADMIN
MEMBER
GUEST
}

enum ProjectRole {
OWNER
ADMIN
MEMBER
VIEWER
}

enum ProjectStatus {
PLANNING
ACTIVE
ON_HOLD
COMPLETED
ARCHIVED
CANCELLED
}

Consolidated TaskStatus (removing TaskStatusGQL in favor of this one)

enum TaskStatus {
TODO
DONE
}

Consolidated Priority (removing PriorityGQL in favor of this one)

enum Priority {
LOW
MEDIUM
HIGH
}

enum DependencyType {
FINISH_TO_START
START_TO_START
FINISH_TO_FINISH
START_TO_FINISH
}

enum Plan {
FREE
PRO
ENTERPRISE
}

enum SubscriptionStatus {
ACTIVE
CANCELLED
PAST_DUE
UNPAID
}

enum ActivityType {
TASK_CREATED
TASK_UPDATED
TASK_COMPLETED
TASK_ASSIGNED
PROJECT_CREATED
PROJECT_UPDATED
DOCUMENT_CREATED
DOCUMENT_UPDATED
WIREFRAME_CREATED
WIREFRAME_UPDATED
COMMENT_ADDED
MEMBER_ADDED
MEMBER_REMOVED
}

NEW: Prompt specific enums

enum PromptVariableType {
STRING
NUMBER
BOOLEAN
DATE
RICH_TEXT # For BlockNote content
LIST_OF_STRINGS
}

----------------------------------
Models
----------------------------------

type User {
id: ID!
email: String!
firstName: String
lastName: String
avatar: String
firebaseUid: String

password: String # Not typically exposed in GraphQL output types

role: UserRole!
createdAt: String!
updatedAt: String!

workspaceMembers: [WorkspaceMember]
ownedWorkspaces: [Workspace]
projectMembers: [ProjectMember]
assignedTasks: [Task]
createdTasks: [Task]
personalTasks: [Task]
personalDocuments: [Document]
personalWireframes: [Wireframe]
personalPrompts: [Prompt] # Added
personalSections: [PersonalSection] # New: For personal sections
activities: [Activity]
comments: [Comment]
mentions: [Mention]
}

type Workspace {
id: ID!
name: String!
slug: String!
description: String
avatar: String
plan: Plan!
createdAt: String!
updatedAt: String!
owner: User!

New fields for Workspace

industry: String
teamSize: String
workFields: [String!] # List of strings for work fields

members: [WorkspaceMember!]!
projects: [Project!]!
subscription: Subscription
settings: WorkspaceSettings
personalTasks: [Task] # New: Personal tasks can also be associated with a workspace
}

type WorkspaceMember {
id: ID!
role: WorkspaceRole!
joinedAt: String!
workspace: Workspace!
user: User!
}

type WorkspaceSettings {
id: ID!
allowGuestAccess: Boolean!
timeZone: String!
workspace: Workspace!
}

type Project {
id: ID!
name: String!
description: String
color: String!
status: ProjectStatus!
startDate: String
endDate: String
createdAt: String!
updatedAt: String!
workspace: Workspace!

members: [ProjectMember!]!
tasks: [Task!]!
documents: [Document!]!
wireframes: [Wireframe!]!
prompts: [Prompt!]!    # Added
activities: [Activity!]!
sprints: [Sprint!]!    # New: Sprints for the project
sections: [Section!]!  # New: Sections for the project

projectMemberCount: Int!
totalTaskCount: Int!
completedTaskCount: Int!
}

type ProjectMember {
id: ID!
role: ProjectRole!
joinedAt: String!
project: Project!
user: User!
}

New model: Sprint for a project

type Sprint {
id: ID!
name: String!
description: String
startDate: String!
endDate: String!
isCompleted: Boolean!
createdAt: String!
updatedAt: String!
project: Project!
tasks: [Task!]! # Tasks belonging to this sprint
milestones: [Milestone!]!
status: SprintStatus! # NEW: Add status to Sprint
}

type Milestone {
id: ID!
name: String!
description: String
dueDate: String! # ISO Date string
isCompleted: Boolean!
createdAt: String!
updatedAt: String!
sprint: Sprint! # Corrected: Reference Sprint directly, not SprintDetails
}

New model: Section for a project

type Section {
id: ID!
name: String!
order: Int! # To define the order of sections (e.g., TODO, IN_PROGRESS)
createdAt: String!
updatedAt: String!
project: Project!

tasks: [Task!]! # Tasks belonging to this section
}

New model: PersonalSection for a user's personal tasks

type PersonalSection {
id: ID!
name: String!
order: Int!
createdAt: String!
updatedAt: String!
user: User!
tasks: [Task!]! # Personal tasks belonging to this personal section
}

type Task {
id: ID!
title: String!
description: String
status: TaskStatus! # Using consolidated TaskStatus
priority: Priority! # Using consolidated Priority
dueDate: String
startDate: String
endDate: String
createdAt: String!
updatedAt: String!
completed: Boolean!

New fields for points and completion percentage

points: Int
completionPercentage: Float

Relationships for project tasks

project: Project
sprint: Sprint # New: for project tasks
section: Section # New: for project tasks

Relationships for personal tasks

personalUser: User # Original userId renamed for clarity for personal tasks
personalWorkspace: Workspace # New: Workspace for personal tasks
personalSection: PersonalSection # New: for personal tasks

Common relationships (assignee, creator, subtasks, dependencies)

assignee: User
creator: User!

parent: Task
subtasks: [Task!]!

dependencies: [TaskDependency!]!
dependents: [TaskDependency!]!

comments: [Comment!]!
activities: [Activity!]!
labels: [TaskLabel!]!
}

type Label {
id: ID!
name: String!
color: String!

workspaceId: String! # Typically exposed via the workspace object itself

workspace: Workspace! # Relation to Workspace
tasks: [TaskLabel!]!
}

type TaskLabel {
taskId: String!
labelId: String!
task: Task!
label: Label!
}

type Document {
id: ID!
title: String!
content: JSON # The BlockNote content is JSON
dataUrl: String # For PDF content
createdAt: String!
updatedAt: String!
type: String! # "doc" or "pdf"
projectId: ID
project: Project
personalUser: User

... other fields

}

type Wireframe {
id: ID!
title: String!
data: JSON!
thumbnail: String
createdAt: String!
updatedAt: String!

project: Project
personalUser: User

comments: [Comment!]!
activities: [Activity!]!
}

--- NEW TYPES FOR WIREFRAMES ---

type WireframeListItem {
id: ID!
title: String!
updatedAt: String!
thumbnail: String # Renamed from previewDataUrl
projectId: ID # To filter by project
}

input CreateWireframeInput {
projectId: ID!
title: String!
data: JSON! # Initial data for the wireframe
thumbnail: String # Optional thumbnail base64 string
}

input UpdateWireframeInput {
id: ID!
title: String
data: JSON # Optional, expects JSON data
thumbnail: String # Optional thumbnail base64 string
}

type Comment {
id: ID!
content: String!
createdAt: String!
updatedAt: String!
author: User!

task: Task
document: Document
wireframe: Wireframe
prompt: Prompt
mentions: [Mention!]!
}

type Mention {
id: ID!
comment: Comment!
user: User!
}

type Activity {
id: ID!
type: ActivityType!
data: JSON!
createdAt: String!
user: User!

project: Project
task: Task
document: Document
wireframe: Wireframe
prompt: Prompt
}

type Subscription {
id: ID!
plan: Plan!
status: SubscriptionStatus!
currentPeriodEnd: String!
cancelAtPeriodEnd: Boolean!
stripeCustomerId: String
stripeSubscriptionId: String
createdAt: String!
updatedAt: String!
workspace: Workspace!
}

NEW: Prompt related types

type PromptVariable {
id: ID!
name: String!
placeholder: String!
description: String
type: PromptVariableType!
defaultValue: String
source: JSON # This is the complex JSON structure defining how to resolve the variable
}

type Version {
id: ID!
content: String!
context: String!
variables: [PromptVariable!]!
createdAt: String!
notes: String
}

type Prompt {
id: ID!
title: String!
content: String!
context: String! # Added
description: String
category: String
tags: [String!]!
isPublic: Boolean!
createdAt: String!
updatedAt: String!
model: String # Added for model selection

projectId: ID # NEW: Added scalar projectId field
project: Project
user: User

comments: [Comment!]!
activities: [Activity!]!
variables: [PromptVariable!]! # Array of embedded variables
versions: [Version!]! # Array of embedded versions
}

type TaskDependency {
id: ID!
type: DependencyType!
lag: Int!

precedingTask: Task!
dependentTask: Task!
}

type WorkspaceData {
id: ID!
name: String!
description: String
industry: String
teamSize: String
workFields: [String!]
members: [WorkspaceMemberData!]!
projects: [ProjectData!]!
}

type WorkspaceMemberData {
id: ID! # This is the WorkspaceMember ID
role: WorkspaceRole!
user: UserPartial! # Partial user data
}

type UserPartial {
id: ID!
email: String!
firstName: String
lastName: String
}

type ProjectData {
id: ID!
name: String!
description: String
status: ProjectStatus!
projectMemberCount: Int!
totalTaskCount: Int!
completedTaskCount: Int!
}

type ProjectMemberDetails { # For ProjectDetails, more detailed than WorkspaceMemberData
id: ID! # ProjectMember ID
role: ProjectRole!
user: UserFullDetails! # More user info needed here
}

--- NEW TYPES FOR GANTT VIEW QUERY ---

type GanttTaskData { # Custom type to match Gantt library's Task structure
id: ID!
name: String!
start: String! # ISO Date string
end: String!   # ISO Date string
progress: Int!
type: String!  # "task", "milestone", "project" (for sprint parents)
sprint: ID     # The ID of the parent sprint (if type is task/milestone)
hideChildren: Boolean
displayOrder: Int

Add other relevant fields if you have them in Task/Milestone (e.g., description, assignee)

description: String
assignee: UserAvatarPartial
originalTaskId: ID # To link back to Task.id or Milestone.id
originalType: String # "TASK" or "MILESTONE"
}

type GanttDataResponse {
sprints: [SprintNameId!]! # List of sprints for filter dropdown
tasks: [GanttTaskData!]! # Flattened list of tasks/milestones for Gantt chart
}

type SprintDetails { # Update SprintDetails type
id: ID!
name: String!
description: String
startDate: String!
endDate: String!
isCompleted: Boolean!
status: SprintStatus! # Using the new SprintStatus enum
tasks: [TaskListView!]! # Tasks directly under this sprint
milestones: [Milestone!]! # NEW: Milestones directly under this sprint
}

You might also consider an ActivityDetails type if you uncomment it
type ActivityDetails {
id: ID!
type: ActivityType!
data: JSON!
createdAt: String!
user: UserFullDetails!
}

type ProjectDetails { # New type to represent the comprehensive data for a single project page
id: ID!
name: String!
description: String
status: ProjectStatus!
color: String!
createdAt: String!

Computed stats

totalTasks: Int!
completedTasks: Int!
inProgressTasks: Int!
overdueTasks: Int!
upcomingDeadlines: Int!
displayStatus: String! # Added for UI convenience, can be derived from status

members: [ProjectMemberDetails!]!
sprints: [SprintDetails!]!

activities: [ActivityDetails!]! # Uncomment if needed

}

type UserFullDetails {
id: ID!
email: String!
firstName: String
lastName: String
avatar: String # Added avatar
}

type UserAvatarPartial { # For assignee in tasks, similar to UserFullDetails but named for context
id: ID!
firstName: String
lastName: String
avatar: String
}

type SprintNameId { # For the dropdown filter
id: ID!
name: String!
}

type TaskListView { # Simplified Task type for list view
id: ID!
title: String!
description: String
status: TaskStatus! # Mapped from Prisma TaskStatus, using consolidated enum
priority: Priority! # Mapped from Prisma Priority, using consolidated enum
dueDate: String # YYYY-MM-DD
points: Int       # Added points field
completionPercentage: Float # Added completionPercentage field
assignee: UserAvatarPartial # Assignee details
completed: Boolean! # Derived field for UI
sprintId: ID # <--- ADD THIS IF NOT ALREADY PRESENT (CRITICAL for previous fixes)
sectionId: ID # <--- ADD THIS SO UI KNOWS THE TASK'S SECTION
}

type SectionWithTasks { # For project sections
id: ID!
name: String!
order: Int! # <--- ADD THIS FOR SECTION REORDERING
tasks: [TaskListView!]!
}

type PersonalSectionWithTasks { # For personal sections
id: ID!
name: String!
tasks: [TaskListView!]!
}

input DeleteSectionOptions {
deleteTasks: Boolean! # True to delete tasks, false to reassign
reassignToSectionId: ID # Required if deleteTasks is false
}

type ProjectTasksAndSectionsData {
sprints: [SprintNameId!]!
sections: [SectionWithTasks!]!
personalSections: [PersonalSectionWithTasks!]!
projectMembers: [ProjectMemberFullDetails!]!

defaultSelectedSprintId: ID # REMOVED: Managed on client

}

Input type for creating a task

input CreateProjectTaskInput {
projectId: ID!
sectionId: ID!
title: String!
description: String
status: TaskStatus # Using consolidated TaskStatus
priority: Priority # Using consolidated Priority
dueDate: String
startDate: String
endDate: String
assigneeId: ID
sprintId: ID
points: Int
parentId: ID # For subtasks, if you implement this in ListView
}

Input type for updating a task

input UpdateProjectTaskInput {
id: ID!
title: String # Changed from String! to String (optional, not nullable)
description: String
status: TaskStatus # Using consolidated TaskStatus
priority: Priority # Using consolidated Priority
dueDate: String # Changed to String (optional)
startDate: String
endDate: String
assigneeId: ID # Changed to ID (optional)
sprintId: ID # Changed to ID (optional)
points: Int # Changed to Int (optional)
parentId: ID
isCompleted: Boolean # NEW: For updating sprint completion status
sectionId: ID # <--- ADD THIS FOR MOVING TASKS BETWEEN SECTIONS
}

Input type for creating a sprint

input CreateSprintInput {
projectId: ID!
name: String!
description: String
startDate: String! # ISO Date string
endDate: String!   # ISO Date string
status: SprintStatus # NEW: Allow setting initial status
}

Input type for updating a sprint

input UpdateSprintInput {
id: ID!
name: String
description: String
startDate: String # ISO Date string
endDate: String   # ISO Date string
isCompleted: Boolean
status: SprintStatus # NEW: Allow updating status
}

type ProjectMemberFullDetails { # NEW: For project members list
id: ID! # This is the ProjectMember ID
role: ProjectRole!
user: UserFullDetails!
}

NEW TYPES FOR GANTT VIEW QUERY (from your provided schema, ensure they are complete)

type GanttTaskData {
id: ID!
name: String!
start: String! # ISO Date string (startDate)
end: String!   # ISO Date string (endDate or dueDate)
progress: Int!
type: String!  # "task", "milestone", "project" (for sprint groups)
sprint: ID     # The ID of the parent sprint (if type is task/milestone)
hideChildren: Boolean
displayOrder: Int
description: String
assignee: UserAvatarPartial

Add other relevant fields if you have them in Task/Milestone
For task updates, we need the original task ID, type, and sprint ID for context

originalTaskId: ID # To link back to Task.id or Milestone.id
originalType: String # "TASK" or "MILESTONE"
}

type GanttDataResponse {
sprints: [SprintNameId!]! # List of sprints for filter dropdown
tasks: [GanttTaskData!]! # Flattened list of tasks/milestones for Gantt chart
}

type SprintDetails { # Update SprintDetails type (used in getProjectDetails)
id: ID!
name: String!
description: String
startDate: String!
endDate: String!   # ISO Date string
isCompleted: Boolean!
status: SprintStatus!
tasks: [TaskListView!]! # Tasks directly under this sprint
milestones: [Milestone!]!
}

Input for creating a new task from Gantt (simplified)

input CreateGanttTaskInput {
projectId: ID!
sprintId: ID! # Tasks always belong to a sprint in Gantt context
name: String!
description: String
startDate: String!
endDate: String! # Use endDate here for Gantt's end
assigneeId: ID
progress: Int # For initial progress
type: String! # "task" or "milestone"
}

Input for updating a Gantt task/milestone

input UpdateGanttTaskInput {
id: ID! # ID of the original Task or Milestone
type: String! # "TASK" or "MILESTONE" - tells resolver which model to update
name: String
description: String
startDate: String
endDate: String # For task (maps to Task.endDate) or milestone (maps to Milestone.dueDate)
assigneeId: ID # For task only
progress: Int # For task only
}

Input for updating a sprint's dates (and other fields)

input UpdateSprintInput {
id: ID!
name: String
description: String
startDate: String # ISO Date string
endDate: String   # ISO Date string
isCompleted: Boolean
status: SprintStatus
}

--- NEW TYPES FOR DOCUMENTS ---
Minimal Document type for list view

type DocumentListItem {
id: ID!
title: String!
updatedAt: String! # For sorting/display
type: String! # "doc" or "pdf" (derived, if content is null assume PDF, else doc)
projectId: ID # To filter by project
}

input CreateDocumentInput {
projectId: ID!
title: String!
content: JSON # Expects Block[] as JSON
dataUrl: String # Optional for PDF
}

input UpdateDocumentInput {
id: ID!
title: String
content: JSON # Optional, expects Block[] as JSON
dataUrl: String # Optional for PDF
}

----------------------------------
NEW: PROMPT LAB INPUTS
----------------------------------

input CreatePromptVariableInput {
id: ID # Client-generated ID is fine for embedded JSON
name: String!
placeholder: String!
description: String
type: PromptVariableType!
defaultValue: String
source: JSON
}

input UpdatePromptVariableInput {
id: ID!
name: String
placeholder: String
description: String
type: PromptVariableType
defaultValue: String
source: JSON
}

input CreatePromptInput {
projectId: ID

userId: ID # Will be derived from context

title: String!
content: String
context: String
description: String
category: String
tags: [String!]
isPublic: Boolean
model: String
variables: [CreatePromptVariableInput!]
versions: [CreateVersionInput!]
}

input UpdatePromptInput {
id: ID!
title: String
content: String
context: String
description: String
category: String
tags: [String!]
isPublic: Boolean
model: String
variables: [UpdatePromptVariableInput!] # For updating the entire variables array
}

input CreateVersionInput { # For initial versions on prompt creation
id: ID
content: String!
context: String!
variables: [CreatePromptVariableInput!]!
createdAt: String # Will be Date.toISOString()
notes: String
}

input SnapshotPromptInput {
promptId: ID!
notes: String
}

input RestorePromptVersionInput {
promptId: ID!
versionId: ID!
}

----------------------------------
Root Queries
----------------------------------

type Query {

getGanttData(projectId: ID!, sprintId: ID): GanttDataResponse # NEW Query

getProjectTasksAndSections(projectId: ID!, sprintId: ID): ProjectTasksAndSectionsData

getProjectDetails(projectId: ID!): ProjectDetails

getWorkspaceData: WorkspaceData # New query
me: User

--- NEW DOCUMENT QUERIES ---

getProjectDocuments(projectId: ID!): [DocumentListItem!]! # Get list of documents for a project
getDocumentDetails(id: ID!): Document # Get full details of a single document

--- NEW WIREFRAME QUERIES ---

getProjectWireframes(projectId: ID!): [WireframeListItem!]! # Get list of wireframes for a project
getWireframeDetails(id: ID!): Wireframe # Get full details of a single wireframe

--- NEW PROMPT QUERIES ---

getProjectPrompts(projectId: ID): [Prompt!]! # Added projectId as optional for personal prompts
getPromptDetails(id: ID!): Prompt
resolvePromptVariable(projectId: ID, variableSource: JSON!, promptVariableId: ID): String
}

----------------------------------
Root Mutations (CRUD-style)
----------------------------------

type Mutation {
createProjectTask(input: CreateProjectTaskInput!): TaskListView! # New mutation
updateProjectTask(input: UpdateProjectTaskInput!): TaskListView! # New mutation

deleteProjectSection(id: ID!, options: DeleteSectionOptions): Section! # Updated mutation

createProjectSection(projectId: ID!, name: String!, order: Int): Section! # New mutation
updateProjectSection(id: ID!, name: String, order: Int): Section! # New mutation

createUser(email: String!, password: String, firstName: String, lastName: String, role: UserRole): User! # Added password to creation

setupWorkspace(
userId: ID!
workspaceName: String!
workspaceDescription: String
projectName: String!
projectDescription: String
industry: String
teamSize: String
workFields: [String!]
): Workspace! # Returns the created Workspace

createProject(
workspaceId: ID!
name: String!
description: String
): Project! # Returns the created Project

deleteProjectTask(id: ID!): TaskListView! # NEW: Mutation to delete a task

Sprint Mutations

createSprint(input: CreateSprintInput!): SprintDetails! # Returns the created sprint
updateSprint(input: UpdateSprintInput!): SprintDetails! # Returns the updated sprint
deleteSprint(id: ID!): SprintDetails! # Returns the deleted sprint

createGanttTask(input: CreateGanttTaskInput!): GanttTaskData! # NEW: Create a task/milestone for Gantt
updateGanttTask(input: UpdateGanttTaskInput!): GanttTaskData! # NEW: Update a task/milestone for Gantt

--- NEW DOCUMENT MUTATIONS ---

createDocument(input: CreateDocumentInput!): DocumentListItem! # Returns the created document item
updateDocument(input: UpdateDocumentInput!): DocumentListItem! # Returns the updated document item
deleteDocument(id: ID!): DocumentListItem! # Returns the deleted document item

--- NEW WIREFRAME MUTATIONS ---

createWireframe(input: CreateWireframeInput!): WireframeListItem! # Returns the created wireframe item
updateWireframe(input: UpdateWireframeInput!): WireframeListItem! # Returns the updated wireframe item
deleteWireframe(id: ID!): WireframeListItem! # Returns the deleted wireframe item

--- NEW PROMPT MUTATIONS ---

createPrompt(input: CreatePromptInput!): Prompt!
updatePrompt(input: UpdatePromptInput!): Prompt!
deletePrompt(id: ID!): Prompt!
snapshotPrompt(input: SnapshotPromptInput!): Prompt!
restorePromptVersion(input: RestorePromptVersionInput!): Prompt!
}

----------------------------------
Scalars
----------------------------------

scalar JSON
'''